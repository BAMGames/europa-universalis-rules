#!/usr/bin/perl

# TODO: clean files no more in manifest.txt

use Digest::MD5;
use Cwd qw(chdir);
use File::Basename;
use File::Path qw(make_path);
use File::Copy;
use strict;
use warnings;
use Data::Dumper;

my $manifest='pions/manifest.txt';
my $bitmapdir='pions/bitmap';
my $wanted='pions/wanted.txt';
my $index=$bitmapdir.'/index.txt';
my $url='';
my $indexed={};
my $index_mtime={};
my $index_sum={};
my $manifest_sum={};
my $baseUrl='http://old-lipn.univ-paris13.fr/~dubacq/europa/pions/';
open DOC,"doc/release.txt" or die "No release document";
my @linesdoc=<DOC>;
close DOC;
my $release='';
foreach my $releaseline (@linesdoc) {
  next unless $releaseline =~ /^release=(.*)/;
  chomp $releaseline;
  $release=$1.'/';
}
$baseUrl.=$release;
#my $baseUrl='file:///data/ro/';
my $specialprefix='FILEDOWNLOADER';
my $tmpFiles={};
my $count=0;
my $maxcount=0;
my $maxcountnumber=0;
$SIG{INT} = sub { &finish(2); };

$specialprefix=$ENV{'SPECIALPREFIX'} if defined($ENV{'SPECIALPREFIX'});

if (!(-d $bitmapdir)) {
  mkdir $bitmapdir or die "Cannot create directory $bitmapdir";
}

sub readIndex {
  open FILE,$index or return;
  while (<FILE>) {
    next unless (/^([0-9a-f]+) ([0-9]+) (.+)$/);
    $index_mtime->{$3}=$2;
    $index_sum->{$3}=$1;
  }
  close FILE;
}
sub sumFile {
  my $filename=shift @_;
  open FILE,$filename or return 'none';
  binmode(FILE);
  my $md5=Digest::MD5->new;
  $md5->addfile(*FILE);
  close(FILE);
  my $digest = $md5->hexdigest;
}
sub updateIndex {
  my $currentdir=shift @_;
  my $fulldir=$bitmapdir.'/'.$currentdir;
  my @dirlist;
  opendir(my $dh, $fulldir) or return;
  @dirlist=grep {!/^\./} readdir($dh);
  closedir($dh);
 FILE:
  foreach my $file (@dirlist) {
    my $filename=$fulldir.'/'.$file;
    my $key=$currentdir.($currentdir?'/':'').$file;
    if (-d $filename) {
      updateIndex($key);
      next;
    } elsif ($key ne 'index.txt') {
      my ($d,$i,$m,$nl,$u,$g,$rd,$s,$at,$mt,$ct,$bs,$bl) = stat($filename);
      $indexed->{$key}=1;
      if (defined($index_mtime->{$key})) {
        next FILE if $index_mtime->{$key} eq $mt;
      }
      my $digest=&sumFile($filename);
      $index_mtime->{$key}=$mt;
      $index_sum->{$key}=$digest;
      $indexed->{$key}=1;
    }
  }
}
sub readManifest {
  my $manifest=shift @_;
  open FILE,$manifest or die "Cannot read manifest $manifest";
  while (<FILE>) {
    next unless (/^([0-9a-f]+) (.) ([0-9]+) (.+)$/);
    $manifest_sum->{$4}=$1;
  }
  close FILE;
}
sub readWanted {
  my $wanted=shift @_;
  open FILE,$wanted or die "Cannot read wanted list $wanted";
  my @wanted=sort grep { chomp } <FILE>;
  close FILE;
  if ($wanted[0] eq 'all') {
    @wanted=sort keys %$manifest_sum;
  }
  return \@wanted;
}

sub dumpIndex {
  open FILE,'>',$index or return; # We are leaving, anyway
  foreach my $key (sort keys %$index_sum) {
    print FILE $index_sum->{$key}.' '.$index_mtime->{$key}.' '.$key."\n";
  }
  close FILE;
}
sub finish {
  my $x=shift @_;
  foreach my $file (keys %$tmpFiles) {
    unlink($file);
  }
  &dumpIndex();
  exit($x);
}
sub fail {
  print STDERR $specialprefix.'failed:'.$_[0]."\n";
}
sub info {
  print STDERR $specialprefix.$_[0]."\n";
}
sub success {
  my $w=shift @_;
  my $c=shift @_;
  if ($c < 100) {
    my ($filename,$directories,$suffix)=fileparse($w,'.png');
    print STDERR $specialprefix.'done:'.$filename."\n";
  } else {
    $count++;
    my $x=sprintf('count:download:%0*d',$maxcountnumber,$count).'/'.$maxcount;
    print STDERR $specialprefix.$x;
  }
}
sub notsuccess {
  my $w=shift @_;
  my ($filename,$directories,$suffix)=fileparse($w,'.png');
  print STDERR $specialprefix.$filename.":old version kept\n";
}
sub download {
  my ($f,$w)=@_;
  my ($filename,$directories,$suffix)=fileparse($w);
  (-d $directories) or make_path($directories);
  my $a=system('curl','-s','-o',$w,$baseUrl.$f);
  return ($a);
}
sub checkDownload {
  my @wanted=@{$_[0]};
  my $tofix=$_[1];
  my $todownload={};
  my $ok={};
  my $impossible={};
  foreach my $file (@wanted) {
    my $wsum='none';
    my $csum='none';
    $wsum=$manifest_sum->{$file} if defined($manifest_sum->{$file});
    $csum=$index_sum->{$file} if defined($index_sum->{$file});
    if ($wsum eq 'none') {
      $impossible->{$file}=1;
      next;
    }
    if ($wsum eq $csum) {
      $ok->{$file}=1;
      next;
    }
    $todownload->{$file}=1;
  }
  return ($todownload,$ok,$impossible);
}
sub checkManifest {
  # check for indexed files not present in the manifest; delete them
  # also list indexed files not matching the manifest.
  my $manifest=shift @_;
  my $todelete={};
  my $tofix={};
  foreach my $key (sort keys %$index_sum) {
    if (!defined($manifest_sum->{$key})) {
      $todelete->{$key}=1;
    } elsif ($manifest_sum->{$key} ne $index_sum->{$key}) { 
      $tofix->{$key}=1;
    }
  }
  return ($todelete,$tofix);
}
sub deleteFiles {
  my $deleteFiles=shift @_;
  my $deleteDirs={};
  my $success=1;
  foreach my $file (keys %$deleteFiles) {
    $success=unlink($bitmapdir.'/'.$file);
    if (!$success) {
      &fail($file);
      &finish(1);
    }
    $deleteDirs->{dirname($file)}=1;
  }
  while (scalar keys %$deleteDirs) {
    my $newDeleteDirs={};
    foreach my $dir (keys %$deleteDirs) {
      next if $dir eq '.';
      $newDeleteDirs->{dirname($dir)}=1 if rmdir($bitmapdir.'/'.$dir);
    }
    $deleteDirs=$newDeleteDirs;
  }
  &info('deleted');
}
sub doDownload {
  my $toDownload=shift @_;
  foreach my $file (sort keys %$toDownload) {
    my $wsum='none';
    my $csum='none';
    $wsum=$manifest_sum->{$file} if defined($manifest_sum->{$file});
    $csum=$index_sum->{$file} if defined($index_sum->{$file});
    my $dest=$bitmapdir.'/'.$file;
    my $tmp=$dest.'.tmp';
    $tmpFiles->{$tmp}=1;
    if (scalar keys %$toDownload < 100) {
      &info($file);
    }
    &download($file,$tmp);
    my $nsum=&sumFile($tmp);
    if ($wsum eq $nsum) {
      move($tmp,$dest) or die "Copy failed: $!";
      my ($d,$i,$m,$nl,$u,$g,$rd,$s,$at,$mt,$ct,$bs,$bl) = stat($dest);
      $index_sum->{$file}=$nsum;
      $index_mtime->{$file}=$mt;
      &success($file,scalar keys %$toDownload);
      delete $tmpFiles->{$tmp};
    } else {                    # Download failed
      if ($csum ne 'none') {
        unlink($tmp);
        &notsuccess($file);
      } else {
        unlink($tmp);
        &fail($file);
        &finish(1);
      }
    }
  }
}

sub main {
  &readIndex;
  &updateIndex('');
  foreach my $file (keys %$index_sum) {
    if (!defined($indexed->{$file})) {
      delete $index_sum->{$file};
      delete $index_mtime->{$file};
    }
  }
  &readManifest($manifest);
  my ($todelete,$tofix)=&checkManifest($manifest);
  my $wantedList=&readWanted($wanted);
  my ($todownload,$ok,$impossible)=&checkDownload($wantedList);
  if (scalar keys %$ok) {
    &info((scalar keys %$ok).' already downloaded');
  }
  if (scalar keys %$todownload) {
    &info((scalar keys %$todownload).' to download');
  }
  if (scalar keys %$impossible) {
    &info((scalar keys %$impossible).' unavailable');
    foreach my $key (sort keys %$impossible) {
      &fail($key);
    }
    &finish(1);
  }
  if (scalar keys %$todelete) {
    &info((scalar keys %$todelete).' to delete');
    &deleteFiles($todelete);
  }
  $maxcount=scalar keys %$todownload;
  if ($maxcount) {
    $maxcountnumber=int(0.00001+log($maxcount)/log(10))+1;
    &doDownload($todownload);
  }
  &finish(0);
}

&main();
