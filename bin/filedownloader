#!/usr/bin/perl

# TODO: clean files no more in manifest.txt

use Digest::MD5;
use Cwd qw(chdir);
use File::Basename;
use File::Path qw(make_path);
use File::Copy;
use strict;
use warnings;
use Data::Dumper;
use IO::Uncompress::Bunzip2 qw(bunzip2 $Bunzip2Error);

open DOC,"doc/release.txt" or die "No release document";
my @linesdoc=<DOC>;
close DOC;
my $release='';
foreach my $releaseline (@linesdoc) {
  next unless $releaseline =~ /^release=(.*)/;
  chomp $releaseline;
  $release=$1.'/';
}
$SIG{INT} = sub { &finish(2); };
my $specialprefix='FILEDOWNLOADER ';
$specialprefix=$ENV{'SPECIALPREFIX'} if defined($ENV{'SPECIALPREFIX'});

my $category;
my $baseUrl;
my $manifest;
my $bitmapdir;
my $wanted;
my $index;
my $url;
my $indexed;
my $index_mtime;
my $index_sum;
my $index_link;
my $manifest_sum;
my $manifest_link;
my $tmpFiles;
my $count;
my $maxcount;
my $maxcountnumber;

while (@ARGV) {
  $category=shift @ARGV;
  die if $category ne 'pions' and $category ne 'carte';
  $baseUrl='http://old-lipn.univ-paris13.fr/~dubacq/europa/'.$category.'/';
  $baseUrl.=$release;
  $manifest=$category.'/manifest.txt.bz2';
  $bitmapdir=$category.'/bitmap';
  $wanted=$category.'/wanted.txt';
  $index=$bitmapdir.'/index.txt';
  $url='';
  $indexed={};
  $index_mtime={};
  $index_sum={};
  $index_link={};
  $manifest_sum={};
  $manifest_link={};
  $tmpFiles={};
  $count=0;
  $maxcount=0;
  $maxcountnumber=0;
  if (!(-d $bitmapdir)) {
    mkdir $bitmapdir or die "Cannot create directory $bitmapdir";
  }
  &main();
}
sub readIndex {
  open FILE,$index or return;
  while (<FILE>) {
    next unless (/^([0-9a-f]+) ([0-9]+) "(.*)" (.+)$/);
    $index_mtime->{$4}=$2;
    $index_sum->{$4}=$1;
    $index_link->{$4}=$3;
  }
  close FILE;
}
sub sumFile {
  my $filename=shift @_;
  open FILE,$filename or return 'none';
  binmode(FILE);
  my $md5=Digest::MD5->new;
  $md5->addfile(*FILE);
  close(FILE);
  my $digest = $md5->hexdigest;
}
sub updateIndex {
  my $currentdir=shift @_;
  my $fulldir=$bitmapdir.'/'.$currentdir;
  my @dirlist;
  opendir(my $dh, $fulldir) or return;
  @dirlist=grep {!/^\./} readdir($dh);
  closedir($dh);
 FILE:
  foreach my $file (@dirlist) {
    my $filename=$fulldir.'/'.$file;
    my $key=$currentdir.($currentdir?'/':'').$file;
    if (-d $filename) {
      updateIndex($key);
      next;
    } elsif (-l $filename and $key ne 'index.txt') {
      my $link = readlink($filename);
      $indexed->{$key}=1;
      $index_sum->{$key}='L';
      $index_link->{$key}=$link;
      $index_mtime->{$key}=0;
    } elsif (-f $filename and $key ne 'index.txt') {
      my ($d,$i,$m,$nl,$u,$g,$rd,$s,$at,$mt,$ct,$bs,$bl) = stat($filename);
      $indexed->{$key}=1;
      $index_link->{$key}='';
      if (defined($index_mtime->{$key})) {
        next FILE if $index_mtime->{$key} eq $mt;
      }
      my $digest=&sumFile($filename);
      $indexed->{$key}=1;
      $index_sum->{$key}=$digest;
      $index_mtime->{$key}=$mt;
    }
  }
}
sub readManifest {
  my $manifest=shift @_;
  my $z = new IO::Uncompress::Bunzip2 $manifest or die "Cannot read manifest $manifest";
  while (<$z>) {
    if (/^(L) (.) ([^ ]+) (.+)$/) {
      $manifest_sum->{$4}=$1;
      $manifest_link->{$4}=$3;
    } elsif (/^([0-9a-f]+) (.) ([0-9]+) (.+)$/) {
      $manifest_sum->{$4}=$1;
      $manifest_link->{$4}='';
    }
  }
  $z->close();
}
sub readWanted {
  my $wanted=shift @_;
  open FILE,$wanted or die "Cannot read wanted list $wanted";
  my @wanted=sort grep { chomp } <FILE>;
  close FILE;
  if ($wanted[0] eq 'all') {
    @wanted=sort keys %$manifest_sum;
  }
  return \@wanted;
}

sub dumpIndex {
  open FILE,'>',$index or return; # We are leaving, anyway
  foreach my $key (sort keys %$index_sum) {
    print FILE $index_sum->{$key}.' '.$index_mtime->{$key}.' "'.$index_link->{$key}.'" '.$key."\n";
  }
  close FILE;
}
sub finish {
  my $x=shift @_;
  foreach my $file (keys %$tmpFiles) {
    unlink($file);
  }
  &dumpIndex();
  exit($x);
}
sub fail {
  print STDERR $specialprefix.'failed:'.$_[0]."\n";
}
sub info {
  print STDERR $specialprefix.$_[0]."\n";
}
sub success {
  my $w=shift @_;
  my $c=shift @_;
  if ($c < 100) {
    my ($filename,$directories,$suffix)=fileparse($w,'.png');
    print STDERR $specialprefix.'done:'.$filename."\n";
  } else {
    $count++;
    my $x=sprintf('count:download:%0*d',$maxcountnumber,$count).'/'.$maxcount;
    print STDERR ($specialprefix.$x)  if ($count%100==0);
  }
}
sub notsuccess {
  my $w=shift @_;
  my ($filename,$directories,$suffix)=fileparse($w,'.png');
  print STDERR $specialprefix.$filename.":old version kept\n";
}
sub download {
  my ($f,$w)=@_;
  my ($filename,$directories,$suffix)=fileparse($w);
  (-d $directories) or make_path($directories);
  my $a=system('curl','-s','-o',$w,$baseUrl.$f);
  return ($a);
}
sub checkDownload {
  my @wanted=@{$_[0]};
  my $todownload={};
  my $ok={};
  my $impossible={};
  foreach my $file (@wanted) {
    my $wsum='none';
    my $csum='none';
    $wsum=$manifest_sum->{$file}.$manifest_link->{$file} if defined($manifest_sum->{$file});
    $csum=$index_sum->{$file}.$index_link->{$file} if defined($index_sum->{$file});
    if ($wsum eq 'none') {
      $impossible->{$file}=1;
      next;
    }
    if ($wsum eq $csum) {
      $ok->{$file}=1;
      next;
    }
    $todownload->{$file}=1;
  }
  return ($todownload,$ok,$impossible);
}
sub checkManifest {
  # check for indexed files not present in the manifest; delete them
  # also list indexed files not matching the manifest.
  my $todelete={};             # present in any form, absent in manifest
  foreach my $key (sort keys %$index_sum) {
    if (!defined($manifest_sum->{$key})) {
      $todelete->{$key}=1;
    }
  }
  return $todelete;
}
sub deleteFiles {
  my $deleteFiles=shift @_;
  my $deleteDirs={};
  my $success=1;
  foreach my $file (keys %$deleteFiles) {
    $success=unlink($bitmapdir.'/'.$file);
    if (!$success) {
      &fail($file);
      &finish(1);
    }
    $deleteDirs->{dirname($file)}=1;
  }
  while (scalar keys %$deleteDirs) {
    my $newDeleteDirs={};
    foreach my $dir (keys %$deleteDirs) {
      next if $dir eq '.';
      $newDeleteDirs->{dirname($dir)}=1 if rmdir($bitmapdir.'/'.$dir);
    }
    $deleteDirs=$newDeleteDirs;
  }
  &info('deleted');
}
sub doDownload {
  my $toDownload=shift @_;
  foreach my $file (sort keys %$toDownload) {
    my $wsum='none';
    my $csum='none';
    $wsum=$manifest_sum->{$file} if defined($manifest_sum->{$file});
    $csum=$index_sum->{$file} if defined($index_sum->{$file});
    my $dest=$bitmapdir.'/'.$file;
    my $tmp=$dest.'.tmp';
    $tmpFiles->{$tmp}=1;
    if (scalar keys %$toDownload < 100) {
      &info($file);
    }
    if ($wsum eq 'L') {
      unlink($dest);
      my ($filename,$directories,$suffix)=fileparse($dest);
      (-d $directories) or make_path($directories);
      symlink $manifest_link->{$file},$dest;
      if (-l $dest) {
        my $link = readlink($dest);
        $indexed->{$file}=1;
        $index_sum->{$file}='L';
        $index_link->{$file}=$link;
        $index_mtime->{$file}=0;
        if ($index_link->{$file} eq $manifest_link->{$file}) {
          &success($file,scalar keys %$toDownload);
          next;
        } else {
          &finish(1);
        }
      }
    }
    &download($file,$tmp);
    my $nsum=&sumFile($tmp);
    if ($wsum eq $nsum) {
      unlink($dest);
      move($tmp,$dest) or die "Copy failed: $!";
      my ($d,$i,$m,$nl,$u,$g,$rd,$s,$at,$mt,$ct,$bs,$bl) = stat($dest);
      $index_sum->{$file}=$nsum;
      $index_link->{$file}='';
      $index_mtime->{$file}=$mt;
      &success($file,scalar keys %$toDownload);
      delete $tmpFiles->{$tmp};
    } else {                    # Download failed
      if ($csum ne 'none') {
        unlink($tmp);
        &notsuccess($file);
      } else {
        unlink($tmp);
        &fail($file);
        &finish(1);
      }
    }
  }
}

sub main {
  &readIndex;
  &updateIndex('');
  foreach my $file (keys %$index_sum) {
    if (!defined($indexed->{$file})) {
      delete $index_sum->{$file};
      delete $index_mtime->{$file};
      delete $index_link->{$file};
    }
  }
  &readManifest($manifest);
  my $todelete=&checkManifest();
  my $wantedList=&readWanted($wanted);
  my ($todownload,$ok,$impossible)=&checkDownload($wantedList);
  if (scalar keys %$ok) {
    &info((scalar keys %$ok).' already correct');
  }
  if (scalar keys %$todownload) {
    &info((scalar keys %$todownload).' to fix');
  }
  if (scalar keys %$impossible) {
    &info((scalar keys %$impossible).' unavailable');
    foreach my $key (sort keys %$impossible) {
      &fail($key);
    }
    &finish(1);
  }
  if (scalar keys %$todelete) {
    &info((scalar keys %$todelete).' to delete');
    &deleteFiles($todelete);
  }
  $maxcount=scalar keys %$todownload;
  if ($maxcount) {
    $maxcountnumber=int(0.00001+log($maxcount)/log(10))+1;
    &doDownload($todownload);
  }
  &finish(0);
}
