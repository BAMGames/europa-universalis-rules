#!/usr/bin/perl

# Idea: manage inside files (both written and read in one actor)
# Idea: pseudo-target sweep to remove unmakeable non-axiom files
# Idea: automatic diagnostic of out, junk and in files.

if ('' cmp 'DOC SYNOPSIS') {

=pod

=head1 NAME

plan - build files by applying a set of fixed rules

=head1 SYNOPSIS

=head2 RULES AND GOALS

plan [B<--mode>] I<modename> ... (see L</"MODES">).

plan [B<--target>] I<targetname> ... (see L</"GOALS AND TARGETS">).

plan [B<--hard>] [B<--hardrule> I<rule>] ... (see L</"LAZY AXIOMS">).

plan [B<-->] [I<goals>] (only goals after B<-->) (see L</"GOALS AND TARGETS">).

=head2 ACTIONS

plan B<[--]ignore>

plan B<[--]what>

plan B<[--]how> [I<goals>]

plan B<[--]why> [I<goals>]

plan B<--help>|B<--man>|B<--nroff>|B<--usage>

If a goal could be mistaken for another option, use the B<--> syntax.

=cut

}

use strict;
use warnings;
# Unicode safety
use utf8;
use Encode;

use JSON::PP;
use Data::Dumper;
use URI::Escape;
use Digest::MD5;
use Symbol 'gensym';
use File::Path qw(make_path remove_tree);
use Cwd;
use Term::ANSIColor;
# command execution
use IPC::Open3;
use POSIX qw(:sys_wait_h dup dup2);
use IO::Select;
use IO::Handle;

my ($execContext,$planContext,$outContext,$optionContext,$progContext);

$planContext=undef;
$progContext={'tmpfiles' => {}};

# Directories

my $axiomdir='plan/axioms';
my $rulefile='plan/rules';
my $actordir='plan/actors';
my $targetdir='plan/targets';
my $modesfile='plan/modes';

# Convenience

sub clone {
  my $obj=shift @_;
  my $t=ref($obj);
  return $obj unless ($t);
  return [map {&clone($_)} @$obj] if ($t eq 'ARRAY');
  my $n={};
  foreach my $key (keys %$obj) {
    $n->{$key}=&clone($obj->{$key});
  }
  return $n;
}

sub findGitTopdir {
  my $oldcwd='';
  my $cwd=getcwd();
  while ($oldcwd ne $cwd and !opendir(GITDIR,".git")) {
    chdir('..');
    $cwd=getcwd();
  }
  closedir(GITDIR);
  &finish(1,'Could not find the top-level directory') if $cwd eq $oldcwd;
  &out(1,'init','Relocated to project top directory');
}

sub addHash {
  my $hash={};
  foreach my $h (@_) {
    foreach my $k (keys %$h) {
      $hash->{$k}=1;
    }
  }
  return $hash;
}
sub addHashInPlace {
  my $hash=shift @_;
  foreach my $h (@_) {
    foreach my $k (keys %$h) {
      $hash->{$k}=$h->{$k};
    }
  }
}
sub subHash {
  my $hash={};    # TODO optimize if first hash much larger than second?
  my $init=shift @_;
  foreach my $k (keys %$init) {
    $hash->{$k}=1;
  }
  foreach my $h (@_) {
    foreach my $k (keys %$h) {
      delete ($hash->{$k}) if (exists($hash->{$k}));
    }
  }
  return $hash;
}

sub main {
  &initLogging();
  &findGitTopdir();
  &parseARGV();
  my $actions=$optionContext->{'actions'};
  if (defined($actions->{'help'})) {
    &usage($optionContext->{'help'});
  }
  &readRules();
  my $gitaxioms=&readAxiomsFromGit();
  &setupCommand();
  &writeModes();
  my $exceptions=&readFileList('plan/axioms');
  $exceptions->{'.tmp/mode'}=1; # TODO in fact all of progContext->{'tmpFiles'}
  my $notaxioms=&readFileList('plan/notaxioms');
  my $realaxioms=addHash($gitaxioms,$exceptions);
  $realaxioms=subHash($realaxioms,$notaxioms);
  $planContext={};
  &readCache($progContext,'junk');
  &cleanJunk($progContext,'junk');
  if (defined($actions->{'show-targets'})) {
    foreach my $key (sort keys %{$optionContext->{'standardTargets'}}) {
      print "$key\n" unless ($key =~ /^-/);
    }
    foreach my $key (sort keys %{$optionContext->{'targets'}}) {
      print "$key\n";
    }
  }
  if (defined($actions->{'clean'})) {
    # distclean = Remove everything in JUNK, NOT IN GOALS_MULTIMODE
    # clean = distclean finals (removes everything except files in finals)
    # sweep = distclean GENERABLE_MULTIMODE (removes everything no more generable)
    # GOALS_MULTIMODE = if all, GENERABLE_MULTIMODE sub EXCLUDED_FILES
    #                   if not all, INCLUDED_FILES sub EXCLUDED_FILES
    my $preserve=&clone($optionContext->{'includedFiles'});
    if ($optionContext->{'allFiles'} == 1) {
      $preserve=&addHash($preserve,&getGenerable($realaxioms,0));
    }
    $preserve=&addHash($preserve,$realaxioms);
    $preserve=&subHash($preserve,$optionContext->{'excludedFiles'});
    &readCache($progContext,'junk');
    my $remove=&subHash($progContext->{'junk'},$preserve);
    &removeFiles($progContext,'junk',$remove);
  }
  if (defined($actions->{'ignore'})) {
    my $generable=&getGenerable($realaxioms,1);
    foreach my $k (keys %{$generable}) {
      delete ($generable->{$k}) if $k =~ '^\.tmp';
    }
    $generable->{'.tmp'} = 1;
    $generable=&subHash($generable,$gitaxioms);
    my $data='/'.join("\n/",sort keys %$generable)."\n";
    &outputSection('.gitignore','plan',$data);
    &finish(0);
  }
  if (defined($actions->{'build'})) {
    my $steps=0;
    my $finished=0;
    $progContext->{'fingerprint'}={};
    $progContext->{'lazyfingerprint'}={};
    $planContext->{'generated'}={};
    &readCache($progContext,'fingerprint');
    &readCache($progContext,'lazyfingerprint');
    &addHashInPlace($progContext->{'fingerprint'},$progContext->{'lazyfingerprint'});
    my $narrowPlan;
    while (!$finished) {
      &preparePlan($realaxioms);
      $narrowPlan=&reducePlan();
      if (scalar keys %{$planContext->{'unbuildable'}}) {
        &explainPlan($narrowPlan);
        &finish(1,'Some files could not be built');
      }
      my $begin=0;
      my $xfinished=0;
      my $todo=undef;
      while (!$xfinished) {
        my $end;
        ($todo,$end)=&firstCompound($narrowPlan,$begin);
        if (defined($todo)) {
          $steps++;
          $xfinished=1;
        } else {
          $begin=$end;
          if ($begin >= scalar @$narrowPlan) {
            $xfinished=1;
            $finished=1;
          }
        }
      }
      &attempt($todo) if defined($todo);
    }
    if (!$steps) {
      if (scalar @$narrowPlan) { 
        &out(1,'display','Everything is up to date');
      } else {
        &out(1,'display','Nothing to be done');
      }
    }
  }
  if (defined($actions->{'what'})) {
    &preparePlan($realaxioms);
    my $narrowPlan=&reducePlan();
    &explainPlan($narrowPlan);
  }
  if (defined($actions->{'how'})) {
    &preparePlan($realaxioms);
    my $narrowPlan=&reducePlan();
    &graphviz($narrowPlan);
  }
  &finish(0);
}

&main();

# Logging
sub initLogging {

=pod

=head2 OUTPUT OPTIONS

B<--verbosity> I<category> I<level> Change the verbosity to I<level> in I<category>.

B<--I<category>> I<level> Shortcut, as above (see L</"VERBOSITY">).

If verbosity can be mistaken for a target name, use the B<--verbosity>
form, because the target will take precedence.

The verbosity level is a positive integer (including 0).

The various categories are :

=over

=item * B<init> initialization information (not useful)

=item * B<plan> informations about the building plan (can be very verbose)

=item * B<exec> informations about the commands launched by the plan

=item * B<err> the error output of the various commands

=item * B<out> the console output of the various commands

=item * B<display> the summary of the building (1: each class, 2: each subclass, 3: each item)

=back

Each rule can define a class and a subclass, and each item built will be
output in a synthetic manner. The default setting is 3 for B<display>
and 1 for B<out> and B<err>. A quiet effect can be obtained by setting
everything to 0.

=cut

  binmode(STDOUT,':utf8');
  binmode(STDERR,':utf8');
  binmode(STDIN,':utf8');
  my $verbosity={'exec'=>0,
                 'init'=>0,
                 'plan'=>0,
                 'out'=>1,
                 'err'=>1,
                 'dev'=>1,
                 'display'=>3};
  my $jsonEncoder=JSON::PP->new->utf8->pretty->canonical;
  $outContext={
               'color' => 1,
               'class' => '',
               'subclass' => '',
               'currentcol' => 0,
               'nomove' => 0,
               'countphase' => '',
               'lastcountcol' => 0,
               'verbosity' => $verbosity,
               'specialprefix' => qr/^PARTIAL PLAN:(.*)$/,
               'json' => $jsonEncoder,
              };
  &columns();
  $SIG{WINCH} = sub { &columns(); };
  $ENV{'SPECIALPREFIX'}="PARTIAL PLAN:";
  $outContext->{'color'}=0 unless -t STDOUT;
  &out(1,'init','Logging system ready');
}                               # DOC INSIDE
sub columns {
  require 'sys/ioctl.ph';
  my $winsize;
  die 'no TIOCGWINSZ' unless defined &TIOCGWINSZ;
  open(TTY, "+</dev/tty") or die "No tty: $!";
  unless (ioctl(TTY, &TIOCGWINSZ, $winsize='')) {
    die sprintf "$0: ioctl TIOCGWINSZ (%08x: $!)\n", &TIOCGWINSZ;
  }
  my ($row, $col, $xpixel, $ypixel) = unpack('S4', $winsize);
  $outContext->{'columns'}=$col;
}
sub finish {
  my $status=shift @_;
  &newline();
  if ($status) {
    print "Dying: ",@_,"\n";
  }
  foreach my $key (keys %{$progContext->{'tmpfiles'}}) {
    unlink($key);
  }
  exit($status);
}
sub newline {
  print "\n" if ($outContext->{'currentcol'});
  $outContext->{'currentcol'}=0;
  $outContext->{'nomove'}=0;
}
sub class {
  my $class=$_[0];
  if ($class ne $outContext->{'class'}) {
    &newline();
    $outContext->{'subclass'}='';
    print color 'bold' if ($outContext->{'color'});
    print $class,"\n";
    print color 'reset' if ($outContext->{'color'});
    $outContext->{'class'}=$class;
  }
}
sub subclass {
  my $subclass=$_[0];
  if ($subclass ne $outContext->{'subclass'}) {
    $outContext->{'subclass'}=$subclass;
    print color 'bold' if ($outContext->{'color'});
    &outDisplay($subclass);
    print color 'reset' if ($outContext->{'color'});
  }
}
sub outDisplay {
  my $str=join('',@_);
  my $storepos=0;
  if ($str =~ /^subclass:(.*)$/) {
    &subclass($1);
    return;
  }
  if ($str =~ /^count:(.*):([0-9\/]+)$/) {
    $str="$1:$2";
    my $oldcountphase=$outContext->{'countphase'};
    my $countphase="$1";
    $outContext->{'countphase'}=$countphase;
    if ($outContext->{'color'} == 0) {
      my $lastcountcol=$outContext->{'lastcountcol'}+1;
      if ($lastcountcol == 500) {
        $lastcountcol=0;
      }
      if ($countphase ne $oldcountphase) {
        $lastcountcol=0;
      }
      $outContext->{'lastcountcol'}=$lastcountcol;
      return if ($lastcountcol != 0);
    } else {
      if ($outContext->{'nomove'} == 1 and $countphase eq $oldcountphase) {
        $storepos=2;
      } else {
        $storepos=1;
      }
    }
  } else {
    $outContext->{'countphase'}='';
  }
  if ($storepos == 2) {
    $outContext->{'nomove'}=1;
    $outContext->{'currentcol'}=$outContext->{'lastcountcol'};
    print "\x1b[u";
  }
  my $len=length($str);
  my $margin=2;                 # Two chars required for []
  if ($outContext->{'currentcol'}+$margin+$len>$outContext->{'columns'}) {
    &newline();
  }
  if ($outContext->{'currentcol'}==0) {
    print '    ';
    $outContext->{'currentcol'}=4;
  }
  if ($storepos == 1) {
    $outContext->{'nomove'}=1;
    $outContext->{'lastcountcol'}=$outContext->{'currentcol'};
    print "\x1b[s";
  } elsif ($storepos != 2) {
    $outContext->{'nomove'}=0;
  }
  $outContext->{'currentcol'}+=2+$len;
  print '[',$str,']';
}
sub out {
  my $v=shift @_;
  my $n=shift @_;
  if ($outContext->{'verbosity'}->{$n}>=$v) {
    if (ref($_[0])) {
      $_[1] = Data::Dumper->Dump([$_[0]],[$_[1]]);
      shift @_;
    }
    if ($n eq 'display') {
      my $storepos=0;
      if ($v==1) {
        &class(@_);
      } elsif ($v==2) {
        &subclass(@_);
      } else {
        &outDisplay(@_);
      }
    } elsif ($n eq 'out') {
      &newline();
      print color 'blue' if ($outContext->{'color'});
      print '      ',@_,"\n";
      print color 'reset' if ($outContext->{'color'});
    } elsif ($n eq 'err' or $n eq 'dev') {
      &newline();
      print color 'red' if ($outContext->{'color'});
      print @_,"\n";
      print color 'reset' if ($outContext->{'color'});
    } else {
      &newline();
      print $n,':',@_,"\n";
    }
  }
}

# ARGV
sub initOptions {
  $optionContext={};
  $optionContext->{'verbosity'}=$outContext->{'verbosity'};
  $optionContext->{'availableModes'}=&readFileList($modesfile,1);
  $optionContext->{'availableModes'}->{'default'}=1;
  $optionContext->{'availableHelps'}={
                                      'help' => 1,
                                      'nroff' => 1,
                                      'man' => 1,
                                      'usage' => 1,
                                     };
  $optionContext->{'availableActions'}={
                                        'ignore' => 1,
                                        'what' => 1,
                                        'why' => 1,
                                        'how' => 1,
                                        'clean' => 1,
                                        'build' => 1,
                                        'show-targets' => 1,
                                       };
  $optionContext->{'excludedFiles'}={};
  $optionContext->{'includedFiles'}={};
  $optionContext->{'actions'}={};
  $optionContext->{'targets'}={};
  $optionContext->{'hardrules'}={};
  $optionContext->{'allFiles'}=0;
  $optionContext->{'lazy'}=1;
  $optionContext->{'standardTargets'}
    = {
       'all' => [ '--all' ],
       '--help' => [ '--help-action', 'help' ],
       '-h' => [ '--help-action', 'help' ],
       '--usage' => [ '--help-action', 'usage' ],
       'help' => [ '--help-action', 'man' ],
       '--man' => [ '--help-action', 'man' ],
       '--nroff' => [ '--help-action', 'nroff' ],
       'what' => [ '--action', 'what' ],
       '--what' => [ '--action', 'what' ],
       'how' => [ '--action', 'how' ],
       '--how' => [ '--action', 'how' ],
       'why' => [ '--action', 'why' ],
       '--why' => [ '--action', 'why' ],
       'ignore' => [ '--action', 'ignore' ],
       '--ignore' => [ '--action', 'ignore' ],
       'distclean' => [ '--action', 'clean' ],
       '--distclean' => [ '--action', 'clean' ],
       'clean' => [ '--action', 'clean', 'finals' ],
       'sweep' => [ '--action', 'clean', '--all' ],
      };
  my @target=&readDir('plan/targets');
  foreach my $t (@target) {
    $optionContext->{'targets'}->{$t}=1;
  }
}
sub checkOptionArg {
  my ($x,$option,$available,$where)=@_;
  my $optname=$option->[$x];
  &finish(1,"Wrong option: $optname must be followed by one argument") unless defined($option->[$x+1]);
  my $cat=$option->[$x+1];
  if ( $available and !defined($optionContext->{$available}->{$cat}) ) {
    &finish(1,"Wrong option: $optname must be followed by one of \"".join('" or "',sort keys %{$optionContext->{$available}}).'"');
  }
  $optionContext->{$where}->{$cat}=1 if $where;
  return $cat;
}
sub parseOptions {
  my ($desc,$options)=@_;
  my @option=@$options;
  &out(1,'init',"Treating $desc options");
  &out(2,'init',$options);
  my $x=0;
  while ($x < scalar @option) {
    my $arg=$option[$x];
    if ($arg eq '--') {
      $x++;
      while (defined($option[$x])) {
        $optionContext->{'includedFiles'}->{$option[$x]}=1;
      }
    } elsif ($arg eq '--help-action') {
      &checkOptionArg($x++,$options,'availableHelps','help');
      $optionContext->{'actions'}->{'help'}=1;
    } elsif ($arg eq '--action') {
      &checkOptionArg($x++,$options,'availableActions','actions');
    } elsif ($arg eq '--all') {
      $optionContext->{'allFiles'}=1;
    } elsif ($arg eq '--hard') {
      $optionContext->{'lazy'}=0;
    } elsif ($arg eq '--mode') {
      &checkOptionArg($x++,$options,'availableModes','mode');
    } elsif ($arg eq '--hardrule') {
      my $cat=&checkOptionArg($x++,$options,undef,'hardrules');
      if (ref($optionContext->{'hardrules'}->{$cat}) ne 'HASH') {
        $optionContext->{'hardrules'}->{$cat}={};
      }
    } elsif ($arg eq '--hardrule-limited') {
      &finish(1,"Wrong option: --hardrule-limited must be followed by two arguments") unless defined($option[$x+2]);
      my $cat=$option[++$x];
      my $level=$option[++$x];
      if (ref($optionContext->{'hardrules'}->{$cat}) ne 'HASH') {
        $optionContext->{'hardrules'}->{$cat}={};
      }
      $optionContext->{'hardrules'}->{$cat}->{$level}=1;
    } elsif ($arg =~ '--(\w+)' and defined($optionContext->{'verbosity'}->{$1})) {
      my $cat=$1;
      my $level=$option[++$x];
      &finish(1,"Wrong option: --$cat must be followed by an integer") unless $level =~ /^[0-9]+$/;
      $optionContext->{'verbosity'}->{$cat}=$level;
    } elsif ($arg eq '--verbosity') {
      &finish(1,"Wrong option: --verbosity must be followed by two arguments") unless defined($option[$x+2]);
      my $cat=&checkOptionArg($x++,$options,'verbosity');
      my $level=$option[++$x];
      &finish(1,"Wrong option: --verbosity must be followed by a category and an integer") unless $level =~ /^[0-9]+$/;
      $optionContext->{'verbosity'}->{$cat}=$level;
    } elsif ($arg eq '--exclude') {
      &checkOptionArg($x++,$options,undef,'excludedFiles');
    } elsif ($arg eq '--file') {
      &checkOptionArg($x++,$options,undef,'includedFiles');
    } elsif (
             defined($optionContext->{'targets'}->{$arg}) or
             defined($optionContext->{'standardTargets'}->{$arg}) or
             $arg eq '--target'
            ) {
      if ($arg eq '--target') {
        $arg=&checkOptionArg($x++,$options,'targets');
      }
      &parseTarget($arg);
    } else {
      $optionContext->{'includedFiles'}->{$arg}=1;
    }
    $x++;
  }
}
sub parseTarget {
  my $target=shift @_;
  if (ref($optionContext->{'targets'}->{$target}) ne 'ARRAY') {
    my $targetOptions=[];
    if (defined($optionContext->{'standardTargets'}->{$target})) {
      $targetOptions=$optionContext->{'standardTargets'}->{$target};
    } else {
      my $targetName='plan/targets/'.$target;
      open TARGET,$targetName or &finish(1,"Unable to open $targetName");
      while (my $l=<TARGET>) {
        chomp $l;
        push $targetOptions,map {&decodeGoalLine($_)} split(/ /,$l);
      }
      close TARGET;
      $optionContext->{'targets'}->{$target}=$targetOptions;
    }
    &parseOptions('target '.$target,$targetOptions);
  } else {
    &out(2,'init',"Skipping $target because it was already invoked");
  }
}
sub parseARGV {
  &initOptions();
  &parseOptions('command line',[@ARGV]);
  if (scalar keys %{$optionContext->{'actions'}} == 0) {
    $optionContext->{'actions'}->{'build'}=1;
  }
  if ( (
        defined($optionContext->{'actions'}->{'build'}) or
        defined($optionContext->{'actions'}->{'why'}) or
        defined($optionContext->{'actions'}->{'how'})
       ) and
       scalar keys %{$optionContext->{'includedFiles'}} == 0 and
       $optionContext->{'allFiles'} == 0 and
       defined($optionContext->{'targets'}->{'finals'}) ) {
    &parseOptions('backup plan #1',['--target','finals']);
  }
  if ( (
        defined($optionContext->{'actions'}->{'build'}) or
        defined($optionContext->{'actions'}->{'why'}) or
        defined($optionContext->{'actions'}->{'how'}) or
        defined($optionContext->{'actions'}->{'what'})
       ) and
       scalar keys %{$optionContext->{'includedFiles'}} == 0 ) {
    &parseOptions('backup plan #2',['--all']);
  }
  if (scalar keys %{$optionContext->{'mode'}} == 0) {
    $optionContext->{'mode'}->{'default'}=1;
  }
  &out(3,'init',$optionContext);
}

sub instantiateTargets {
  my ($targets,$goals,$generation,$axioms)=@_;
  my $goalHash={};
  my $targetHashes=[];
  my $all=0;
  foreach my $g (@$goals) {
    $goalHash->{$g}++;
  }
  foreach my $f (@$targets) {
    if ($f eq 'all') {
      my $allHash=subHash($generation,$axioms);
      push $targetHashes,$allHash;
    } else {
      push $targetHashes,&readFileList($targetdir.'/'.$f,1);
    }
  }
  &addHashInPlace($goalHash,@$targetHashes);
  return $goalHash;
}

# Help
sub usage {

=pod

=head2 HELP OPTIONS

B<--help>|B<-h> Generate this help (long version).

B<--usage> Generate this help (short version).

B<--man> Generate man page.

B<--nroff> Generate man page in NROFF format.

B<--help-action usage|help|man|nroff> One of the above.

The built-in target C<help> is equivalent to option B<--man>.

=cut

  ### usage ($option)
  ### Provides all kinds of textual help and stops
  my ($options)=@_;
  my $option=(sort keys %$options)[0];
  &out(1,'init',"Entering help with option $option");
  if (!defined($option)) {
    $option='usage';
  }
  my $cmd='pod2txt';
  my $release="0.6";
  my ($a,$out,$b);
  if ($option eq 'man'||$option eq 'nroff') {
    ($a,$out,$b)=@{&executeCommand('','pod2man',"$0",'--center','User commands','--release',$release)};
    if ($a==0 && $option eq 'man') {
      ($a,$out,$b)=@{&executeCommand($out,'nroff','-man','-')};
    }
  } else {
    ($a,$out,$b)=@{&executeCommand('','pod2text',"$0")};
  }
  if ($option eq 'usage') {
    $out =~ s/OPTIONS.*$//s;
  }
  if ($option ne 'man') {
    print $out;
  } else {
    open FILE,"|pager";
    print FILE $out;
    close FILE;
  }
  &finish(0);
}

# Command execution with stderr filtering
sub REAPER {
  my $child;
  while (($child = waitpid(-1, WNOHANG)) > 0) {
    &out(1,'exec',"Caught $child dying with status $?");
    $execContext->{'status'}->{$child} = $?;
    delete $execContext->{'children'}->{$child};
  }
  $SIG{CHLD} = \&REAPER;        # still loathe SysV
}
sub setupCommand {
  &out(1,'init','Initialize harness for command executions');
  select(STDERR); $| = 1;
  select(STDOUT); $| = 1;
  $execContext={
                'status' => {},
                'children' => {},
               };
  $SIG{CHLD} = \&REAPER;
  $SIG{INT} = sub {
    foreach my $pid (keys %{$execContext->{'children'}}) {
      kill 2,$pid;
    }
  }
}
sub errorCommand {
  my $lines=$_[0];
  foreach my $line (split /\n/m,$lines) {
    chomp $line;
    if ($line =~ $outContext->{'specialprefix'}) {
      my $part=$1;
      if ($part =~ /^done:(.*)$/) {
        $part=$1;
        push $execContext->{'partiallyDone'},$part;
        next;
      }
      &out(3,'display',$part);
    } else {
      &out(1,'err',$line);
    }
  }
}
sub execCommand {
  my $line;
  &out(1,'exec','Executing '.join(' ',@_));
  my $out = gensym;
  my $err = gensym;
  $execContext->{'partiallyDone'}=[];
  my $savedstdin=dup(0);
  my $pid = open3("<&".$savedstdin,$out, $err, @_);
  die "Could not fork: $!" unless defined($pid);
  return 1 if (!$pid);
  &out(1,'exec',"Forked pid $pid");
  $execContext->{'children'}->{$pid}=1;
  my $sel= new IO::Select;
  $sel->add($err,$out);
  while (scalar keys %{$execContext->{'children'}} > 0) {
    foreach my $readhandle ($sel->can_read(.5)) {
      my $length=sysread $readhandle,$line,4096;
      if ($length) {
        if (fileno($readhandle)==fileno($err)) {
          &errorCommand($line);
        } else {
          foreach my $linebit (split /\n/m,$line) {
            chomp $linebit;
            &out(1,'out',$linebit);
          }
        }
      }
    }
  }
  &out(3,'exec',$execContext);
  my $status=0+$execContext->{'status'}->{$pid};
  delete $execContext->{'status'}->{$pid};
  &out(1,'exec',"Command finished with status $status");
  return $status;
}
sub executeCommand {
  # a much simpler version for the manual page
  my $in=shift @_;
  &out(1,'exec',join(' ',@_));
  my $outputtext='';
  my $errtext='';
  my $pid=open3(\*INPUT, \*OUTPUT, \*ERR,@_);
  print INPUT $in if $in;
  close(INPUT);
  my $done=0;
  do {
    while (<OUTPUT>) {
      $outputtext.=$_;
    }
    while (<ERR>) {
      $errtext.=$_;
    }
    $done=waitpid($pid,WNOHANG);
  } until ($done>0);
  return [ $?, $outputtext, $errtext ];
}

# Disk Input/Output
sub fingerprintDir {
  my ($f)=@_;
  opendir (my $dh, $f) || return "$f:unreadable";
  my $hashing = Digest::MD5->new;
  my @files=();
  while (my $file=readdir $dh) {
    next if $file =~ /^\./;
    push @files,$f.'/'.$file;
  }
  closedir $dh;
  @files=sort @files;
  my $data;
  foreach my $f (@files) {
    if (-d $f) {
      $data=&fingerprintDir($f);
    } else {
      my ($d,$i,$m,$nl,$u,$g,$rd,$s,$at,$mt,$ct,$bs,$bl) = stat($f);
      $s='unk' unless defined($s);
      $data="$f:$s";
    }
    $hashing->add($data);
  }
  return $hashing->hexdigest;
}
sub fingerprint {
  my ($f)=@_;
  my $hash='0';
  return '0' unless (-e $f);
  return &fingerprintDir($f) if (-d $f);
  open FILE,"$f" or return "$f:0";
  my $hashing = Digest::MD5->new;
  $hashing->addfile(*FILE);
  $hash=$hashing->hexdigest;
  close FILE;
  return $hash;
}
sub fingerprintArray {
  # example: $rule, 'in'
  my @a=sort keys %{$_[0]->{$_[1]}};
  return 'none' unless (scalar @a);
  my $hashing = Digest::MD5->new;
  my $fp;
  foreach my $file (@a) {
    $fp=&fingerprint($file);
    $hashing->add($file.$fp);
  }
  return $hashing->hexdigest;
}

sub encodeGoalLine {
  join('',
       map { ($_ > 127 || $_ < 32 || $_ == 37 )?
               sprintf("%%(%d)", $_) :
                 chr($_)
               } unpack("W*", &decode_utf8($_[0]))); # unpack Unicode characters
}
sub decodeGoalLine {
  my $a=$_[0];
  $a =~ s/%\(([0-9]+)\)/chr($1)/eg;
  return $a;
}

sub writeCache {
  my ($cacheHash,$path)=@_;
  &out(3,'init',"Storing $path cache");
  my $cachehandle;
  if ($path eq 'lazyfingerprint') {
    make_path('plan');
    open $cachehandle,'>',"plan/$path" or &finish(1,"I cannot open my $path cache!");
  } else {
    make_path('.tmp');
    open $cachehandle,'>',".tmp/$path" or &finish(1,"I cannot open my $path cache!");
  }
  print $cachehandle $outContext->{'json'}->encode($cacheHash->{$path});
  $cachehandle->sync();
  close $cachehandle;
}
sub readCache {
  my ($cacheHash,$path)=@_;
  if (!defined($cacheHash)) {
    $cacheHash={};
  }
  if (!defined($cacheHash->{$path})) {
    $cacheHash->{$path}={};
  }
  &out(1,'init',"Reading $path cache");
  my $filepath=".tmp/$path";
  $filepath="plan/$path" if ($path eq 'lazyfingerprint');
  local $/;
  open (my $fh,'<',$filepath) or return;
  my $json=<$fh>;
  my $cache;
  eval {$cache=decode_json($json)};
  if ($@) {
    die "Corrupted file $filepath";
  }
  foreach my $f (keys %{$cache}) {
    $cacheHash->{$path}->{$f}=$cache->{$f};
  }
}
sub outputSection {
  my ($file,$section,$data)=@_;
  my @lines=();
  my $inside=0;
  my $done=0;
  if (-f $file and -r $file) {
    open FILE,$file;
    while (my $line=<FILE>) {
      chomp $line;
      if ($line =~ /^# start automatic section for $section$/) {
        $inside=1;
        if (!$done) {
          $done=1;
          push @lines,"# start automatic section for $section";
          push @lines,$data;
          push @lines,"# stop automatic section for $section";
        }
        next;
      }
      if ($line =~ /^# stop automatic section for $section$/) {
        $inside=0;next;
      }
      next if $inside==1;
      push @lines,$_;
    }
    if (!$done) {
      push @lines,"# start automatic section for $section";
      push @lines,$data;
      push @lines,"# stop automatic section for $section";
    }
    close FILE;
  } else {
    push @lines,"# start automatic section for $section\n";
    push @lines,$data;
    push @lines,"# stop automatic section for $section\n";
  }
  open FILE,">$file";
  foreach my $line (@lines) {
    next unless defined($line);
    print FILE $line."\n";
  }
  close FILE;
}
sub writeModes {
  &out(1,'init','Outputting modes');
  make_path('.tmp');
  open FILE,'>','.tmp/mode' or die 'I could not write to .tmp/mode';
  $progContext->{'tmpfiles'}->{'.tmp/mode'}=1;
  my @array=sort keys %{$planContext->{'mode'}};
  print FILE join("\n",@array),"\n";
  close FILE;
}

sub cleanJunk {
  my ($cacheHash,$path)=@_;
  &out(1,'init','Cleaning old files cache');
  foreach my $key (keys %{$cacheHash->{$path}}) {
    delete $cacheHash->{$path}->{$key} unless (-e $key);
  }
  &writeCache($cacheHash,$path);
}
sub removeFiles {
  my ($cacheHash,$path,$toRemove)=@_;
  my $count=0;
  foreach my $key (keys %$toRemove) {
    if (-l $key or -e $key) {
      $count++;
      if (-d $key) {
        remove_tree($key);
      } elsif (-e $key or -l $key) {
        unlink $key;
      }
      delete $cacheHash->{$path}->{$key};
    }
  }
  if ($count>1) {
    &out(3,'display',"removed ".($count-1)." old files");
    &writeCache($cacheHash,$path);
  } else {
    &out(3,'display',"all files already removed");
  }
}

sub readAxiomsFromGit {
  &out(1,'init','Reading axioms from git');
  # TODO use some form of exec command instead of open|
  open READ,"git ls-files -z|";
  my $a=<READ>;
  close READ;
  my @b=sort map {decode_utf8($_)} split("\x{00}",$a);
  &out(2,'init',\@b);
  my $hash={};
  foreach my $k (@b) {
    $hash->{$k}=1;
  }
  return $hash;
}
sub readRules {
  local $/;
  my $rules={};
  if ( -f $rulefile) {
    &out(1,'init','Read rules');
    open (my $fh,'<',$rulefile);
    my $json=<$fh>;
    close $fh;
    $rules=decode_json($json);
  }
  my @fragments=();
  if ( -d "$rulefile" ) {
    &out(1,'init','Read rules directory '."$rulefile");
    push @fragments,map { [ $_, "${rulefile}/$_" ] } sort &readDir($rulefile);
  }
  if ( -d "${rulefile}.d" ) {
    &out(1,'init','Read rules directory '."${rulefile}.d");
    push @fragments, map { [ $_, "${rulefile}.d/$_" ] } sort &readDir("${rulefile}.d");
  }
  foreach my $fragment (@fragments) {
    open (my $fh,'<',$fragment->[1]);
    my $json=<$fh>;
    close $fh;
    $rules->{$fragment->[0]}=decode_json($json);
  }
  foreach my $rulename (keys %$rules) {
    my $rule=$rules->{$rulename};
    $rule->{'actor'}=$rulename unless (defined($rule->{'actor'}));
    $rule->{'out'}=[] unless (defined($rule->{'out'}));
    $rule->{'junk'}=[] unless (defined($rule->{'junk'}));
    $rule->{'in'}=[] unless (defined($rule->{'in'}));
    if (!defined($rule->{'command'})) {
      $rule->{'command'}=[$actordir.'/'.$rule->{'actor'}];
      push $rule->{'in'},$rule->{'command'}->[0];
    }
    if (ref($rule->{'command'}) ne 'ARRAY') {
      my $com=$rule->{'command'};
      $rule->{'command'}=[map {&decodeGoalLine($_)} split(/ /,$com)];
    }
    $rule->{'arg'}=[] unless (defined($rule->{'arg'}));
    $rule->{'class'}='' unless (defined($rule->{'class'}));
    $rule->{'subclass'}='' unless (defined($rule->{'subclass'}));
  }
  $rules->{'AXIOM'}={'type' => 'axiom',
                     'actor' => 'AXIOM',
                     'class' => 'Checking axioms',
                     'subclass' => '',
                     'name' => 'AXIOM',
                     'command' => [$actordir.'/AXIOM']
                    };
  $optionContext->{'pristineRules'}=$rules;
}
sub readFileList {
  my ($path,$mandatory)=@_;
  my $hash={};
  if (open FILE,'<:encoding(utf8)',$path) {
    my $line;
    while ($line=<FILE>) {
      chomp $line;
      my $g=&decodeGoalLine($line);
      $hash->{$g}++;
    }
    close FILE;
  } else {
    &out(1,'err',"Could not open $path") if defined($mandatory);
  }
  return $hash;
}
sub readDir {
  my ($dir,$mandatory)=shift @_;
  my @dirlist;
  if (opendir(my $dh, $dir)) {
    @dirlist=grep {!/^\./} readdir($dh);
    closedir($dh);
  } else {
    &out(1,'err','Could not open directory $dir') if ($mandatory);
  }
  return @dirlist;
}

# Planning

sub actionKey {
  my $rule=shift @_;
  return $rule->{'key'} if (defined($rule->{'key'}));
  if (defined($rule->{'arg'}) and scalar @{$rule->{'arg'}} > 0) {
    $rule->{'key'}=join(' ',$rule->{'actor'},map {&encodeGoalLine($_)} @{$rule->{'arg'}});
  } else {
    $rule->{'key'}=$rule->{'actor'};
  }
  return $rule->{'key'};
}
sub recordGeneration {
  my $rule=shift @_;
  my $key=&actionKey($rule);
  my $gen=$rule->{'gen'};
  &out(2,'plan',"Rule $key is complete at generation $gen");
  $planContext->{'plan'}->{$key}=$rule;
  foreach my $outfile (keys %{$rule->{'out'}}) {
    if (defined($planContext->{'generated'}->{$outfile})) {
      goto OK if ($planContext->{'ignoreDuplicates'} == 1);
      if (defined($planContext->{'realAxioms'})
          and $planContext->{'generated'}->{$outfile} =~ /^AXIOM /) {
        if (defined($rule->{'lazy'})) {
          $planContext->{'lazy'}->{$outfile}=1;
          &out(1,'plan',"Seeing $outfile as lazy");
          goto OK;
        }
        &out(1,'err',"Non lazy-rule $key is regenerating axiom $outfile.");
      } else {
        &out(1,'err',"Rule $key is regenerating $outfile, already generated by ".$planContext->{'generated'}->{$outfile}.'.');
      }
      &finish(1,"Please fix your rules.");
    } else {
    OK:
      $planContext->{'generated'}->{$outfile}=$key;
      $planContext->{'generatedgen'}->{$outfile}=$gen;
      next;
    }
  }
  foreach my $outfile (keys %{$rule->{'junk'}}) {
    $planContext->{'junkable'}->{$outfile}=1;
  }
}

sub recordAxioms {
  foreach my $axiom (keys %{$_[0]}) {
    $planContext->{'usedRules'}->{'AXIOM'}++;
    my $axiomRule=&clone($planContext->{'pristineRules'}->{'AXIOM'});
    $axiomRule->{'type'}='simple';
    $axiomRule->{'out'}={$axiom => 1};
    if ($axiom eq $actordir.'/AXIOM') {
      $axiomRule->{'in'}={}
    } else {
      $axiomRule->{'in'}={$actordir.'/AXIOM' => 1};
    }
    $axiomRule->{'wanted'}={};
    $axiomRule->{'arg'}=[$axiom];
    $axiomRule->{'gen'}=0;
    &recordGeneration($axiomRule);
  }
}
sub sortRules {
  my $prule=$planContext->{'pristineRules'};
  foreach my $rulename (keys %$prule) {
    my $origrule=$prule->{$rulename};
    if (defined($origrule->{'lazy'})
        and $optionContext->{'lazy'} == 1) {
      if (defined($optionContext->{'hardrules'}->{$rulename})) {
        &out(1,'plan',"Rule $rulename is usually lazy, but hardened");
        if (scalar keys %{$optionContext->{'hardrules'}->{$rulename}}) {
          if (!defined($origrule->{'allowedargs'})) {
            $origrule->{'allowedargs'}=[keys %{$planContext->{'hardrules'}->{$rulename}}];
          } else {
            my $a={};
            foreach my $b (@{$origrule->{'allowedargs'}}) {
              $a->{$b}=1 if (defined($optionContext->{'hardrules'}->{$rulename}->{$b}));
            }
            $origrule->{'allowedargs'}=[keys %$a];
          }
        }
      } else {
        &out(1,'plan',"Skipping rule $rulename because of lazy mode");
        next;
      }
    }
    if (defined($origrule->{'mode'})) {
      my $modefound=0;
      my @modes=split(/,/,$origrule->{'mode'});
      foreach my $candidatemode (@modes) {
        $modefound++ if defined($planContext->{'mode'}->{$origrule->{'mode'}});
      }
      if ($modefound == 0) {
        &out(1,'plan',"Skipping rule $rulename because not in mode ".$origrule->{'mode'});
      next;
      }
    }
    $planContext->{'usedRules'}->{$rulename}=0;
    if ($origrule->{'type'} eq 'simple') {
      my $rule=&cleanRule(&clone($origrule));
      $rule->{'name'}=$rulename;
      $planContext->{'simpleRules'}->{&actionKey($rule)}=$rule;
      $planContext->{'usedRules'}->{$rulename}=1;
    } elsif ($origrule->{'type'} eq 'pattern') {
      push $planContext->{'patternRules'},$rulename;
    }
  }
}
sub cleanRule {
  my ($rule,@list)=@_;
  my $list=scalar @list;
  my $in={};
  my $out={};
  my $junk={};
  my $class=$rule->{'class'};
  if ($class =~ /\$/) {
    foreach my $counter (1..$list) {
      $class =~ s/\$$counter/$list[$counter-1]/ge;
    }
  }
  $rule->{'class'}=$class;
  my $subclass=$rule->{'subclass'};
  if ($subclass =~ /\$/) {
    foreach my $counter (1..$list) {
      $subclass =~ s/\$$counter/$list[$counter-1]/ge;
    }
  }
  $rule->{'subclass'}=$subclass;
  foreach my $file (@{$rule->{'in'}}) {
    foreach my $counter (1..$list) {
      $file =~ s/\$$counter/$list[$counter-1]/ge;
    }
    $in->{$file}=1;
  }
  if (defined($rule->{'infile'})) {
    my $hash=[];
    foreach my $file (@{$rule->{'infile'}}) {
      foreach my $counter (1..$list) {
        $file =~ s/\$$counter/$list[$counter-1]/ge;
      }
      &out(2,'plan',"Expanding infile $file");
      push $hash,readFileList($file);
    }
    &addHashInPlace($in,@$hash);
  }
  foreach my $file (@{$rule->{'junk'}}) {
    foreach my $counter (1..$list) {
      $file =~ s/\$$counter/$list[$counter-1]/ge;
    }
    $junk->{$file}=1;
  }
  foreach my $file (@{$rule->{'out'}}) {
    foreach my $counter (1..$list) {
      $file =~ s/\$$counter/$list[$counter-1]/ge;
    }
    $out->{$file}=1;
  }
  if (defined($rule->{'outfile'})) {
    my $hash=[];
    foreach my $file (@{$rule->{'outfile'}}) {
      foreach my $counter (1..$list) {
        $file =~ s/\$$counter/$list[$counter-1]/ge;
      }
      &out(2,'plan',"Expanding outfile $file");
      push $hash,readFileList($file);
    }
    &addHashInPlace($out,@$hash);
  }
  # Do something
  $rule->{'in'}=$in;
  $rule->{'out'}=$out;
  $rule->{'junk'}=$junk;
  $rule->{'wanted'}=&clone($in);
  return $rule;
}
sub developPatterns {
  my ($gen,$theorems)=@_;
  foreach my $rulename (@{$planContext->{'patternRules'}}) {
    my $rule=$planContext->{'pristineRules'}->{$rulename};
    my $pattern=$rule->{'pattern'};
    my $patternRE=qr/$pattern/;
    foreach my $theorem (keys %$theorems) {
      my @list = ($theorem =~ $patternRE);
      next unless @list;
      my $arg=$rule->{'argument'};
      foreach my $counter (1..scalar @list) {
        $arg =~ s/\$$counter/$list[$counter-1]/ge;
      }
      if (defined($rule->{'allowedargs'})) {
        my $ok=0;
        foreach my $allow (@{$rule->{'allowedargs'}}) {
          if ($allow eq $arg) {
            $ok=1;last;
          }
        }
        next unless $ok;
      }
      $rule->{'arg'}=[$arg];
      my $newrule=&cleanRule(&clone($rule),@list);
      $newrule->{'name'}=$rulename;
      my $key=&actionKey($newrule);
      $newrule->{'trigger'}=$theorem;
      foreach my $wanted (keys %{$newrule->{'wanted'}}) {
        if (exists($planContext->{'generatedgen'}->{$wanted})
            and $planContext->{'generatedgen'}->{$wanted} < $gen) {
          delete $newrule->{'wanted'}->{$wanted};
        }
      }
      $planContext->{'simpleRules'}->{&actionKey($newrule)}=$newrule;
      $planContext->{'usedRules'}->{$rulename}++;
    }
  }
}
sub resolveSimpleRules {
  my ($theorems)=@_;
  foreach my $key (keys %{$planContext->{'simpleRules'}}) {
    my $rule=$planContext->{'simpleRules'}->{$key};
    $rule->{'wanted'}=&subHash($rule->{'wanted'},$theorems);
    next if (scalar keys $rule->{'wanted'});
    # we found everyone!
    $planContext->{'completeRules'}->{$key}=$planContext->{'simpleRules'}->{$key};
    delete($planContext->{'simpleRules'}->{$key});
  }
}

sub eliminateCompleteRules {
  my ($gen)=@_;
  my $newtheorems={};
  my $mingen=1000000;
  foreach my $key (keys %{$planContext->{'completeRules'}}) {
    my $rule=$planContext->{'completeRules'}->{$key};
    if (defined($rule->{'mingen'}) and $gen<$rule->{'mingen'}) {
      $mingen=$rule->{'mingen'} if ($rule->{'mingen'}<$mingen);
      next;
    }
    $rule->{'gen'}=$gen;
    &recordGeneration($rule);
    foreach my $out (keys %{$rule->{'out'}}) {
      $newtheorems->{$out}=1;
    }
    delete($planContext->{'completeRules'}->{$key});
  }
  return ($mingen,$newtheorems);
}

sub preparePlan {
  my ($axioms,$ignoredup,$modes,$lazy)=@_; # include list of lazy here
  # ignoredup=0/undef => normal
  # ignoredup=1     => ignore duplicates, do not recompute order
  # ignoredup=2     => order being recomputed, do not ignore dup
  $planContext={};
  $planContext->{'pristineRules'}=&clone($optionContext->{'pristineRules'});
  $ignoredup=0 if (!defined($ignoredup));
  $planContext->{'ignoreDuplicates'}=$ignoredup;
  if ($ignoredup==0) {
    &out(1,'plan','Initializing plan');
    $planContext->{'lazy'}={};
  } elsif ($ignoredup==1) {
    &out(1,'plan','Quick multimode plan');
    $planContext->{'lazy'}={};
  } elsif ($ignoredup==2) {
    &out(1,'plan','Recomputing plan (with lazy axioms)');
    $planContext->{'lazy'}=$lazy;
    $axioms=&subHash($axioms,$lazy);
  }
  if (defined($modes)) {
    $planContext->{'mode'}=$modes;
  } else {
    $planContext->{'mode'}=&clone($optionContext->{'mode'});
  }
  &writeModes();
  $planContext->{'generated'}={};
  $planContext->{'junkable'}={};
  $planContext->{'plan'}={};
  $planContext->{'completeRules'}={};
  $planContext->{'simpleRules'}={};
  $planContext->{'patternRules'}=[];
  $planContext->{'usedRules'}={};
  $planContext->{'realAxioms'}=&clone($axioms);
  &out(3,'plan','Sorting rules');
  &sortRules();
  &out(2,'plan','Recording axioms');
  &recordAxioms($axioms);
  my $theorems=$axioms;
  my $mingen;
  my $gen=1;
  while ($gen<1000000) {
    &out(2,'plan',"Building theorems (generation $gen), still ".
         (scalar keys %{$planContext->{'simpleRules'}}).' rules to go');
    &developPatterns($gen,$theorems);
    &resolveSimpleRules($theorems);
    ($mingen,$theorems)=&eliminateCompleteRules($gen);
    &out(3,'plan','Found '.(scalar keys %$theorems).' new theorems');
    if (scalar keys %$theorems) {
      $gen++;
    } else {
      $gen=$mingen;
    }
  }
  if (scalar keys %{$planContext->{'lazy'}} > 0 and
      !defined($lazy) and
      $planContext->{'ignoreDuplicates'} == 0 ) {
    &preparePlan($axioms,2,
                 &clone($planContext->{'mode'}),
                 &clone($planContext->{'lazy'}));
  }
}
sub getGenerable {
  my ($axioms,$junk)=@_;
  my $lazy=$optionContext->{'lazy'};
  $optionContext->{'lazy'}=0;
  &preparePlan($axioms,1,$optionContext->{'availableModes'});
  my $generable={};
  foreach my $k (keys %{$planContext->{'generated'}}) {
    $generable->{$k}=1 unless (defined($axioms->{$k}));
  }
  if ($junk) {
    foreach my $k (keys %{$planContext->{'junkable'}}) {
      $generable->{$k}=1 unless (defined($axioms->{$k}));
    }
  }
  $optionContext->{'lazy'}=$lazy;
  return $generable;
}
sub explainPlan {
  my $narrowPlan=shift @_;
  &out(1,'plan','Explaining plan');
  foreach my $key (sort keys %{$planContext->{'simpleRules'}}) {
    my $rule=$planContext->{'simpleRules'}->{$key};
    &out(1,'err',"The rule $key did not complete.");
    foreach my $missingfile (sort keys %{$rule->{'wanted'}}) {
      &out(1,'err','The file "'.&encodeGoalLine($missingfile).'" was missing.');
    }
    &out(1,'err','This rule was triggered by "'.&encodeGoalLine($rule->{'trigger'}).'".') if ($rule->{'trigger'});
  }
  my $notUsed=[];
  my $usedRules=$planContext->{'usedRules'};
  foreach my $rulename (sort {$usedRules->{$b} <=> $usedRules->{$a} || $a cmp $b} keys %$usedRules) {
    my $count=$usedRules->{$rulename};
    if ($count) {
      &out(1,'out',"The rule named $rulename was used $count time".($count>1?'s.':'.'));
    } else {
      push $notUsed,$rulename;
    }
  }
  if (scalar @$notUsed > 0) {
    foreach my $rulename (@$notUsed) {
      &out(1,'err',"The rule named $rulename was not used at all.");
    }
  }
  foreach my $file (sort keys %{$planContext->{'unbuildable'}}) {
    &out(1,'err',"Impossible to build $file");
  }
  &out(1,'out',"Here is the plan so far:");
  my $begin=0;
  while ($begin < scalar @$narrowPlan) {
    my ($todo,$end)=&firstCompound($narrowPlan,$begin);
    &out(1,'out',&actionKey($todo));
    $begin=$end;
  }
}
sub reducePlan {
  &out(1,'plan','Narrowing build paths for selected goals');
  my $plan={};
  my $seen={};
  my $goals=&clone($optionContext->{'includedFiles'});
  if ($optionContext->{'allFiles'} == 1) {
    foreach my $key (keys %{$planContext->{'generated'}}) {
      $goals->{$key}=1;
    }
  }
  foreach my $key ($optionContext->{'excludedFiles'}) {
    delete $goals->{$key} if defined($goals->{$key});
  }
  my $requirement=&clone($goals);
  my $generation=$planContext->{'generated'};
  foreach my $key (keys %$requirement) {
    $seen->{$key}=1;
  }
  while (scalar keys %$requirement) {
    foreach my $file (keys %$requirement) {
      delete ($requirement->{$file});
      if (!exists($generation->{$file})) {
        &out(1,'err','No build path to "'.&encodeGoalLine($file).'" yet.');
        next;
      }
      my $actionkey=$generation->{$file};
      my $inFiles=$planContext->{'plan'}->{$actionkey}->{'in'};
      foreach my $in (keys %$inFiles) {
        $requirement->{$in}=1 unless $seen->{$in};
        $seen->{$in}=1;
      }
      $plan->{$actionkey}=1;
    }
  }
  $planContext->{'narrowPlan'}=$plan;
  my $planKeys=[sort {
    my $pa=$planContext->{'plan'}->{$a};
    my $pb=$planContext->{'plan'}->{$b};
    return ($pa->{'gen'} <=> $pb->{'gen'}) ||
      ($pa->{'actor'} cmp $pb->{'actor'}) ||
        ($pa->{'class'} cmp $pb->{'class'}) ||
          ($pa->{'subclass'} cmp $pb->{'subclass'}) ||
            ($pa->{'key'} cmp $pb->{'key'})
          } keys %$plan];
  &out(2,'plan',$planKeys);
  $planContext->{'unbuildable'}=&subHash($goals,$planContext->{'generated'});
  $planContext->{'goals'}=$goals;
  return $planKeys;
}

sub firstCompound {
  my ($plan,$begin) = @_;
  my $newplan=[];
  my $end=$begin+1;
  return (undef,$end) unless ($begin < scalar @$plan);
  my $planList=$planContext->{'plan'};
  my $maxend;
  my $first=$planList->{$plan->[$begin]};
  if (defined($first->{'maxargs'})) {
    $maxend=$begin+$first->{'maxargs'};
  } else {
    $maxend=$begin+100000000;
  }
  while (
         $end < scalar @$plan and
         $end < $maxend and
         $planList->{$plan->[$end]}->{'gen'} == $first->{'gen'} and
         $planList->{$plan->[$end]}->{'actor'} eq $first->{'actor'}
        ) {
    $end++;
  }
  my $candidates=[];
  # weed out already done candidates
  foreach my $i ($begin..$end-1) {
    my $rule=$planList->{$plan->[$i]};
    my $key=&actionKey($rule);
    my $fingerprintIn=&fingerprintArray($rule,'in');
    $rule->{'fingerprintIn'}=$fingerprintIn;
    my $fingerprintOut=&fingerprintArray($rule,'out');
    if (!defined($progContext->{'fingerprint'}->{$key})) {
      &out(2,'plan',"Considering $key (never seen)");
    } elsif ($progContext->{'fingerprint'}->{$key} eq "$fingerprintIn $fingerprintOut") {
      &out(3,'plan',"Not considering $key");
      next;
    } else {
      &out(2,'plan',"Considering $key (input or output changed)");
    }
    push $candidates,$key;
  }
  if (scalar @$candidates == 0) {
    return (undef,$end);
  }
  if (scalar @$candidates == 1) {
    return ($planList->{$candidates->[0]},$end);
  }
  my $compoundRule=&clone($first);
  delete $compoundRule->{'key'};
  my $individualRules=[];
  my $newargs=[];
  my $newins=[];
  my $newouts=[];
  my $newjunks=[];
  my $origin={};
  foreach my $key (@$candidates) {
    my $rule=$planList->{$key};
    push $newargs,@{$rule->{'arg'}};
    push $newins,$rule->{'in'};
    push $newouts,$rule->{'out'};
    push $newjunks,$rule->{'junk'};
    $origin->{$key}=1;
  }
  my $newin=addHash(@$newins);
  my $newout=addHash(@$newouts);
  my $newjunk=addHash(@$newjunks);
  $compoundRule->{'arg'}=$newargs;
  $compoundRule->{'origin'}=$origin;
  $compoundRule->{'in'}=$newin;
  $compoundRule->{'out'}=$newout;
  $compoundRule->{'junk'}=$newjunk;
  return ($compoundRule,$end);
}

# Execution control

sub registerSuccess {
  my ($rule)=@_;
  my $fingerprintOut=&fingerprintArray($rule,'out');
  my $fingerprintIn=$rule->{'fingerprintIn'};
  my $key=&actionKey($rule);
  &out(3,'plan',"Registering success of $key");
  $progContext->{'fingerprint'}->{$key}="$fingerprintIn $fingerprintOut";
  $progContext->{'lazyfingerprint'}->{$key}="$fingerprintIn $fingerprintOut" if defined($rule->{'lazy'});
}
sub attempt {
  my $rule=shift @_;
  my $key=&actionKey($rule);
  &out(2,'exec',"Preparing for $key");
  my @execLine=(@{$rule->{'command'}},@{$rule->{'arg'}});
  if ($rule->{'class'} ne '') {
    &out(1,'display',$rule->{'class'});
    if ($rule->{'subclass'} ne '') {
      &out(2,'display',$rule->{'subclass'});
    }
  } else {
    &out(1,'display',substr $key,0,72); # Default class = key
  }
  # in doubt, every possibly generated file will have been generated in the first
  # steps of the rule, so let's suppose they were.
  if ($rule ne 'AXIOM') {
    &addHashInPlace($progContext->{'junk'},$rule->{'out'});
    &addHashInPlace($progContext->{'junk'},$rule->{'junk'});
    &writeCache($progContext,'junk');
  }
  my $status=&execCommand(@execLine);
  if ($status) {
    foreach my $ok (@{$execContext->{'partiallyDone'}}) {
      my $okEscaped=$rule->{'actor'}.' '.&encodeGoalLine($ok); # actionKey
      if (exists($rule->{'origin'}->{$okEscaped})) {
        &registerSuccess($planContext->{'plan'}->{$okEscaped});
      } else {
        &out(1,'err',"$ok was registered as done, but no rule by that name exists");
      }
    }
    &writeCache($progContext,'fingerprint');
    &writeCache($progContext,'lazyfingerprint') if defined($rule->{'lazy'});
    &finish(1,"One rule failed with status $status");
  } else {
    if (exists($rule->{'origin'})) {
      foreach my $ok (keys %{$rule->{'origin'}}) {
        &registerSuccess($planContext->{'plan'}->{$ok});
      }
    } else {
      &registerSuccess($rule);
    }
    &writeCache($progContext,'fingerprint');
    &writeCache($progContext,'lazyfingerprint') if defined($rule->{'lazy'});
  }
}

# Graphing

sub graphviz {
  # TODO enhance.
  # Collapse all targets produced by patterns as one node.
  # Collapse all actions produced by patterns as one node.
  my ($plan,$gen)=@_;
  my $rule;
  my $name;
  my $rulenames={};
  print "digraph How {\n  node [shape=box];\n";
  foreach my $key (@$plan) {
    $rule=$planContext->{'plan'}->{$key};
    $name=$rule->{'name'}.' '.$rule->{'gen'};
    $rulenames->{$name}={} unless (defined($rulenames->{$name}));
    $rulenames->{$name}->{$key}=1;
  }
  foreach my $rulename (sort keys %$rulenames) {
    next if ($rulename eq 'AXIOM 0');
    my @keys=sort keys %{$rulenames->{$rulename}};
    my $caption;
    if (scalar @keys > 9) {
      my $len=scalar @keys;
      splice @keys,8,$len,"...total $len";
    }
    $caption=join('\n',@keys);
    print '  "'.$rulename.'" [ label="'.$caption.'"];'."\n";
  }
  print '  node [shape=box,fillcolor="#FFFFD0",style=filled];'."\n";
  my $filetoinofrule={};
  my $filetooutofrule={};
  my $files={};
  foreach my $key (@$plan) {
    $rule=$planContext->{'plan'}->{$key};
    $name=$key;
    $name=$rule->{'name'}.' '.$rule->{'gen'};;
    next if ($name eq 'AXIOM 0');
    foreach my $file (keys %{$rule->{'out'}}) {
      if (!defined($filetooutofrule->{$file})) {
        $filetooutofrule->{$file}={};
      }
      $filetooutofrule->{$file}->{$name}=1;
      $files->{$file}=1;
    }
    foreach my $file (keys %{$rule->{'in'}}) {
      if (!defined($filetoinofrule->{$file})) {
        $filetoinofrule->{$file}={};
      }
      $filetoinofrule->{$file}->{$name}=1;
      $files->{$file}=1;
    }
  }
  my $alias={};
  my $nodes={};
  foreach my $file (keys %$files) {
    if (!defined($filetooutofrule->{$file})) {
      $filetooutofrule->{$file}={};
    }
    if (!defined($filetoinofrule->{$file})) {
      $filetoinofrule->{$file}={};
    }
    my $data='IN:'.join("\n",sort keys %{$filetoinofrule->{$file}})."\n";
    $data.='OUT:'.join("\n",sort keys %{$filetooutofrule->{$file}});
    my $hashing = Digest::MD5->new;
    $hashing->add($data);
    my $node='NODE'.$hashing->hexdigest;
    $alias->{$file}=$node;
    $nodes->{$node}={} unless defined($nodes->{$node});
    $nodes->{$node}->{$file}=1;
  }
  foreach my $node (keys %$nodes) {
    my @keys=sort keys %{$nodes->{$node}};
    my $caption;
    if (scalar @keys > 9) {
      my $len=scalar @keys;
      splice @keys,8,$len,"...total $len";
    }
    $caption=join('\n',@keys);
    print $node.' [ label="'.$caption.'"];'."\n";
  }
  my $links={};
  foreach my $key (@$plan) {
    $rule=$planContext->{'plan'}->{$key};
    $name=$rule->{'name'}.' '.$rule->{'gen'};
    next if ($name eq 'AXIOM 0');
    foreach my $file (keys %{$rule->{'out'}}) {
      $links->{$name}->{$alias->{$file}}=1;
    }
    foreach my $file (keys %{$rule->{'in'}}) {
      $links->{$alias->{$file}}->{$name}=1;
    }
  }
  foreach my $start (sort keys %$links) {
    foreach my $end (sort keys %{$links->{$start}}) {
      print '  "'.$start.'" -> "'.$end.'";'."\n";
    }
  }
  print "}\n";
}

# Documentation

if ('' eq 'DOC PRINCIPLES') {
  1;

=pod

=head1 PRINCIPLE

TODO

=head1 RULES

A rule is the description of an action that can be done.

A rule has a name that must be unique, and properties. The values of
these properties are either integer, strings or arrays of strings.

The C<plan/rules> file contains all the rules in JSON format.

A rule basically must have an actor (a script or program, stored in
C<plan/actors> directory with its name in the C<actor> property. The
actor is executed whenever the rule may apply (see below). The program
stops if an actor returns with an error. During the execution of the
actor, its standard input is still accessible to the actor. Standard
output is written in blue, so as to be more detectable, and standard
error in red, except for some messages pertaining to the communication
between the I<plan> utility and the actors.

=head2 RULES INPUT, OUTPUT AND JUNK

A simple rule will apply as soon as its C<in> files are available, and
after the actor has run without errors, the C<out> files are considered
to be produced (even if they are absent on the filesystem).

The list of C<in> files is computed from the C<in> property of the rule
plus the contents of the files mentioned in the C<infile>
property. Likewise, the list of C<out> files comes from the C<out>
property and the contents of the files listed in the C<outfile>
property.

The C<infile> and C<outfile> are in a very simple format: one file name
per line, with %(hexadecimal) escaping. A file name with a newline in it
could be given as C<file%(0A)name>, for example. Such a file name is not
recommended anyway. C<infile> and C<outfile> properties are evaluated
before each rule application (so several times per run), in case one
script changes the contents of the files.

TODO JUNK

=head2 RULES TRIGGERING AND COMPOUNDING

Starting from the axioms (see L</"AXIOMS">) the I<plan> utility will
build a plan targetting the goals indicated by the user. The plan is a
succession of rules necessary in order to build the required goals. Each
rule retains a fingerprint that depends on its C<in> files before
execution and its C<out> files after execution. If one of these changed,
or the rule was never run, then the rule is not correctly
fingerprinted. The first rule in the topologic order that is not
correctly fingerprinted will be selected for execution.

To gain time, and because executing the same actor for several targets
at once, if the first rules all have the same actor and no
interdependencies, they are compound: the actor is only run once with
several arguments (the C<arg> property of the rule). This however is
limited by the C<maxargs> property (this limits the number of arguments
given to the compound actor: with 1, each rule remains executed
individually).

After each execution the plan is recomputed. Since the plan is mostly
identical, the first (compound) rules have been done and need not be
redone. Working piece by piece, the plan is fully executed.

There are theoretical possibilities that the plan never ends, if a rule
keeps changing its input files list.

=head2 PATTERN RULES vs SIMPLE RULES

TODO

=head1 POSSIBLE ACTIONS

The actions are chose with B<--action I<actionname>>, or more often by
an alias. An action will always be selected.

B<build> is the default action if none is explicitely selected. This
action will build the selected goals (see L</"GOALS AND TARGETS">).

B<ignore> will build a C<.gitignore> file (preserving user-edited
parts). Goals are irrelevant for this action.

B<what> will explain what this utility plans to do to build the selected
targets.

B<why> will explain what can be derived from the selected targets. For
example, C<plan why foo.c> may explain that C<foo.c> is compiled to
C<foo.o>, linked to C<something.o> as C<foo>, and then run to produce
C<foo.lib>. The output is in graphviz format.

B<how> will explain from what a selected target is derived. For example,
C<plan how foo.c> may show that C<foo.c> is in fact generated from
C<foo.in> and C<foo_stub.c>, the last one being generated from
C<stub.sh>.

B<clean> will clean the selected targets (see L</"CLEANING">).

B<show-targets> will output (one name per line) the built-in targets and
the user targets. This can be used to build command-line completion, for
example.

=head1 CLEANING

An index of all files built is kept, and cleaning is basically removing
all files built. The action is B<--action clean> or equivalently the
target B<distclean>.

When adding goals, these goals will be preserved from being removed (as
are all axioms). As a side-effect, B<--exclude I<filename>> will
actually add I<filename> to the list of the files to be removed.

The default target B<clean> will add the B<finals> target to the goals
(and thus preserve all the files built by finals). The default target
B<sweep> will add all generable files to the targets, which means that
it will remove all files that are no more generable.

Note that the junk files are not considered as generable, and thus will
be removed.

=head1 LAZY AXIOMS

A lazy axiom is an axiom that is version-controlled, but may be rebuilt
from others. For some reason (because it needs special tools to build,
because it is very long or expensive), it is in fact a theorem that is
delivered as an axiom. It can be used for building, but some manual
action must be made to rebuild it.

A rule that produces a I<lazy axiom> is a I<lazy rule>. A lazy rule will
be ignored unless the B<--hard> option is enabled, or the B<--hardrule>
option with the specific name of the rule. The name of the rule is the
actor name followed by the argument(s) of the actors. Moreover, the lazy
rule fingerprint will be stored in C<plan/lazyfingerprint> instead of
being stored in a temporary location. If C<plan/lazyfingerprint> is
under version control also, the file will not be redone if it depends
only on identical files. For example, an archive file of results shipped
in the project for commodity could be regenerated only if the archived
files change. If none of the archived files change, then the fingerprint
of the rule will be identical to the stored one, and the archive will
not be regenerated (archive files tend to differ in result even if
archiving the same contents, which is a pain for keeping them under
version control).

An axiom regenerated by a lazy rule will not generate any warning.
An axiom regenerated by an ordinaru rule will generate a warning.

=head2 EXAMPLE

The following rule BITMAP is defined:

=over

=item * pattern : "(.*).eps"

=item * argument : "$1", actor : "BITMAPPER"

=item * in : "$1.eps", out : "$1.png"

=back

C<plan/actor/BITMAPPER test> is supposed to turn C<test.eps> in
C<test.png>.  However, BITMAPPER may be available only on some
platforms, or just too long to run for C<test.png> not to be stored in
the VCS. On one hand, the command C<plan --hard test.png> or
equivalently C<plan --hardrule "BITMAPPER"> or also C<plan
--hardule-limited BITMAPPER test> will rebuild C<test.png> from
C<test.eps>. On the other hand, C<plan all> or even C<plan test.png>
will just ignore the rule (C<test.png> is, after all, an axiom).

Note that the third form will ignore C<BITMAPPER otherfile>. The option
C<--hardrule-limited NAME ARGUMENT> can be given several times (even
with the same C<NAME>). This option applies only for pattern rules;
simple rules have a unique name and are therefore enabled or disabled by
C<--hardrule>.

Another possibility is to put C<test.png> in C<plan/notaxioms>. However,
in this case, on a new installation of the project, C<test.png> will
always be rebuilt even if already present. C<plan/notaxioms> just
disconnects the git status and the axiom status.

=head1 EXPLAINING

The B<--why> and B<--how> specifiers will disable file generation and
explain by a simple graph which file is output starting from the
specified goals (B<--why>) or an input from the specified goals
(B<--how>). The graph is in I<graphviz> format.

=head1 GOALS AND TARGETS

The target files are options (they can be separated by spaces or by
newlines). The names may be escaped by using the %(hexadecimal) notation.
You will most probably never encounter that.

Files can be included with option B<--file> or simply their name if this
does not conflict with something else, such as a target's name. They can
also be excluded with option B<--exclude>, which does not seem very
useful, unless the option B<--all> is also used. This option (also
B<all>) includes all possibly generated files.

The target names are usually sufficient to use them as goals; if needed,
use B<--target I<targetname>>. However, it's best not to call your
target '--verbosity' or 'all' (or any other name already taken).

If no goals are given and one is required (for actions I<build>, I<why>
and I<how>), then the target C<finals> will be used if it does
exist. Else, C<all> will be used.

=head1 JUNK

While executing a rule, some temporary files may be created and cleaned
up. However, premature termination of the rule may leave behind these
temporary files. Even if it is good to automatically clean up these
files in the process of the rules, diagnostic may require leaving these
behind for examination. To be able to clean these by invoking the clean
functionality, and to ignore these by invoking the ignore functionality,
one may declare C<junk> files. The junk files are not checked for
anything (they may even be axioms), but they will be automatically added
to the list of files generated while running a rule, and will be ignored
(unless some other reason, such as being an axiom, prevents it).

=head1 MODES

To be able to build projects in several modes, a facility is provided
through the B<--mode> I<modename> option. A file C<.tmp/mode> is created
with each selected mode on a line by itself. For example: C<debug> and
C<mariadb> may build a project using debug flags and the MariaDB
database internally, while C<default> might use no debug flags and
C<sqlite>. Introducing this file in the input of the actor allows to act
differently. Rules using the different modes should depend on this file.

Moreover, rules may use a C<mode> property. The rules with a C<mode>
property currently not active are not considered. This allows for
possibly completely different properties (input, output, ...). The
C<mode> property can be a list of modes separated by commas; in this
case, the rule is active if any of these modes is selected.

If no mode is selected, then the mode C<default> is automatically selected.

=head1 FILES

=over

=item * C<plan/targets/I<target>> a list of goals aliased as a target

=item * C<plan/lazyfingerprint> a list of goals stored in git but not axioms

=item * C<plan/axioms> a list of goals not stored in git but considered as axioms

Beware that if plan/axioms is not empty, your project may be buildable
locally, but fail from the repository.

=item * C<plan/notaxioms> a list of files stored in git but not considered as axioms

For example, a compiled documentation may be stored in the git
repository even if it is automatically rebuilt each time. However,
L</"LAZY AXIOMS"> may be more interesting for this use case.

=item * C<plan/in/I<name>> a good place to put files read by C<infile> directives.

=item * C<plan/out/I<name>> a good place to put files read by C<outfile> directives.

=item * C<plan/actors/I<ACTOR>> a short script that executes the rule named
I<ACTOR> and receives the various arguments as $1, $2, etc.

=item * C<plan/rules> a JSON encoded file containing the rules.

=back

=head1 BUGS OR FEATURES

The fingerprint of a directory (to avoid declaring gazillions of files,
a rule may declare a directory as its output or input) is computed
solely from the list of its files and their sizes (and recursively for
directories inside directories). So, changing one byte in a file will
not change the fingerprint of the directory and may so not trigger
further actions. This is more or less a feature (one does not want to
checksum several gigabytes of data in an input directory everytime).

There is no automatic dependency on C<bin/plan> itself. Hopefully, the
result of the build should not depend on the building tool.

=head1 AUTHOR

Copyright Jean-Christophe Dubacq 2013

=head1 COPYING

This work is licensed under the BSD licence. It is explicitly stated
here that the license does not extend to the data managed by the
program, in case anyone had doubts.

=head1 TODO

Use IPC::Run3 that does many things better than we do.

Improve documentation.

Graph output for how is suboptimal (read unusable).

Action C<why> is not implemented yet.

C<sub main> has a lot of redundancy in some parts

Variables may be useful. They should behave more or less like modes.

An array of allowed modes instead of a single mode should be done for
rules.

=cut

}