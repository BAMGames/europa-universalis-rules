#!/usr/bin/perl

# Idea: allow for lazy axioms in plan/lazy
## These axioms would not be considered if option --hard is given
## Overwriting these axioms is not considered an error.
## A rule overwriting only these axioms must be ignored.
## Example: generating .pfb .afm from .sfd files
# Idea: manage inside files (both written and read in one actor)
# Idea: pseudo-target sweep to remove unmakeable non-axiom files


if (0) {

=pod

=head1 NAME

plan - build files by applying a set of fixed rules

=head1 SYNOPSIS

plan [B<--target>] I<targetname> ...

plan [B<-->] I<goal> [I<goal>] (only goals)

plan B<--why> I<goal> [I<goal>] (only goals)

plan B<--how> I<goal> [I<goal>] (only goals)

plan B<--help>|B<--man>|B<--nroff>|B<--usage>

If a goal could be mistaken for another option, use the B<--> form.

=cut

}


use strict;
use warnings;
use JSON::PP;
use Data::Dumper;
use URI::Escape;
use Digest::MD5;
use Symbol 'gensym';
use File::Path qw(make_path);
use Cwd;
use Term::ANSIColor;

my %verbosity=('exec'=>0,
               'init'=>0,
               'plan'=>0,
               'out'=>1,
               'err'=>1,
               'display'=>3);
my $color=1;
$color=0 unless -t STDOUT;
my $trace=1;
# Logging

my $class='';
my $oldclass='';
my $subclass='';
my $oldsubclass='';
my $currentcol=0;
my $nomove=0;
sub finish {
  my $status=shift @_;
  &newline();
  if ($status == 1) {
    die @_;
  }
  exit($status);
}
sub newline {
  print "\n" if ($currentcol);
  $currentcol=0;
  $nomove=0;
}
sub class {
  $oldclass=$class;
  $class=$_[0];
  if ($class ne $oldclass) {
    &newline();
    $subclass='';
    print color 'bold' if ($color);
    print $class,"\n";
    print color 'reset' if ($color);
  }
}
sub subclass {
  $oldsubclass=$subclass;
  $subclass=$_[0];
  if ($subclass ne $oldsubclass) {
    print color 'bold' if ($color);
    &out(3,'display',$subclass);
    print color 'reset' if ($color);
  }
}
my $countphase='';
my $lastcountcol=0;
sub out {
  my $v=shift @_;
  my $n=shift @_;
  if ($verbosity{$n}>=$v) {
    if ($n eq "display") {
      my $storepos=0;
      if ($v==1) {
        &class(@_);
      } elsif ($v==2) {
        &subclass(@_);
      } else {
        my $str=join('',@_);
        if ($_[0]=~ /^count:(.*):([0-9\/]+)$/) {
          $str="$1:$2";
          my $oldcountphase=$countphase;
          $countphase="$1";
          if ($color == 0) {
            $lastcountcol++;
            if ($lastcountcol == 500) {
              $lastcountcol=0;
            }
            if ($countphase ne $oldcountphase) {
              $lastcountcol=0;
            }
            return if ($lastcountcol != 0);
          } else {
            if ($nomove == 1 and $countphase eq $oldcountphase) {
              $storepos=2;
            } else {
              $storepos=1;
            }
          }
        } else {
          $countphase='';
        }
        my $len=length($str);
        if ($currentcol+2+$len>80) {
          &newline();
        }
        if ($currentcol==0) {
          print "    ";
          $currentcol=4;
        }
        if ($storepos == 1) {
          $nomove=1;
          $lastcountcol=$currentcol;
          print "\x1b[s";
        } elsif ($storepos == 2) {
          $nomove=1;
          $currentcol=$lastcountcol;
          print "\x1b[u";
        } else {
          $nomove=0;
        }
        $currentcol+=2+$len;
        print '[',$str,']';
      }
    } elsif ($n eq "out") {
      &newline();
      print color 'blue' if ($color);
      print "      ",@_,"\n";
      print color 'reset' if ($color);
    } elsif ($n eq 'err') {
      &newline();
      print color 'red' if ($color);
      print @_,"\n";
      print color 'reset' if ($color);
    } else {
      &newline();
      print $n,':',@_,"\n";
    }
  }
}

# ARGV


=pod

=head2 GENERIC OPTIONS

B<--verbosity> I<category> I<level> Change the verbosity to I<level> in I<category>.

B<--I<category>> I<level> Shortcut, as above.

If verbosity can be mistaken for a target name, use the B<--verbosity> form, because the target will take precedence.

The verbosity level is a positive integer (including 0).

The various categories are :

=over

=item * B<init> initialization information (not usefule)

=item * B<plan> informations about the building plan (can be very verbose)

=item * B<exec> informations about the commands launched by the plan

=item * B<err> the error output of the various commands

=item * B<out> the console output of the various commands

=item * B<display> the summary of the building (1: each class, 2: each subclass, 3: each item)

=back

Each rule can define a class and a subclass, and each item built will be
output in a synthetic manner. The default setting is 3 for B<display>
and 1 for B<out> and B<err>. A quiet effect can be obtained by setting
everything to 0.

=cut

sub parseARGV {
  my $goals=[];
  my $mode="goal";
  my $targets=[];
  my %target=('all'=>1,'finals'=>1); # TODO read from the plan/targets/ DIR
  my $x=0;
  while ($x < scalar @ARGV) {
    my $arg=$ARGV[$x];
    if ($arg eq '--verbosity') {
      &finish(1,"Wrong option: --verbosity must be followed by two arguments") unless defined($ARGV[$x+2]);
      my $cat=$ARGV[$x+1];
      my $level=$ARGV[$x+2];
      $x+=2;
      &finish(1,"Wrong option: --verbosity must be followed by either ".join(' or ',keys %verbosity)) unless defined($verbosity{$cat});
      &finish(1,"Wrong option: --verbosity must be followed by a category and an integer") unless $level =~ /^[0-9]+$/;
      $verbosity{$cat}=$level;
    } elsif ($arg eq '--help') {
      $mode="help-help";
    } elsif ($arg eq '--help' or $arg eq '-h') {
      $mode="help-help";
    } elsif ($arg eq '--man') {
      $mode="help-man";
    } elsif ($arg eq '--usage') {
      $mode="help-usage";
    } elsif ($arg eq '--nroff') {
      $mode="help-nroff";
    } elsif ($arg eq 'why' or $arg eq '--why') {
      $mode="why";
    } elsif ($arg eq 'how' or $arg eq '--how') {
      $mode="how";
    } elsif ($arg eq 'distclean' or $arg eq '--distclean') {
      $mode="distclean";
    } elsif (defined($target{$arg}) or $arg eq '--target') {
      if ($arg eq '--target') {
        $x++;
        $arg=$ARGV[$x];
      }
      push $targets,$arg;
    } elsif ($arg eq '--') {
      $x++;
      while ($x < scalar @ARGV) {
        push $goals,$ARGV[$x];
        $x++;
      }
    } else {
      push $goals,$arg;
    }
    $x++;
  }
  if (scalar @$goals == 0 and scalar @$targets == 0) {
    push $targets,'finals';
  }
  return ($goals,$targets,$mode);
}

my ($goals,$target,$mode)=&parseARGV();
&out(1,"init","Parsing ARGV done");

my %implemented=('goal' => 1,'distclean' => 1, 'clean' => 1,
                 'help-help' => 1,
                 'help-man' => 1,
                 'help-nroff' => 1,
                 'help-usage' => 1,
                );
finish(1,"$mode is not implemented yet") unless defined($implemented{$mode});

# help

sub usage {

=pod

=head2 HELP OPTIONS

B<--help>|B<-h> Generate this help (long version).

B<--usage> Generate this help (short version).

B<--man> Generate man page.

B<--nroff> Generate man page in NROFF format.

=cut

  ### usage ($option)
  ### Provides all kinds of textual help and stops
  my ($option)=@_;
  if (!defined($option)) {
    $option="usage";
  }
  my $cmd="pod2txt";
  my $release="0.6";
  my ($a,$out,$b);
  if ($option eq "man"||$option eq "nroff") {
    ($a,$out,$b)=@{&executeCommand("","pod2man","$0","--center","User commands","--release",$release)};
    if ($a==0 && $option eq "man") {
      ($a,$out,$b)=@{&executeCommand($out,"nroff","-man","-")};
    }
  } else {
    ($a,$out,$b)=@{&executeCommand("","pod2text","$0")};
  }
  if ($option eq "usage") {
    $out =~ s/OPTIONS.*$//s;
  }
  if ($option ne "man") {
    print $out;
  } else {
    open FILE,"|pager";
    print FILE $out;
    close FILE;
  }
  &finish(0);
}

# Command execution with stderr filtering

use IPC::Open3;
use POSIX ":sys_wait_h";
use IO::Select;
use IO::Handle;
my %statusCommand=();
my %childCommand=();
select(STDERR); $| = 1;
select(STDOUT); $| = 1;

sub REAPER {
  my $child;
  while (($child = waitpid(-1, WNOHANG)) > 0) {
    $statusCommand{$child} = $?;
    delete $childCommand{$child};
  }
  $SIG{CHLD} = \&REAPER;        # still loathe SysV
}
sub setupCommand {
  $SIG{CHLD} = \&REAPER;
  $SIG{INT} = sub {
    foreach my $pid (keys %childCommand) {
      kill 2,$pid;
    }
  };
}

my $specialprefix=qr/^PARTIAL PLAN:(.*)$/;
$ENV{'SPECIALPREFIX'}="PARTIAL PLAN:";
my @partiallydone=();

sub errorCommand {
  my $lines=$_[0];
  foreach my $line (split /\n/m,$lines) {
    chomp $line;
    if ($line =~ $specialprefix) {
      my $part=$1;
      &out(3,'display',$part);
      if ($part =~ /^failed:/ or $part =~ /^count:/) {
        1;
      } else {
        push @partiallydone,$part;
      }
    } else {
      &out(1,'err',$line);
    }
  }
}

sub execCommand {
  my $line;
  &out(1,"exec",@_);
  my $out = gensym;
  my $err = gensym;
  my $pid = open3("<&STDIN",$out, $err, @_);
  if ($pid) {
    $childCommand{$pid}=1;
    my $sel= new IO::Select;
    $sel->add($err,$out);
    while (scalar keys %childCommand > 0) {
      foreach my $readhandle ($sel->can_read(.5)) {
        my $length=sysread $readhandle,$line,4096;
        if ($length) {
          if (fileno($readhandle)==fileno($err)) {
            &errorCommand($line);
          } else {
            chomp $line;
            &out(1,'out',$line);
          }
        }
      }
    }
  }
  my $status=0+$statusCommand{$pid};
  delete $statusCommand{$pid};
  &out(1,"exec","Command finished with status $status");
  return $status;
}

sub executeCommand {
  my $in=shift @_;
  &out(1,"exec",join(' ',@_));
  my $outputtext="";
  my $errtext="";
  my $pid=open3(\*INPUT, \*OUTPUT, \*ERR,@_);
  print INPUT $in if $in;
  close(INPUT);
  my $done=0;
  do {
    while (<OUTPUT>) {
      $outputtext.=$_;
    }
    while (<ERR>) {
      $errtext.=$_;
    }
    $done=waitpid($pid,WNOHANG);
  } until ($done>0);
  return [ $?, $outputtext, $errtext ];
}

if ($mode =~ /^help-([a-z]+)/) {
  &usage($1);
}

&out(1,'init','Initialize harness for command executions');
&setupCommand;

my $axiomdir='plan/axioms';
my $finaldir='plan/finals';
my $rulefile='plan/rules';

my %axioms=();
my %finals=();
my @theorems=();
my %generation=();
my @rules;
my $trigger=[];
my %bottomupseen=();
my %rules=();
my %fingerprintCache=();
my %generatedCache=();
my $result=[];

sub fingerprint() {
  my ($f)=@_;
  my $hash="0";
  return "0" if (-d $f);
  return "0" unless (-e $f);
  open FILE,"$f" or return "$f:0";
  my $hashing = Digest::MD5->new;
  $hashing->addfile(*FILE);
  $hash=$hashing->hexdigest;
  close FILE;
  return $hash;
}

sub fingerprintArray() {
  # example: $rule, 'in'
  my @a=@{$_[0]->{$_[1]}};
  return 'none' unless (scalar @a);
  my $hashing = Digest::MD5->new;
  my $fp;
  foreach my $file (@a) {
    $fp=&fingerprint($file);
    $hashing->add($file.$fp);
  }
  return $hashing->hexdigest;
}

sub findGitTopdir {
  my $oldcwd='';
  my $cwd=getcwd();
  while ($oldcwd ne $cwd and !opendir(GITDIR,".git")) {
    chdir('..');
    $cwd=getcwd();
  }
  &finish(1,"Could not find the top-level directory") if $cwd eq $oldcwd;
  closedir(GITDIR);
}

my $jsonEncoder=JSON::PP->new->pretty;
sub writeCache() {
  my ($cacheHash,$path)=@_;
  &out(3,'init',"Storing $path cache");
  my $cachehandle;
  open STDIN,"/dev/null" unless fileno(STDIN);
  make_path('.tmp');
  open $cachehandle,'>',".tmp/$path" or &finish(1,"I cannot open my $path cache!");
  print $cachehandle $jsonEncoder->encode($cacheHash);
  $cachehandle->sync();
  close $cachehandle;
}

sub readCache() {
  my ($cacheHash,$path)=@_;
  &out(1,'init',"Reading $path cache");
  local $/;
  open (my $fh,'<',".tmp/$path") or return;
  my $json=<$fh>;
  my $cache=decode_json($json);
  foreach (keys %{$cache}) {
    $cacheHash->{$_}=$cache->{$_};
  }
}

sub removeGenerated() {
  my ($cacheHash,$path,$axioms)=@_;
  my $count=0;
  if (defined($axioms)) {
    &out(1,'display','Removing old files');
  } else {
    &out(1,'init','Cleaning old files cache');
  }
  # If not defined, just test presence
  # Else, unlink all files not in $axioms hash
  foreach my $key (keys %{$cacheHash}) {
    if (-f $key) {
      if (defined($axioms) and !defined($axioms->{$key})) {
        # clean or distclean
        $count++;
        unlink $key;
        delete $cacheHash->{$key};
      }
    } else {
      delete $cacheHash->{$key};
    }
  }
  &writeCache($cacheHash,$path);
  if (defined($axioms)) {
    &out(3,'display',"Removed $count old files");
  }
}

sub readAxioms() {
  my $axiomtype=shift @_;
  my $axiomdir=shift @_;
  my $axioms=shift @_;
  &out(1,"init","Reading $axiomtype from $axiomdir");
  opendir(my $dh, $axiomdir) || return;
  while (readdir $dh) {
    next if /^[.]/;
    my $axiomfile=$axiomdir."/".$_;
    open FILE,$axiomfile;
    while (my $line=<FILE>) {
      chomp $line;
      next if $line=~/^#/;
      $axioms->{uri_unescape($line)}=1;
    }
    close FILE;
  }
  closedir $dh;
}

sub shallowCopy() {
  my $a=[];
  foreach my $b (@{$_[0]}) {
    push $a,$b;
  }
  return $a;
}

sub readRules() {
  local $/;
  open (my $fh,'<',$rulefile);
  my $json=<$fh>;
  my $rules=decode_json($json);
  @rules=values %{$rules};
  foreach my $rule (@rules) {
    $rule->{'in'}=[] unless (defined($rule->{'in'}));
    push $rule->{'in'},'plan/bin/'.$rule->{'actor'};
    $rules{$rule->{"actor"}}=$rule;
  }
  $rules{'AXIOM'}={'type' => 'simple',
                   'actor' => 'AXIOM',
                   'in'=>['plan/bin/AXIOM'],
                   'class' => 'Checking axioms'};
}

sub shallowCopyRule() {
  my ($oldrule,$rule)=@_;
  foreach my $k (keys %$oldrule) {
    if (ref($k) ne 'ARRAY') {
      $rule->{$k}=$oldrule->{$k};
    } else {
      $rule->{$k}=[@{$oldrule->{$k}}];
    }
  }
  $rule->{'arg'}=[] if (!defined($rule->{'arg'}));
  $rule->{'class'}='' if (!defined($rule->{'class'}));
  $rule->{'subclass'}='' if (!defined($rule->{'subclass'}));
}

sub recordGeneration() {
  # Shallow cloning (2 levels is enough)
  my $oldrule=$_[0];
  foreach my $thm (@{$oldrule->{'out'}}) {
    my $rule={};
    &shallowCopyRule($oldrule,$rule);
    &finish(1,"Regenerated $thm in generation ".$oldrule->{'gen'}) if (exists $generation{$thm});
    $generation{$thm}=$rule;
  }
}

sub actionKey() {
  my $a=shift @_;
  if (defined($a->{'key'})) {
    return $a->{'key'};
  }
  if (defined($a->{'arg'}) and scalar @{$a->{'arg'}} > 0) {
    $a->{'key'}=join(' ',$a->{'actor'},map {&uri_escape($_)} @{$a->{'arg'}});
  } else {
    $a->{'key'}=$a->{'actor'};
  }
  return $a->{'key'};
}

sub listEqual() {
  # Compares two arrays of strings
  my ($a,$b)=@_;
  return 0 unless (scalar @$a == scalar @$b);
  foreach my $i (0..scalar @$a-1) {
    return 0 if $a->[$i] ne $b->[$i];
  }
  return 1;
}

sub nextGeneration() {
  my ($gen,$previousthm) = @_;
  &out(3,"plan","Building list of buildable files, generation $gen");
  my @current=@$previousthm;
  my $found=[];
  foreach my $rule (@rules) {
    if ($rule->{'type'} eq 'simple' ) {
      my $key=&actionKey($rule);
      next if (exists($bottomupseen{$key}));
      my $allfound=1;
      if (defined($rule->{'infile'})) {
        foreach my $infile (@{$rule->{'infile'}}) {
          if (open FILE,$infile) {
            foreach (<FILE>) {
              chomp;
              push $rule->{'in'},$_;
            }
            close FILE;
          }
        }
        $rule->{'oldinfile'} = $rule->{'infile'};
        delete $rule->{'infile'};
      }
      foreach my $requirement (@{$rule->{'in'}}) {
        if (!exists($generation{$requirement})
            or $generation{$requirement}->{'gen'} >= $gen) {
          $allfound=0;last;
        }
      }
      if ($allfound) {
        $rules{$rule->{"actor"}}->{'seen'}=1;
        $bottomupseen{$key}=1;
        $rule->{'gen'}=$gen;
        &recordGeneration($rule);
        push $found,@{$rule->{'out'}};
      }
    } elsif ($rule->{'type'} eq 'pattern' ) {
      my $pattern=$rule->{'pattern'};
      my $patternRE=qr/$pattern/;
      foreach my $candidate (@current) {
        my @list;
        if (@list = ($candidate =~ $patternRE)) {
          if (defined($rule->{'allowedargs'})) {
            my $ok=0;
            foreach my $allow (@{$rule->{'allowedargs'}}) {
              if (&listEqual($allow,\@list)) {
                $ok=1;
                last;
              }
            }
            next unless $ok;
          }
          my @in=();
          my @out=();
          foreach my $infile (@{$rule->{'in'}}) {
            push @in, $infile;
          }
          foreach my $outfile (@{$rule->{'out'}}) {
            push @out, $outfile;
          }
          if (defined($rule->{'infile'})) {
            foreach my $infile (@{$rule->{'infile'}}) {
              my $inf=''.$infile;
              foreach my $counter (1..$#list+1) {
                $inf =~ s/\$$counter/$list[$counter-1]/ge;
              }
              if (open FILE,$inf) {
                foreach (<FILE>) {
                  chomp;
                  push @in,$_;
                }
                close FILE;
              }
            }
          }
          my $argument=$rule->{'argument'};
          my $subclass='';
          $subclass=$rule->{'subclass'} if (defined($rule->{'subclass'}));
          foreach my $counter (1..$#list+1) {
            $argument =~ s/\$$counter/$list[$counter-1]/ge;
            $subclass =~ s/\$$counter/$list[$counter-1]/ge;
            foreach (@in,@out) {
              s/\$$counter/$list[$counter-1]/ge;
            }
          }
          my $newrule={};
          &shallowCopyRule($rule,$newrule);
          $newrule->{'arg'}=[$argument];
          $newrule->{'subclass'}=$subclass;
          delete $newrule->{'key'};
          my $key=&actionKey($newrule);
          next if exists($bottomupseen{$key});
          $bottomupseen{$key}=1;
          $newrule->{'in'}=[@in];
          $newrule->{'wanted'}=[@in];
          $newrule->{'out'}=[@out];
          push $trigger,$newrule;
        }
      }
    }
  }
  my $delayednumber=0;
  my $triggercopy=&shallowCopy($trigger);
  foreach my $delayed (@$triggercopy) {
    my @wanted=@{$delayed->{'wanted'}};
    my $i=0;
    my $wantedcopy=&shallowCopy(\@wanted);
    foreach my $wanted (@$wantedcopy) {
      if (exists($generation{$wanted}) and $generation{$wanted}->{'gen'}<$gen) {
        splice $delayed->{'wanted'},$i,1;
        $i--;
      }
      $i++;
    }
    @wanted=@{$delayed->{'wanted'}};
    if (scalar @wanted == 0) {
      $delayed->{'gen'}=$gen;
      &recordGeneration($delayed);
      push $found,@{$delayed->{'out'}};
      splice $trigger,$delayednumber,1;
      $delayednumber--;
    }
    $delayednumber++;
  }
  return $found;
}

sub bottomUp {
  my @axioms=sort keys %axioms;
  my $currentgen=\@axioms;
  my $generation=1;
  my $newlength=scalar @axioms;
  &out(2,"plan","Building list of buildable files");
  while ($newlength) {
    $currentgen=&nextGeneration($generation,$currentgen);
    $newlength=scalar @{$currentgen};
    $generation++;
  }
  foreach my $actor (keys %rules) {
    if (!defined($rules{$actor}->{'seen'})
        and $rules{$actor}->{'type'} eq 'simple') {
      &out(2,'plan',"The rule $actor was not used at all");
      &out(3,'plan',Dumper($rules{$actor}));
    }
  }
}

sub topDown {
  # Now, collect only the goals
  &out(2,"plan","Isolating goals paths from $target");
  my %topdownseen=();
  my $mygoals=$goals;
  my %idontknow=();
  my %ineed=();

  if ($target eq 'all') {
    push $mygoals,keys %generation;
  } elsif ($target eq 'finals') {
    push $mygoals,keys %finals;
  }

  &out(4,"plan","Final list of goals established: ".join(' ',@$mygoals));
  while (scalar @$mygoals) {
    my $goal=pop $mygoals;
    do {
      $idontknow{$goal}=1;next;
    } unless (exists($generation{$goal}));
    my $key=&actionKey($generation{$goal});
    next if exists($topdownseen{$key});
    $topdownseen{$key}=1;
    $ineed{$key}=$generation{$goal};
    push $mygoals,@{$generation{$goal}->{'in'}};
  }
  if (scalar keys %idontknow) {
    print "I do not know how to build the following goals:\n";
    print join("\n",sort keys %idontknow),"\n";
    &finish(1,"Stopping");
  }
  my @result=sort {
    ($a->{'gen'} <=> $b->{'gen'}) || ($a->{'class'} cmp $b->{'class'}) || ($a->{'subclass'} cmp $b->{'subclass'}) || ($a->{'actor'} cmp $b->{'actor'}) || (join(' ',$a->{'arg'}) cmp join(' ',$b->{'arg'}))
  } values %ineed;
  return \@result;
}

sub firstCompound {
  my ($plan,$begin) = @_;
  my $newplan=[];
  return undef unless (scalar @$plan);
  my $end=$begin+1;
  my $maxend;
  my $axiom=$plan->[$begin]->{'actor'};
  if (defined($rules{$axiom}->{'maxargs'})) {
    $maxend=$begin+$rules{$axiom}->{'maxargs'};
  } else {
    $maxend=$begin+100000000;
  }
  while (
         $end < scalar @$plan and
         $end < $maxend and
         $plan->[$end]->{'gen'} == $plan->[$begin]->{'gen'} and
         $plan->[$end]->{'actor'} eq $plan->[$begin]->{'actor'}
        ) {
    $end++;
  }
  my $candidates=[];
  # weed out already done candidates
  foreach my $i ($begin..$end-1) {
    my $key=&actionKey($plan->[$i]);
    my $fingerprintIn=&fingerprintArray($plan->[$i],'in');
    $plan->[$i]->{'fingerprintIn'}=$fingerprintIn;
    my $fingerprintOut=&fingerprintArray($plan->[$i],'out');
    if ((defined($fingerprintCache{$key})
         and $fingerprintCache{$key} eq "$fingerprintIn $fingerprintOut")
       ) {
      &out(3,"plan","Not considering $key");
      next;
    } elsif (!defined($fingerprintCache{$key})) {
      &out(2,"plan","Considering $key (never seen)");
    } else {
      &out(2,"plan","Considering $key (input or output changed)");
    }
    push $candidates,$i;
  }
  # TODO
  my $compoundRule={};
  &shallowCopyRule($plan->[$begin],$compoundRule);
  delete $compoundRule->{'key'};
  $compoundRule->{'arg'}=[];
  my $individualRules=[];
  my $newargs=$compoundRule->{'arg'};
  my $newin={};
  my $newout={};

  foreach my $i (@$candidates) {
    push $newargs,@{$plan->[$i]->{'arg'}};
    push $individualRules,$plan->[$i];
    foreach my $j (@{$plan->[$i]->{'in'}}) {
      $newin->{$j}=1;
    }
    foreach my $j (@{$plan->[$i]->{'out'}}) {
      $newout->{$j}=1;
    }
  }
  my @newin=sort keys $newin;
  my @newout=sort keys $newout;
  $compoundRule->{'in'}=\@newin;
  $compoundRule->{'out'}=\@newout;
  return ($compoundRule,$candidates,$end);
}

sub registerSuccess() {
  my ($candidate,$plan)=@_;
  my $rule=$plan->[$candidate];
  my $fingerprintOut=&fingerprintArray($rule,'out');
  my $fingerprintIn=$rule->{'fingerprintIn'};
  my $key=&actionKey($rule);
  &out(4,"plan","Registering success of $key");
  $fingerprintCache{$key}="$fingerprintIn $fingerprintOut";
}

sub attempt() {
  my $todo=$_[0];
  my @candidateRules=@{$_[1]};
  @partiallydone=();
  my @execLine=($todo->{'actor'});
  push @execLine,@{$todo->{'arg'}} if (scalar @{$todo->{'arg'}});
  my $line=join(' ',@execLine);
  my $success=substr $line,0,72;
  $success.="..." if ($success ne $line);
  $execLine[0]='plan/bin/'.$todo->{'actor'};
  if ($todo->{'class'} ne '') {
    &out(1,'display',$todo->{'class'});
    if ($todo->{'subclass'} ne '') {
      &out(2,'display',$todo->{'subclass'});
    }
  } else {
    &out(1,'display',$success);
  }
  my @tab=();
  push @tab,@{$todo->{'out'}} if defined($todo->{'out'});
  push @tab,@{$todo->{'junk'}} if defined($todo->{'junk'});
  foreach my $file (@tab) {
    $generatedCache{$file}=1;
  }
  &writeCache(\%generatedCache,'generated');
  my $status=&execCommand(@execLine);
  if ($status) {
    foreach my $ok (@partiallydone) {
      my $protectedok=uri_escape($ok); # TODO: Really use actionKeys here, not filenames
      foreach my $i (@candidateRules) {
        my $rule=$result->[$i];
        if (defined $rule->{'arg'}
            and scalar @{$rule->{'arg'}} == 1
            and $rule->{'arg'}->[0] eq $protectedok) {
          &registerSuccess($i,$result);
          last;
        }
      }
    }
    &writeCache(\%fingerprintCache,'fingerprint');
    &finish(1,"One rule failed with status $status") if ($status);
  }
  # register success of everybody
  &out(3,"plan","Everything was successful");
  foreach my $i (@candidateRules) {
    &registerSuccess($i,$result);
  }
  &writeCache(\%fingerprintCache,'fingerprint');
}

&findGitTopdir();

&readAxioms("axioms",$axiomdir,\%axioms);
&readAxioms("finals",$finaldir,\%finals);
&readCache(\%fingerprintCache,'fingerprint');

&readCache(\%generatedCache,'generated');
&removeGenerated(\%generatedCache,'generated',undef);

if ($mode eq "distclean" or $mode eq "clean") {
  my %protected=();
  foreach my $i (keys %axioms) {
    $protected{$i}=1;
  }
  if ($mode eq "clean") {
    foreach my $i (keys %finals) {
      $protected{$i}=1;
    }
  }
  &removeGenerated(\%generatedCache,'generated',\%protected);
  &finish(0);
}

&readRules();
&out(3,"plan","Recording axioms");
foreach my $axiom (sort keys %axioms) {
  my $axiomrule={};
  &shallowCopyRule($rules{'AXIOM'},$axiomrule);
  $axiomrule->{'gen'}=0;
  $axiomrule->{'in'}=[] if ($axiom eq 'plan/bin/AXIOM');
  $axiomrule->{'arg'}=[$axiom];
  $axiomrule->{'out'}=[$axiom];
  &recordGeneration($axiomrule);
}
&bottomUp();
$result=&topDown();

my $todo;
my $todoIndividuals;
my $begin=0;
my $end=0;

my $done=0;
while ($end < scalar @$result) {
  ($todo,$todoIndividuals,$end)=&firstCompound($result,$begin);
  $begin=$end;
  next if ((scalar @{$todoIndividuals}) == 0);
  $done++;
  &attempt($todo,$todoIndividuals);
}

if ($done==0) {
  &out(1,"display","Everything is up to date");
}
&newline();
&finish(0);

=pod

=head1 PRINCIPLE

TODO

=head1 RULES

TODO

=head1 EXPLAINING

The B<--why> and B<--how> specifiers will disable file generation and
explain by a simple graph which file is output starting from the
specified goals (B<--why>) or an input from the specified goals
(B<--how). The graph is in I<graphviz> format.

=head1 GOALS AND TARGETS

The various goals files are filenames with one name per line. The names
may be escaped by using the %(hexadecimal) notation (you will most
probably never encounter that).

Targets are predefined list of goals that can be used instead of
specifying individual goals. The target names are usually sufficient to
use them as goals.

There is one default target: the I<all> target is the list of all
buildable files.

If no goals are given, then the target I<finals> will be used by default
(even if it is not defined).

=head1 FILES

=over

=item * C<plan/targets/I<target>> a list of goals aliased as a target

=item * C<plan/lazy> a list of goals stored in git but not axioms

=item * C<plan/axioms> a list of goals not stored in git but considered as axioms

Beware that if plan/axioms is not empty, your project may be buildable
locally, but fail from the repository.

=item * C<plan/in/I<name>> a good place to put files read by "infile" directives.

=item * C<plan/out/I<name>> a good place to put files read by "outfile" directives.

=item * C<plan/actors/I<ACTOR>> a short script that executes the rule named
I<ACTOR> and receives the various arguments as $1, $2, etc.

=item * C<plan/rules> a JSON encoded file containing the rules.

=back

=head1 AUTHOR

Copyright Jean-Christophe Dubacq 2013

=head1 COPYING

This work is licensed under the BSD licence. It is explicitly stated
here that the license does not extend to the data managed by the
program, in case anyone had doubts.

=cut
