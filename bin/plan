#!/usr/bin/perl

# Idea: allow for lazy axioms in plan/lazy
## These axioms would not be considered if option --hard is given
## Overwriting these axioms is not considered an error.
## A rule overwriting only these axioms must be ignored.
## Example: generating .pfb .afm from .sfd files
# Idea: manage inside files (both written and read in one actor)
# Idea: pseudo-target sweep to remove unmakeable non-axiom files


if ('' cmp 'DOC SYNOPSIS') {

=pod

=head1 NAME

plan - build files by applying a set of fixed rules

=head1 SYNOPSIS

plan [B<--target>] I<targetname> ...

plan [B<-->] I<goal> [I<goal>] (only goals)

plan B<[--]what>

plan B<[--]why> I<goal> [I<goal>] (only goals)

plan B<[--]how> I<goal> [I<goal>] (only goals)

plan B<--help>|B<--man>|B<--nroff>|B<--usage>

If a goal could be mistaken for another option, use the B<--> form.

=cut

}

use strict;
use warnings;
# Unicode safety
use utf8;
use Encode;

use JSON::PP;
use Data::Dumper;
use URI::Escape;
use Digest::MD5;
use Symbol 'gensym';
use File::Path qw(make_path);
use Cwd;
use Term::ANSIColor;
# command execution
use IPC::Open3;
use POSIX ":sys_wait_h";
use IO::Select;
use IO::Handle;

my ($execContext,$planContext,$outContext);

# Directories

my $axiomdir='plan/axioms';
my $rulefile='plan/rules';
my $actordir='plan/bin';
my $targetdir='plan/targets';

# Convenience

sub clone {
  my $obj=shift @_;
  my $t=ref($obj);
  return $obj unless ($t);
  return [map {&clone($_)} @$obj] if ($t eq 'ARRAY');
  my $n={};
  foreach my $key (keys %$obj) {
    $n->{$key}=&clone($obj->{$key});
  }
  return $n;
}

sub findGitTopdir {
  my $oldcwd='';
  my $cwd=getcwd();
  while ($oldcwd ne $cwd and !opendir(GITDIR,".git")) {
    chdir('..');
    $cwd=getcwd();
  }
  closedir(GITDIR);
  &finish(1,"Could not find the top-level directory") if $cwd eq $oldcwd;
  &out(1,'init','Relocated to project top directory');
}

sub addHash {
  my $hash={};
  foreach my $h (@_) {
    foreach my $k (keys %$h) {
      $hash->{$k}=1;
    }
  }
  return $hash;
}
sub subHash {
  my $hash={};    # TODO optimize if first hash much larger than second?
  my $init=shift @_;
  foreach my $k (keys %$init) {
    $hash->{$k}=1;
  }
  foreach my $h (@_) {
    foreach my $k (keys %$h) {
      delete ($hash->{$k}) if (exists($hash->{$k}));
    }
  }
  return $hash;
}

sub main {
  &initLogging();
  &findGitTopdir();
  my ($goals,$targets,$mode)=&parseARGV();
  if ($mode =~ /^help-([a-z]+)/) {
    &usage($1);
  }
  &readRules();
  my $axioms=&readAxiomsFromGit(); # TODO use some form of exec command instead of open|
  &setupCommand();
  my $exceptions=&readFileList('plan/axioms');
  my $notaxioms=&readFileList('plan/notaxioms');
  my $realaxioms=addHash($axioms,$exceptions);
  $realaxioms=subHash($realaxioms,$notaxioms);
  if ($mode eq 'clean' or $mode eq 'distclean') {
    my $finals={};
    $finals=&readFileList('plan/targets/finals') if $mode eq 'clean';
    my $preserve=addHash($realaxioms,$finals);
    &readCache($planContext->{'junk'},'junk');
    &removeGenerated($planContext->{'generated'},'generated',$preserve);
    &finish(0);
  } elsif ($mode eq 'what') {
    &preparePlan($realaxioms);
    my $goalHash=&instantiateTargets($targets,$goals,$planContext->{'generated'},$realaxioms);
    my $unbuildable=&subHash($goalHash,$planContext->{'generated'});
    &explainPlan($unbuildable);
    &finish(0);
  } elsif ($mode eq 'how') {
    &preparePlan($realaxioms);
    my $goalHash=&instantiateTargets($targets,$goals,$planContext->{'generated'},$realaxioms);
    my $unbuildable=&subHash($goalHash,$planContext->{'generated'});
    my $narrowPlan=&reducePlan($goalHash,$planContext->{'generated'});
    &graphviz($narrowPlan,$goalHash);
    &finish(0);
  } elsif ($mode eq 'goal') {
    my $steps=0;
    my $finished=0;
    $planContext->{'fingerprint'}={};
    $planContext->{'generated'}={};
    &readCache($planContext->{'fingerprint'},'fingerprint');
    &readCache($planContext->{'junk'},'junk');
    &removeGenerated($planContext->{'generated'},'generated',undef);
    my $narrowPlan;
    while (!$finished) {
      &preparePlan($realaxioms);
      my $goalHash=&instantiateTargets($targets,$goals,$planContext->{'generated'},$realaxioms);
      my $unbuildable=&subHash($goalHash,$planContext->{'generated'});
      $narrowPlan=&reducePlan($goalHash,$planContext->{'generated'});
      my $begin=0;
      my $xfinished=0;
      my $todo=undef;
      while (!$xfinished) {
        my $end;
        ($todo,$end)=&firstCompound($narrowPlan,$begin);
        if (defined($todo)) {
          $steps++;
          $xfinished=1;
        } else {
          $begin=$end;
          if ($begin >= scalar @$narrowPlan) {
            $xfinished=1;
            $finished=1;
          }
        }
      }
      &attempt($todo) if defined($todo);
    }
    if ($steps==0) {
      if (scalar @$narrowPlan) { 
        &out(1,"display","Everything is up to date");
      } else {
        &out(1,"display","Nothing to be done");
      }
    }
    &finish(0);
  }
  &finish(1,"$mode is not implemented yet");
}

&main();

# Logging
sub initLogging {

=pod

=head2 GENERIC OPTIONS

B<--verbosity> I<category> I<level> Change the verbosity to I<level> in I<category>.

B<--I<category>> I<level> Shortcut, as above.

If verbosity can be mistaken for a target name, use the B<--verbosity> form, because the target will take precedence.

The verbosity level is a positive integer (including 0).

The various categories are :

=over

=item * B<init> initialization information (not usefule)

=item * B<plan> informations about the building plan (can be very verbose)

=item * B<exec> informations about the commands launched by the plan

=item * B<err> the error output of the various commands

=item * B<out> the console output of the various commands

=item * B<display> the summary of the building (1: each class, 2: each subclass, 3: each item)

=back

Each rule can define a class and a subclass, and each item built will be
output in a synthetic manner. The default setting is 3 for B<display>
and 1 for B<out> and B<err>. A quiet effect can be obtained by setting
everything to 0.

=cut

  binmode(STDOUT,':utf8');
  binmode(STDERR,':utf8');
  binmode(STDIN,':utf8');
  my $verbosity={'exec'=>0,
                 'init'=>0,
                 'plan'=>0,
                 'out'=>1,
                 'err'=>1,
                 'dev'=>1,
                 'display'=>3};
  my $jsonEncoder=JSON::PP->new->pretty;
  $outContext={
               'color' => 1,
               'class' => '',
               'subclass' => '',
               'currentcol' => 0,
               'nomove' => 0,
               'countphase' => '',
               'lastcountcol' => 0,
               'verbosity' => $verbosity,
               'specialprefix' => qr/^PARTIAL PLAN:(.*)$/,
               'json' => $jsonEncoder,
              };
  $ENV{'SPECIALPREFIX'}="PARTIAL PLAN:";
  $outContext->{'color'}=0 unless -t STDOUT;
  &out(1,'init','Logging system ready');
}                               # DOC INSIDE
sub finish {
  my $status=shift @_;
  &newline();
  if ($status == 1) {
    print "Dying: ",@_,"\n";
  }
  exit($status);
}
sub newline {
  print "\n" if ($outContext->{'currentcol'});
  $outContext->{'currentcol'}=0;
  $outContext->{'nomove'}=0;
}
sub class {
  my $class=$_[0];
  if ($class ne $outContext->{'class'}) {
    &newline();
    $outContext->{'subclass'}='';
    print color 'bold' if ($outContext->{'color'});
    print $class,"\n";
    print color 'reset' if ($outContext->{'color'});
    $outContext->{'class'}=$class;
  }
}
sub subclass {
  my $subclass=$_[0];
  if ($subclass ne $outContext->{'subclass'}) {
    $outContext->{'subclass'}=$subclass;
    print color 'bold' if ($outContext->{'color'});
    &outDisplay($subclass);
    print color 'reset' if ($outContext->{'color'});
  }
}
sub outDisplay {
  my $str=join('',@_);
  my $storepos=0;
  if ($str =~ /^count:(.*):([0-9\/]+)$/) {
    $str="$1:$2";
    my $oldcountphase=$outContext->{'countphase'};
    my $countphase="$1";
    $outContext->{'countphase'}=$countphase;
    if ($outContext->{'color'} == 0) {
      my $lastcountcol=$outContext->{'lastcountcol'}+1;
      if ($lastcountcol == 500) {
        $lastcountcol=0;
      }
      if ($countphase ne $oldcountphase) {
        $lastcountcol=0;
      }
      $outContext->{'lastcountcol'}=$lastcountcol;
      return if ($lastcountcol != 0);
    } else {
      if ($outContext->{'nomove'} == 1 and $countphase eq $oldcountphase) {
        $storepos=2;
      } else {
        $storepos=1;
      }
    }
  } else {
    $outContext->{'countphase'}='';
  }
  my $len=length($str);
  if ($outContext->{'currentcol'}+2+$len>80) {
    &newline();
  }
  if ($outContext->{'currentcol'}==0) {
    print "    ";
    $outContext->{'currentcol'}=4;
  }
  if ($storepos == 1) {
    $outContext->{'nomove'}=1;
    $outContext->{'lastcountcol'}=$outContext->{'currentcol'};
    print "\x1b[s";
  } elsif ($storepos == 2) {
    $outContext->{'nomove'}=1;
    $outContext->{'currentcol'}=$outContext->{'lastcountcol'};
    print "\x1b[u";
  } else {
    $outContext->{'nomove'}=0;
  }
  $outContext->{'currentcol'}+=2+$len;
  print '[',$str,']';
}
sub out {
  my $v=shift @_;
  my $n=shift @_;
  if ($outContext->{'verbosity'}->{$n}>=$v) {
    if (ref($_[0])) {
      $_[1] = Data::Dumper->Dump([$_[0]],[$_[1]]);
      shift @_;
    }
    if ($n eq "display") {
      my $storepos=0;
      if ($v==1) {
        &class(@_);
      } elsif ($v==2) {
        &subclass(@_);
      } else {
        &outDisplay(@_);
      }
    } elsif ($n eq "out") {
      &newline();
      print color 'blue' if ($outContext->{'color'});
      print "      ",@_,"\n";
      print color 'reset' if ($outContext->{'color'});
    } elsif ($n eq 'err' or $n eq 'dev') {
      &newline();
      print color 'red' if ($outContext->{'color'});
      print @_,"\n";
      print color 'reset' if ($outContext->{'color'});
    } else {
      &newline();
      print $n,':',@_,"\n";
    }
  }
}

# ARGV
sub parseARGV {
  my $goals=[];
  my $mode="goal";
  my $targets=[];
  my @target=&readDir('plan/targets');
  my %target=('all' => 1);
  foreach my $t (@target) {
    $target{$t}=1;
  }
  my $x=0;
  while ($x < scalar @ARGV) {
    my $arg=$ARGV[$x];
    if (defined($target{$arg}) or $arg eq '--target') {
      if ($arg eq '--target') {
        $x++;
        $arg=$ARGV[$x];
      }
      push $targets,$arg;
    } elsif ($arg eq '--verbosity') {
      &finish(1,"Wrong option: --verbosity must be followed by two arguments") unless defined($ARGV[$x+2]);
      my $cat=$ARGV[$x+1];
      my $level=$ARGV[$x+2];
      $x+=2;
      &finish(1,"Wrong option: --verbosity must be followed by one of ".join(' or ',keys %{$outContext->{'verbosity'}})) unless defined($outContext->{'verbosity'}->{$cat});
      &finish(1,"Wrong option: --verbosity must be followed by a category and an integer") unless $level =~ /^[0-9]+$/;
      $outContext->{'verbosity'}->{$cat}=$level;
    } elsif ($arg eq '--help') {
      $mode="help-help";
    } elsif ($arg eq '--help' or $arg eq '-h') {
      $mode="help-help";
    } elsif ($arg eq '--man') {
      $mode="help-man";
    } elsif ($arg eq '--usage') {
      $mode="help-usage";
    } elsif ($arg eq '--nroff') {
      $mode="help-nroff";
    } elsif ($arg eq 'what' or $arg eq '--what') {
      $mode="what";
    } elsif ($arg eq 'why' or $arg eq '--why') {
      $mode="why";
    } elsif ($arg eq 'how' or $arg eq '--how') {
      $mode="how";
    } elsif ($arg eq 'clean' or $arg eq '--clean') {
      $mode="distclean";
    } elsif ($arg eq 'distclean' or $arg eq '--distclean') {
      $mode="distclean";
    } elsif ($arg =~ '--(\w+)' and defined($outContext->{'verbosity'}->{$1})) {
      my $cat=$1;
      my $level=$ARGV[$x+1];
      $x++;
      &finish(1,"Wrong option: --verbosity must be followed by a category and an integer") unless $level =~ /^[0-9]+$/;
      $outContext->{'verbosity'}->{$cat}=$level;
    } elsif ($arg eq '--') {
      $x++;
      while ($x < scalar @ARGV) {
        push $goals,$ARGV[$x];
        $x++;
      }
    } else {
      push $goals,$arg;
    }
    $x++;
  }
  if (scalar @$goals == 0 and scalar @$targets == 0) {
    push $targets,'finals';
  }
  &out(1,"init","Parsing ARGV done");
  return ($goals,$targets,$mode);
}
sub instantiateTargets {
  my ($targets,$goals,$generation,$axioms)=@_;
  my $goalHash={};
  my $targetHashes=[];
  my $all=0;
  foreach my $g (@$goals) {
    $goalHash->{$g}++;
  }
  foreach my $f (@$targets) {
    if ($f eq 'all') {
      my $allHash=subHash($generation,$axioms);
      push $targetHashes,$allHash;
    } else {
      push $targetHashes,&readFileList($targetdir.'/'.$f,1);
    }
  }
  $goalHash=&addHash($goalHash,@$targetHashes);
  return $goalHash;
}

# Help
sub usage {

=pod

=head2 HELP OPTIONS

B<--help>|B<-h> Generate this help (long version).

B<--usage> Generate this help (short version).

B<--man> Generate man page.

B<--nroff> Generate man page in NROFF format.

=cut

  ### usage ($option)
  ### Provides all kinds of textual help and stops
  my ($option)=@_;
  if (!defined($option)) {
    $option="usage";
  }
  my $cmd="pod2txt";
  my $release="0.6";
  my ($a,$out,$b);
  if ($option eq "man"||$option eq "nroff") {
    ($a,$out,$b)=@{&executeCommand("","pod2man","$0","--center","User commands","--release",$release)};
    if ($a==0 && $option eq "man") {
      ($a,$out,$b)=@{&executeCommand($out,"nroff","-man","-")};
    }
  } else {
    ($a,$out,$b)=@{&executeCommand("","pod2text","$0")};
  }
  if ($option eq "usage") {
    $out =~ s/OPTIONS.*$//s;
  }
  if ($option ne "man") {
    print $out;
  } else {
    open FILE,"|pager";
    print FILE $out;
    close FILE;
  }
  &finish(0);
}

# Command execution with stderr filtering
sub REAPER {
  my $child;
  while (($child = waitpid(-1, WNOHANG)) > 0) {
    &out(1,'exec',"Caught $child dying with status $?");
    $execContext->{'status'}->{$child} = $?;
    delete $execContext->{'children'}->{$child};
  }
  $SIG{CHLD} = \&REAPER;        # still loathe SysV
}
sub setupCommand {
  &out(1,'init','Initialize harness for command executions');
  select(STDERR); $| = 1;
  select(STDOUT); $| = 1;
  $execContext={
                'status' => {},
                'children' => {},
               };
  $SIG{CHLD} = \&REAPER;
  $SIG{INT} = sub {
    foreach my $pid (keys %{$execContext->{'children'}}) {
      kill 2,$pid;
    }
  }
}
sub errorCommand {
  my $lines=$_[0];
  foreach my $line (split /\n/m,$lines) {
    chomp $line;
    if ($line =~ $outContext->{'specialprefix'}) {
      my $part=$1;
      &out(3,'display',$part);
      if ($part =~ /^failed:/ or $part =~ /^count:/) {
        1;
      } else {
        push $execContext->{'partiallyDone'},$part;
      }
    } else {
      &out(1,'err',$line);
    }
  }
}
sub execCommand {
  my $line;
  &out(1,"exec",'Executing '.join(' ',@_));
  my $out = gensym;
  my $err = gensym;
  $execContext->{'partiallyDone'}=[];
  my $pid = open3("<&STDIN",$out, $err, @_);
  return 1 if (!$pid);
  &out(1,"exec","Forked pid $pid");
  $execContext->{'children'}->{$pid}=1;
  my $sel= new IO::Select;
  $sel->add($err,$out);
  while (scalar keys %{$execContext->{'children'}} > 0) {
    foreach my $readhandle ($sel->can_read(.5)) {
      my $length=sysread $readhandle,$line,4096;
      if ($length) {
        if (fileno($readhandle)==fileno($err)) {
          &errorCommand($line);
        } else {
          chomp $line;
          &out(1,'out',$line);
        }
      }
    }
  }
  &out(3,'exec',$execContext);
  my $status=0+$execContext->{'status'}->{$pid};
  delete $execContext->{'status'}->{$pid};
  &out(1,"exec","Command finished with status $status");
  return $status;
}
sub executeCommand {
  # a much simpler version for the manual page
  my $in=shift @_;
  &out(1,"exec",join(' ',@_));
  my $outputtext="";
  my $errtext="";
  my $pid=open3(\*INPUT, \*OUTPUT, \*ERR,@_);
  print INPUT $in if $in;
  close(INPUT);
  my $done=0;
  do {
    while (<OUTPUT>) {
      $outputtext.=$_;
    }
    while (<ERR>) {
      $errtext.=$_;
    }
    $done=waitpid($pid,WNOHANG);
  } until ($done>0);
  return [ $?, $outputtext, $errtext ];
}

# Disk Input/Output
sub fingerprint {
  my ($f)=@_;
  my $hash="0";
  return "0" unless (-e $f);
  return "0" if (-d $f);       # TODO: recursive version for directories
  open FILE,"$f" or return "$f:0";
  my $hashing = Digest::MD5->new;
  $hashing->addfile(*FILE);
  $hash=$hashing->hexdigest;
  close FILE;
  return $hash;
}
sub fingerprintArray {
  # example: $rule, 'in'
  my @a=sort keys %{$_[0]->{$_[1]}};
  return 'none' unless (scalar @a);
  my $hashing = Digest::MD5->new;
  my $fp;
  foreach my $file (@a) {
    $fp=&fingerprint($file);
    $hashing->add($file.$fp);
  }
  return $hashing->hexdigest;
}

sub encodeGoalLine {
  join("",
       map { ($_ > 127 || $_ < 32 || $_ == 37 )?
               sprintf("%%(%d)", $_) :
                 chr($_)
               } unpack("W*", &decode_utf8($_[0]))); # unpack Unicode characters
}
sub decodeGoalLine {
  my $a=$_[0];
  $a =~ s/%\(([0-9]+)\)/chr($1)/eg;
  return $a;
}

sub writeCache {
  my ($cacheHash,$path)=@_;
  &out(3,'init',"Storing $path cache");
  my $cachehandle;
  open STDIN,"/dev/null" unless fileno(STDIN);
  make_path('.tmp');
  open $cachehandle,'>',".tmp/$path" or &finish(1,"I cannot open my $path cache!");
  print $cachehandle $outContext->{'json'}->encode($cacheHash);
  $cachehandle->sync();
  close $cachehandle;
}
sub readCache {
  my ($cacheHash,$path)=@_;
  &out(1,'init',"Reading $path cache");
  local $/;
  open (my $fh,'<',".tmp/$path") or return;
  my $json=<$fh>;
  my $cache=decode_json($json);
  foreach (keys %{$cache}) {
    $cacheHash->{$_}=$cache->{$_};
  }
}

sub forceUnlink {
  my $_=shift @_;
  unlink $_;                    # TODO: this may be a directory
}
sub removeGenerated {
  my ($cacheHash,$path,$axioms)=@_;
  my $count=0;
  if (defined($axioms)) {
    &out(1,'display','Removing old files');
  } else {
    &out(1,'init','Cleaning old files cache');
  }
  # If $axioms not defined, just test presence
  # Else, unlink all files not in $axioms hash
  foreach my $key (keys %{$cacheHash}) {
    if (-f $key) {
      if (defined($axioms) and !exists($axioms->{$key})) {
        # clean or distclean
        $count++;
        &forceUnlink($key);
        delete $cacheHash->{$key};
      }
    } else {
      delete $cacheHash->{$key};
    }
  }
  &writeCache($cacheHash,$path);
  if (defined($axioms)) {
    &out(3,'display',"Removed $count old files");
  }
}

sub readAxiomsFromGit {
  &out(1,'init',"Reading axioms from git");
  open READ,"git ls-files -z|";
  my $a=<READ>;
  close READ;
  my @b=sort map {decode_utf8($_)} split("\x{00}",$a);
  &out(2,'init',\@b);
  my $hash={};
  foreach my $k (@b) {
    $hash->{$k}=1;
  }
  return $hash;
}
sub readRules {
  local $/;
  open (my $fh,'<',$rulefile);
  my $json=<$fh>;
  my $rules=decode_json($json);
  foreach my $rulename (keys %$rules) {
    my $rule=$rules->{$rulename};
    $rule->{'in'}=[] unless (defined($rule->{'in'}));
    $rule->{'arg'}=[] unless (defined($rule->{'arg'}));
    $rule->{'class'}='' unless (defined($rule->{'class'}));
    $rule->{'subclass'}='' unless (defined($rule->{'subclass'}));
  }
  $rules->{'AXIOM'}={'type' => 'axiom',
                     'actor' => 'AXIOM',
                     'class' => 'Checking axioms',
                     'subclass' => '',
                    };
  $planContext->{'pristineRules'}=$rules;
  &out(1,'init',"Read rules");
}
sub readFileList {
  my ($path,$mandatory)=@_;
  my $hash={};
  if (open FILE,'<:encoding(utf8)',$path) {
    my $line;
    while ($line=<FILE>) {
      chomp $line;
      my $g=&decodeGoalLine($line);
      $hash->{$g}++;
    }
    close FILE;
  } else {
    &out(1,'err',"Could not open $path") if defined($mandatory); 
  }
  return $hash;
}
sub readDir {
  my ($dir,$mandatory)=shift @_;
  my @dirlist;
  if (opendir(my $dh, $dir)) {
    @dirlist=grep {!/^\./} readdir($dh);
    closedir($dh);
  } else {
    &out(1,'err','Could not open directory $dir') if ($mandatory);
  }
  return @dirlist;
}

# Planning

sub actionKey {
  my $rule=shift @_;
  return $rule->{'key'} if (defined($rule->{'key'}));
  if (defined($rule->{'arg'}) and scalar @{$rule->{'arg'}} > 0) {
    $rule->{'key'}=join(' ',$rule->{'actor'},map {&encodeGoalLine($_)} @{$rule->{'arg'}});
  } else {
    $rule->{'key'}=$rule->{'actor'};
  }
  return $rule->{'key'};
}
sub recordGeneration {
  my $rule=shift @_;
  my $key=&actionKey($rule);
  my $gen=$rule->{'gen'};
  &out(2,'plan',"Rule $key is complete at generation $gen");
  $planContext->{'plan'}->{$key}=$rule;
  foreach my $outfile (keys %{$rule->{'out'}}) {
    $planContext->{'generated'}->{$outfile}=$key;
    $planContext->{'generatedgen'}->{$outfile}=$gen;
  }
}

sub recordAxioms {
  foreach my $axiom (keys %{$_[0]}) {
    $planContext->{'usedRules'}->{'AXIOM'}++;
    my $axiomRule=&clone($planContext->{'pristineRules'}->{'AXIOM'});
    $axiomRule->{'type'}='simple';
    $axiomRule->{'out'}={$axiom => 1};
    $axiomRule->{'in'}={};
    $axiomRule->{'wanted'}={};
    $axiomRule->{'arg'}=[$axiom];
    $axiomRule->{'gen'}=0;
    &recordGeneration($axiomRule);
  }
}
sub sortRules {
  my $prule=$planContext->{'pristineRules'};
  foreach my $rulename (keys %$prule) {
    $planContext->{'usedRules'}->{$rulename}=0;
    if ($prule->{$rulename}->{'type'} eq 'simple') {
      my $rule=&cleanRule(&clone($prule->{$rulename}));
      $planContext->{'simpleRules'}->{&actionKey($rule)}=$rule;
      $planContext->{'usedRules'}->{$rulename}=1;
    } elsif ($prule->{$rulename}->{'type'} eq 'pattern') {
      push $planContext->{'patternRules'},$rulename;
    }
  }
}
sub cleanRule {
  my ($rule,@list)=@_;
  my $list=scalar @list;
  my $in={};
  my $out={};
  my $class=$rule->{'class'};
  if ($class =~ /\$/) {
    foreach my $counter (1..$list) {
      $class =~ s/\$$counter/$list[$counter-1]/ge;
    }
  }
  $rule->{'class'}=$class;
  my $subclass=$rule->{'subclass'};
  if ($subclass =~ /\$/) {
    foreach my $counter (1..$list) {
      $subclass =~ s/\$$counter/$list[$counter-1]/ge;
    }
  }
  $rule->{'subclass'}=$subclass;
  foreach my $file (@{$rule->{'in'}}) {
    foreach my $counter (1..$list) {
      $file =~ s/\$$counter/$list[$counter-1]/ge;
    }
    $in->{$file}=1;
  }
  if (defined($rule->{'infile'})) {
    my $hash=[];
    foreach my $file (@{$rule->{'infile'}}) {
      foreach my $counter (1..$list) {
        $file =~ s/\$$counter/$list[$counter-1]/ge;
      }
      &out(2,'plan',"Expanding infile $file");
      push $hash,readFileList($file);
    }
    $in=&addHash($in,@$hash);
  }
  foreach my $file (@{$rule->{'out'}}) {
    foreach my $counter (1..$list) {
      $file =~ s/\$$counter/$list[$counter-1]/ge;
    }
    $out->{$file}=1;
  }
  if (defined($rule->{'outfile'})) {
    my $hash=[];
    foreach my $file (@{$rule->{'outfile'}}) {
      foreach my $counter (1..$list) {
        $file =~ s/\$$counter/$list[$counter-1]/ge;
      }
      &out(2,'plan',"Expanding outfile $file");
      push $hash,readFileList($file);
    }
    $out=&addHash($out,@$hash);
  }
  # Do something
  $rule->{'in'}=$in;
  $rule->{'out'}=$out;
  $rule->{'wanted'}=&clone($in);
  return $rule;
}
sub developPatterns {
  my ($gen,$theorems)=@_;
  foreach my $rulename (@{$planContext->{'patternRules'}}) {
    my $rule=$planContext->{'pristineRules'}->{$rulename};
    my $pattern=$rule->{'pattern'};
    my $patternRE=qr/$pattern/;
    foreach my $theorem (keys %$theorems) {
      my @list = ($theorem =~ $patternRE);
      next unless @list;
      my $arg=$rule->{'argument'};
      foreach my $counter (1..scalar @list) {
        $arg =~ s/\$$counter/$list[$counter-1]/ge;
      }
      if (defined($rule->{'allowedargs'})) {
        my $ok=0;
        foreach my $allow (@{$rule->{'allowedargs'}}) {
          if ($allow eq $arg) {
            $ok=1;last;
          }
        }
        next unless $ok;
      }
      $rule->{'arg'}=[$arg];
      my $newrule=&cleanRule(&clone($rule),@list);
      my $key=&actionKey($newrule);
      $newrule->{'trigger'}=$theorem;
      foreach my $wanted (keys %{$newrule->{'wanted'}}) {
        if (exists($planContext->{'generatedgen'}->{$wanted})
            and $planContext->{'generatedgen'}->{$wanted} < $gen) {
          delete $newrule->{'wanted'}->{$wanted};
        }
      }
      $planContext->{'simpleRules'}->{&actionKey($newrule)}=$newrule;
      $planContext->{'usedRules'}->{$rulename}++;
    }
  }
}
sub resolveSimpleRules {
  my $newtheorems={};
  my ($gen,$theorems)=@_;
  foreach my $key (keys %{$planContext->{'simpleRules'}}) {
    my $rule=$planContext->{'simpleRules'}->{$key};
    $rule->{'wanted'}=&subHash($rule->{'wanted'},$theorems);
    next if (scalar keys $rule->{'wanted'});
    # we found everyone!
    $rule->{'gen'}=$gen;
    &recordGeneration($rule);
    foreach my $out (keys %{$rule->{'out'}}) {
      $newtheorems->{$out}=1;
    }
    delete($planContext->{'simpleRules'}->{$key});
  }
  return $newtheorems;
}

sub preparePlan {
  &out(1,'plan','Initializing plan');
  my ($axioms)=@_;              # include list of lazy here
  $planContext->{'generated'}={};
  $planContext->{'plan'}={};
  $planContext->{'simpleRules'}={};
  $planContext->{'patternRules'}=[];
  $planContext->{'usedRules'}={};
  &out(3,'plan','Sorting rules');
  &sortRules();
  &out(2,'plan','Recording axioms');
  &recordAxioms($axioms);
  my $theorems=$axioms;
  my $gen=0;
  while (scalar keys %$theorems) {
    $gen++;
    &out(2,'plan',"Building theorems (generation $gen), still ".
         (scalar keys %{$planContext->{'simpleRules'}}).' rules to go');
    &developPatterns($gen,$theorems);
    $theorems=&resolveSimpleRules($gen,$theorems);
    &out(3,'plan','Found '.(scalar keys %$theorems).' new theorems');
  }
}
sub explainPlan {
  &out(1,'plan','Explaining plan');
  foreach my $key (sort keys %{$planContext->{'simpleRules'}}) {
    my $rule=$planContext->{'simpleRules'}->{$key};
    &out(1,'err',"The rule $key did not complete.");
    foreach my $missingfile (sort keys %{$rule->{'wanted'}}) {
      &out(1,'err','The file "'.&encodeGoalLine($missingfile).'" was missing.');
    }
    &out(1,'err','This rule was triggered by "'.&encodeGoalLine($rule->{'trigger'}).'".') if ($rule->{'trigger'});
  }
  my $notUsed=[];
  foreach my $rulename (sort keys %{$planContext->{'usedRules'}}) {
    my $count=$planContext->{'usedRules'}->{$rulename};
    if ($count) {
      &out(1,'out',"The rule named $rulename was used $count times.");
    } else {
      push $notUsed,$rulename;
    }
  }
  if (scalar @$notUsed > 0) {
    foreach my $rulename (@$notUsed) {
      &out(1,'err',"The rule named $rulename was not used at all.");
    }
  }
}
sub reducePlan {
  &out(1,'plan','Narrowing build paths for selected goals');
  my ($goals,$generation)=@_;
  my $plan={};
  my $seen={};
  my $requirement=&clone($goals);
  while (scalar keys %$requirement) {
    my $tab=[keys %$requirement];
    foreach my $file (keys %$requirement) {
      delete ($requirement->{$file});
      next if ($seen->{$file});
      $seen->{$file}=1;
      if (!exists($generation->{$file})) {
        &out(1,'err','No build path to "'.&encodeGoalLine($file).'".');
        next;
      }
      my $actionkey=$generation->{$file};
      my $inFiles=$planContext->{'plan'}->{$actionkey}->{'in'};
      foreach my $in (keys %$inFiles) {
        $requirement->{$in}=1 unless $seen->{$in};
      }
      $plan->{$actionkey}=1;
    }
  }
  $planContext->{'narrowPlan'}=$plan;
  my $planKeys=[sort {
    my $pa=$planContext->{'plan'}->{$a};
    my $pb=$planContext->{'plan'}->{$b};
    return ($pa->{'gen'} <=> $pb->{'gen'}) ||
      ($pa->{'actor'} cmp $pb->{'actor'}) ||
        ($pa->{'class'} cmp $pb->{'class'}) ||
          ($pa->{'subclass'} cmp $pb->{'subclass'}) ||
            ($pa->{'key'} cmp $pb->{'key'})
          } keys %$plan];
  &out(2,'plan',$planKeys);
  return $planKeys;
}

sub firstCompound {
  my ($plan,$begin) = @_;
  my $newplan=[];
  my $end=$begin+1;
  return (undef,$end) unless ($begin < scalar @$plan);
  my $planList=$planContext->{'plan'};
  my $maxend;
  my $first=$planList->{$plan->[$begin]};
  if (defined($first->{'maxargs'})) {
    $maxend=$begin+$first->{'maxargs'};
  } else {
    $maxend=$begin+100000000;
  }
  while (
         $end < scalar @$plan and
         $end < $maxend and
         $planList->{$plan->[$end]}->{'gen'} == $first->{'gen'} and
         $planList->{$plan->[$end]}->{'actor'} eq $first->{'actor'}
        ) {
    $end++;
  }
  my $candidates=[];
  # weed out already done candidates
  foreach my $i ($begin..$end-1) {
    my $rule=$planList->{$plan->[$i]};
    my $key=&actionKey($rule);
    my $fingerprintIn=&fingerprintArray($rule,'in');
    $rule->{'fingerprintIn'}=$fingerprintIn;
    my $fingerprintOut=&fingerprintArray($rule,'out');
    if (!defined($planContext->{'fingerprint'}->{$key})) {
      &out(2,"plan","Considering $key (never seen)");
    } elsif ($planContext->{'fingerprint'}->{$key} eq "$fingerprintIn $fingerprintOut") {
      &out(3,"plan","Not considering $key");
      next;
    } else {
      &out(2,"plan","Considering $key (input or output changed)");
    }
    push $candidates,$key;
  }
  if (scalar @$candidates == 0) {
    return (undef,$end);
  }
  if (scalar @$candidates == 1) {
    return ($planList->{$candidates->[0]},$end);
  }
  my $compoundRule=&clone($first);
  delete $compoundRule->{'key'};
  my $individualRules=[];
  my $newargs=[];
  my $newins=[];
  my $newouts=[];
  foreach my $key (@$candidates) {
    my $rule=$planList->{$key};
    push $newargs,@{$rule->{'arg'}};
    push $newins,$rule->{'in'};
    push $newouts,$rule->{'out'};
  }
  my $newin=addHash(@$newins);
  my $newout=addHash(@$newouts);
  $compoundRule->{'arg'}=$newargs;
  $compoundRule->{'origin'}=$candidates;
  $compoundRule->{'in'}=$newin;
  $compoundRule->{'out'}=$newout;
  return ($compoundRule,$end);
}

# Execution control

sub registerSuccess {
  my ($rule)=@_;
  my $fingerprintOut=&fingerprintArray($rule,'out');
  my $fingerprintIn=$rule->{'fingerprintIn'};
  my $key=&actionKey($rule);
  &out(3,"plan","Registering success of $key");
  $planContext->{'fingerprint'}->{$key}="$fingerprintIn $fingerprintOut";
}

sub attempt {
  my $rule=shift @_;
  my $key=&actionKey($rule);
  &out(2,'exec',"Preparing for $key");
  my @execLine=($actordir.'/'.$rule->{'actor'},@{$rule->{'arg'}});
  if ($rule->{'class'} ne '') {
    &out(1,'display',$rule->{'class'});
    if ($rule->{'subclass'} ne '') {
      &out(2,'display',$rule->{'subclass'});
    }
  } else {
    &out(1,'display',substr $key,0,72); # Default class = key
  }
  # in doubt, every possibly generated file will have been generated in the first
  # steps of the rule, so let's suppose they were.
  my $generatedHash=&addHash($planContext->{'junk'},$rule->{'out'});
  $planContext->{'junk'}=$generatedHash;
  &writeCache($planContext->{'junk'},'junk');
  my $status=&execCommand(@execLine);
  if ($status) {
    foreach my $ok (@{$execContext->{'partiallyDone'}}) {
      my $okEscaped=$rule->{'actor'}.' '.&encodeGoalLine($ok); # actionKey
      if (exists $rule->{'origin'}->{$okEscaped}) {
        &registerSuccess($planContext->{'plan'}->{$okEscaped});
      } else {
        &out(1,'err',"$ok was registered as done, but no rule by that name exists");
      }
    }
    &writeCache($planContext->{'fingerprint'},'fingerprint');
    &finish(1,"One rule failed with status $status");
  } else {
    if (exists($rule->{'origin'})) {
      foreach my $ok (@{$rule->{'origin'}}) {
        &registerSuccess($planContext->{'plan'}->{$ok});
      }
    } else {
      &registerSuccess($rule);
    }
    &writeCache($planContext->{'fingerprint'},'fingerprint');
  }
}

# Graphing

sub graphviz {
  # TODO enhance.
  # Collapse all targets produced by patterns as one node.
  # Collapse all actions produced by patterns as one node.
  my ($plan,$gen)=@_;
  my $rule;
  print "digraph How {\n  node [shape=box];\n";
  foreach my $key (@$plan) {
    $rule=$planContext->{'plan'}->{$key};
    next if $rule->{'actor'} eq 'AXIOM';
    print "  \"$key\";\n";
  }
  print "  node [shape=ellipse];\n";
  foreach my $key (@$plan) {
    $rule=$planContext->{'plan'}->{$key};
    next if $rule->{'actor'} eq 'AXIOM';
    foreach my $file (keys %{$rule->{'out'}}) {
      print "  \"$key\" -> \"$file\";\n";
    }
    foreach my $file (keys %{$rule->{'in'}}) {
      print "  \"$file\" -> \"$key\";\n";
    }
  }
  print "}\n";
}

# Documentation

if ('' eq 'DOC PRINCIPLES') {
  1;

=pod

=head1 PRINCIPLE

TODO

=head1 RULES

TODO

=head1 EXPLAINING

The B<--why> and B<--how> specifiers will disable file generation and
explain by a simple graph which file is output starting from the
specified goals (B<--why>) or an input from the specified goals
(B<--how>). The graph is in I<graphviz> format.

=head1 GOALS AND TARGETS

The various goals files are filenames with one name per line. The names
may be escaped by using the %(hexadecimal) notation (you will most
probably never encounter that).

Targets are predefined list of goals that can be used instead of
specifying individual goals. The target names are usually sufficient to
use them as goals.

There is one default target: the I<all> target is the list of all
buildable files.

If no goals are given, then the target I<finals> will be used by default
(even if it is not defined).

=head1 FILES

=over

=item * C<plan/targets/I<target>> a list of goals aliased as a target

=item * C<plan/lazy> a list of goals stored in git but not axioms

=item * C<plan/axioms> a list of goals not stored in git but considered as axioms

Beware that if plan/axioms is not empty, your project may be buildable
locally, but fail from the repository.

=item * C<plan/in/I<name>> a good place to put files read by "infile" directives.

=item * C<plan/out/I<name>> a good place to put files read by "outfile" directives.

=item * C<plan/actors/I<ACTOR>> a short script that executes the rule named
I<ACTOR> and receives the various arguments as $1, $2, etc.

=item * C<plan/rules> a JSON encoded file containing the rules.

=back

=head1 AUTHOR

Copyright Jean-Christophe Dubacq 2013

=head1 COPYING

This work is licensed under the BSD licence. It is explicitly stated
here that the license does not extend to the data managed by the
program, in case anyone had doubts.

=cut

}