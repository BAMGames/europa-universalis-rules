#!/usr/bin/perl

# Idea: allow for lazy axioms in plan/lazy
## These axioms would not be considered if option --hard is given
## Overwriting these axioms is not considered an error.
## A rule overwriting only these axioms must be ignored.
## Example: generating .pfb .afm from .sfd files
# Idea: pseudo-targets clean distclean
# Idea: manage inside files (both written and read in one actor)

use strict;
use warnings;
use JSON::PP;
use Data::Dumper;
use URI::Escape;
use Digest::MD5;
use Symbol 'gensym';
use File::Path qw(make_path);

my %verbosity=('exec'=>0,
               'init'=>0,
               'plan'=>0,
               'display'=>1);
# Logging

sub out {
  my $v=shift @_;
  my $n=shift @_;
  if ($verbosity{$n}>=$v) {
    if ($n ne "display") {
      print $n,':',@_,"\n";
    } else {
      print @_,"\n";
    }
  }
}

sub stop {
  my $status=shift @_;
  &out(1,'display',@_);
  exit ($status);
}

# ARGV

sub parseARGV {
  my $goals=[];
  my $mode="goal";
  my $target="finals";
  my %target=('all'=>1,'finals'=>1);
  my $x=0;
  while ($x < scalar @ARGV) {
    my $arg=$ARGV[$x];
    if ($arg eq '--verbosity') {
      die "Wrong option: --verbosity must be followed by two arguments" unless defined($ARGV[$x+2]);
      my $cat=$ARGV[$x+1];
      my $level=$ARGV[$x+2];
      $x+=2;
      die "Wrong option: --verbosity must be followed by either ".join(' or ',keys %verbosity) unless defined($verbosity{$cat});
      die "Wrong option: --verbosity must be followed by a category and an integer" unless $level =~ /^[0-9]+$/;
      $verbosity{$cat}=$level;
    } elsif ($arg eq 'clean' or $arg eq '--clean') {
      $mode="clean";
    } elsif ($arg eq 'distclean' or $arg eq '--distclean') {
      $mode="distclean";
    } elsif (defined($target{$arg}) or $arg eq '--target') {
      if ($arg eq '--target') {
        $x++;
        $arg=$ARGV[$x];
      }
      $target=$arg;
    } elsif ($arg eq '--') {
      $x++;
      while ($x < scalar @ARGV) {
        push $goals,$ARGV[$x];
        $x++;
      }
    } else {
      push $goals,$arg;
    }
    $x++;
  }
  return ($goals,$target,$mode);
}

my ($goals,$target,$mode)=&parseARGV();
&out(1,"init","Parsing ARGV done");

my %implemented=('goal' => 1,'distclean' => 1, 'clean' => 1);
die "$mode is not implemented yet" unless defined($implemented{$mode});

# Command execution with stderr filtering

use IPC::Open3;
use POSIX ":sys_wait_h";
use IO::Select;
use IO::Handle;
my %statusCommand=();
my %childCommand=();
select(STDERR); $| = 1;
select(STDOUT); $| = 1;

sub REAPER {
  my $child;
  while (($child = waitpid(-1, WNOHANG)) > 0) {
    $statusCommand{$child} = $?;
    delete $childCommand{$child};
  }
  $SIG{CHLD} = \&REAPER;        # still loathe SysV
}
sub setupCommand {
  $SIG{CHLD} = \&REAPER;
  $SIG{INT} = sub {
    foreach my $pid (keys %childCommand) {
      kill 2,$pid;
    }
  };
}

my $specialprefix=qr/^PARTIAL PLAN:(.*)$/;
$ENV{'SPECIALPREFIX'}="PARTIAL PLAN:";
my @partiallydone=();

sub errorCommand {
  my $line=$_[0];
  chomp $line;
  if ($line =~ $specialprefix) {
    my $part=$1;
    print "[  ]",$part,"\n";
    if ($part =~ /^failed:/) {
    } else {
      push @partiallydone,$part;
    }
  } else {
    print STDERR $line,"\n";
  }
}

sub execCommand {
  my $line;
  &out(1,"exec",@_);
  my $err = gensym;
  my $pid = open3("<&STDIN",">&STDOUT", $err, @_);
  if ($pid) {
    $childCommand{$pid}=1;
    # This method still outputs $err to the tty
    # It is supposed to be less risky wrt block
    # my $sel= new IO::Select;
    # $sel->add($err);
    # while (scalar keys %childCommand > 0) {
    #   foreach my $readhandle ($sel->can_read(1)) {
    #     my $length=sysread $readhandle,$line,4096;
    #     if ($length) {
    #       &errorCommand($line);
    #     }
    #   }
    # }
    while (scalar keys %childCommand > 0) {
      while (my $line=<$err>) {
        &errorCommand($line);
      }
    }
  }
  my $status=0+$statusCommand{$pid};
  delete $statusCommand{$pid};
  &out(1,"exec","Command finished with status $status");
  return $status;
}

&out(1,'init','Initialize harness for command executions');
&setupCommand;

my $axiomdir='plan/axioms';
my $finaldir='plan/finals';
my $rulefile='plan/rules';

my %axioms=();
my %finals=();
my @theorems=();
my %generation=();
my @rules;
my $trigger=[];
my %bottomupseen=();
my %rules=();
my %fingerprintCache=();
my %generatedCache=();
my $result=[];

sub fingerprint() {
  my ($f)=@_;
  my $hash="0";
  return "$f:0" if (-d $f);
  return "$f:0" unless (-e $f);
  open FILE,"$f" or return "$f:0";
  my $hashing = Digest::MD5->new;
  $hashing->addfile(*FILE);
  $hash=$hashing->hexdigest;
  close FILE;
  return $hash;
}

sub fingerprintArray() {
  # example: $rule, 'in'
  my @a=@{$_[0]->{$_[1]}};
  return 'none' unless (scalar @a);
  my $hashing = Digest::MD5->new;
  my $fp;
  foreach my $file (@a) {
    $fp=&fingerprint($file);
    $hashing->add($file.$fp);
  }
  return $hashing->hexdigest;
}


sub writeCache() {
  my ($cacheHash,$path)=@_;
  &out(3,'init',"Storing $path cache");
  my $cachehandle;
  open STDIN,"/dev/null" unless fileno(STDIN);
  make_path('.tmp');
  open $cachehandle,'>',".tmp/$path" or die;
  print $cachehandle encode_json $cacheHash;
  $cachehandle->sync();
  close $cachehandle;
}

sub readCache() {
  my ($cacheHash,$path)=@_;
  &out(1,'init',"Reading $path cache");
  local $/;
  open (my $fh,'<',".tmp/$path") or return;
  my $json=<$fh>;
  my $cache=decode_json($json);
  foreach (keys %{$cache}) {
    $cacheHash->{$_}=$cache->{$_};
  }
}

sub removeGenerated() {
  my ($cacheHash,$path,$axioms)=@_;
  my $count=0;
  if (defined($axioms)) {
    &out(1,'display','Removing old files');
  } else {
    &out(1,'init','Cleaning old files cache');
  }
  # If not defined, just test presence
  # Else, unlink all files not in $axioms hash
  foreach my $key (keys %{$cacheHash}) {
    if (-f $key) {
      if (defined($axioms) and !defined($axioms->{$key})) {
        # clean or distclean
        $count++;
        unlink uri_unescape($key);
        delete $cacheHash->{$key};
      }
    } else {
      delete $cacheHash->{$key};
    }
  }
  &writeCache($cacheHash,$path);
  if (defined($axioms)) {
    &out(1,'display',"Removed $count old files");
  }
}

sub readAxioms() {
  my $axiomtype=shift @_;
  my $axiomdir=shift @_;
  my $axioms=shift @_;
  &out(1,"init","Reading $axiomtype from $axiomdir");
  opendir(my $dh, $axiomdir) || return;
  while (readdir $dh) {
    next if /^[.]/;
    my $axiomfile=$axiomdir."/".$_;
    open FILE,$axiomfile;
    while (my $line=<FILE>) {
      chomp $line;
      next if $line=~/^#/;
      $axioms->{uri_unescape($line)}=1;
    }
    close FILE;
  }
  closedir $dh;
}

sub shallowCopy() {
  my $a=[];
  foreach my $b (@{$_[0]}) {
    push $a,$b;
  }
  return $a;
}

sub readRules() {
  local $/;
  open (my $fh,'<',$rulefile);
  my $json=<$fh>;
  my $rules=decode_json($json);
  @rules=@{$rules};
  foreach my $rule (@rules) {
    $rule->{'in'}=[] unless (defined($rule->{'in'}));
    push $rule->{'in'},'plan/bin/'.$rule->{'actor'};
    $rules{$rule->{"actor"}}=$rule;
  }
  $rules{'AXIOM'}={'type' => 'AXIOM','in'=>['plan/bin/AXIOM']};
}

sub recordGeneration() {
  my %rule=%{$_[0]};
  my $gen=$rule{'gen'};
  my $arrayarg=[];
  if (defined($rule{'arg'})) {
    push $arrayarg,map {&uri_escape($_)} @{$rule{'arg'}};
  }
  $rule{'arg'}=$arrayarg;
  foreach my $thm (@{$rule{'out'}}) {
    die "Regenerated $thm in generation $gen" if (exists $generation{$thm});
    $generation{$thm}={'gen' => $gen,
                       'actor' => uri_escape($rule{'actor'}),
                       'arg' => $arrayarg,
                       'in' => [@{$rule{'in'}}],
                       'out' => [@{$rule{'out'}}],
                      };
  }
}

sub actionKey() {
  my %a=%{$_[0]};
  return join(' ',$a{'actor'},@{$a{'arg'}}) if (defined($a{'arg'}));
  return $a{'actor'};
}

sub nextGeneration() {
  my ($gen,$previousthm) = @_;
  &out(3,"plan","Building list of buildable files, generation $gen");
  my @current=@$previousthm;
  my $rulenum=-1;
  my $found=[];
  foreach my $rule (@rules) {
    $rulenum++;
    if ($rule->{'type'} eq 'simple' ) {
      my $key=&actionKey($rule);
      next if (exists($bottomupseen{$key}));
      my $allfound=1;
      foreach my $requirement (@{$rule->{'in'}}) {
        if (!exists($generation{$requirement})
            or $generation{$requirement} < $gen) {
          $allfound=0;last;
        }
      }
      if ($allfound) {
        $rules{$rule->{"actor"}}->{'seen'}=1;
        $bottomupseen{$key}=1;
        &recordGeneration({'gen' => $gen,
                           'in' => $rule->{'in'},
                           'actor' => $rule->{'actor'},
                           'out' => $rule->{'out'}});
        push $found,@{$rule->{'out'}};
      }
    } elsif ($rule->{'type'} eq 'pattern' ) {
      my $pattern=$rule->{'pattern'};
      my $patternRE=qr/$pattern/;
      foreach my $candidate (@current) {
        my @list;
        if (@list = ($candidate =~ $patternRE)) {
          my @in=();
          my @out=();
          foreach my $infile (@{$rule->{'in'}}) {
            push @in, $infile;
          }
          foreach my $outfile (@{$rule->{'out'}}) {
            push @out, $outfile;
          }
          if (defined($rule->{'infile'})) {
            foreach my $infile (@{$rule->{'infile'}}) {
              my $inf=''.$infile;
              foreach my $counter (1..$#list+1) {
                $inf =~ s/\$$counter/$list[$counter-1]/ge;
              }
              if (open FILE,$inf) {
                foreach (<FILE>) {
                  chomp;
                  push @in,$_;
                }
                close FILE;
              }
            }
          }
          my $argument=$rule->{'argument'};
          foreach my $counter (1..$#list+1) {
            $argument =~ s/\$$counter/$list[$counter-1]/ge;
            foreach (@in,@out) {
              s/\$$counter/$list[$counter-1]/ge;
            }
          }
          my $key=&actionKey({'actor'=>$rule->{'actor'},'arg'=>[$argument]});
          next if exists($bottomupseen{$key});
          $bottomupseen{$key}=1;
          push $trigger,{
                         'rulenum' => $rulenum,
                         'actor' => $rule->{'actor'},
                         'arg' => [$argument],
                         'in' => [ @in ],
                         'wanted' => [ @in ],
                         'out' => [ @out ]
                        };
        }
      }
    }
  }

  my $delayednumber=0;
  my $triggercopy=&shallowCopy($trigger);
  foreach my $delayed (@$triggercopy) {
    my @wanted=@{$delayed->{'wanted'}};
    my $i=0;
    my $wantedcopy=&shallowCopy(\@wanted);
    foreach my $wanted (@$wantedcopy) {
      if (exists($generation{$wanted}) && $generation{$wanted}->{'gen'}<$gen) {
        splice $delayed->{'wanted'},$i,1;
        $i--;
      }
      $i++;
    }
    @wanted=@{$delayed->{'wanted'}};
    if (scalar @wanted == 0) {
      $delayed->{'gen'}=$gen;
      &recordGeneration($delayed);
      push $found,@{$delayed->{'out'}};
      splice $trigger,$delayednumber,1;
      $delayednumber--;
    }
    $delayednumber++;
  }
  return $found;
}

sub bottomUp {
  my @axioms=sort keys %axioms;
  my $currentgen=\@axioms;
  my $generation=1;
  my $newlength=scalar @axioms;
  &out(2,"plan","Building list of buildable files");
  while ($newlength) {
    $currentgen=&nextGeneration($generation,$currentgen);
    $newlength=scalar @{$currentgen};
    $generation++;
  }
  foreach my $actor (keys %rules) {
    if (!defined($rules{$actor}->{'seen'})
        and $rules{$actor}->{'type'} eq 'simple') {
      &out(2,'plan',"The rule $actor was not used at all");
      &out(3,'plan',Dumper($rules{$actor}));
    }
  }
  &out(4,"plan",Dumper(\%generation));
}

sub topDown {
  # Now, collect only the goals
  &out(2,"plan","Isolating goals paths from $target");
  my %topdownseen=();
  my $mygoals=$goals;
  my %idontknow=();
  my %ineed=();

  if ($target eq 'all') {
    push $mygoals,keys %generation;
  } elsif ($target eq 'finals') {
    push $mygoals,keys %finals;
  }

  &out(4,"plan","Final list of goals established: ".join(' ',@$mygoals));
  while (scalar @$mygoals) {
    my $goal=pop $mygoals;
    do {
      $idontknow{$goal}=1;next;
    } unless (exists($generation{$goal}));
    my $key=&actionKey($generation{$goal});
    next if exists($topdownseen{$key});
    $topdownseen{$key}=1;
    $ineed{$key}=$generation{$goal};
    push $mygoals,@{$generation{$goal}->{'in'}};
  }
  if (scalar keys %idontknow) {
    print "I do not know how to build the following goals:\n";
    print join("\n",sort keys %idontknow),"\nStopping.\n";
    exit 1;
  }
  my @result=sort {
    ($a->{'gen'} <=> $b->{'gen'}) || ($a->{'actor'} cmp $b->{'actor'}) || (join(' ',$a->{'arg'}) cmp join(' ',$b->{'arg'}))
  } values %ineed;
  return \@result;
}

sub firstCompound {
  my ($plan,$begin) = @_;
  my $newplan=[];
  return undef unless (scalar @$plan);
  my $end=$begin+1;
  my $maxend;
  my $axiom=$plan->[$begin]->{'actor'};
  if (defined($rules{$axiom}->{'maxargs'})) {
    $maxend=$begin+$rules{$axiom}->{'maxargs'};
  } else {
    $maxend=$begin+100000000;
  }
  while (
         $end < scalar @$plan and
         $end < $maxend and
         $plan->[$end]->{'gen'} == $plan->[$begin]->{'gen'} and
         $plan->[$end]->{'actor'} eq $plan->[$begin]->{'actor'}
        ) {
    $end++;
  }
  my $candidates=[];
  # weed out already done candidates
  foreach my $i ($begin..$end-1) {
    my $key=&actionKey($plan->[$i]);
    my $fingerprintIn=&fingerprintArray($plan->[$i],'in');
    $plan->[$i]->{'fingerprintIn'}=$fingerprintIn;
    my $fingerprintOut=&fingerprintArray($plan->[$i],'out');
    if ((defined($fingerprintCache{$key})
         and $fingerprintCache{$key} eq "$fingerprintIn $fingerprintOut")
       ) {
      &out(3,"plan","Not considering $key");
      next;
    } elsif (!defined($fingerprintCache{$key})) {
      &out(2,"plan","Considering $key (never seen)");
    } else {
      &out(2,"plan","Considering $key (input or output changed)");
    }
    push $candidates,$i;
  }
  # TODO
  my $compoundRule={'gen' =>$plan->[$begin]->{'gen'},
                    'actor' =>$plan->[$begin]->{'actor'},
                    'arg' => [],
                   };
  my $individualRules=[];
  my $newargs=$compoundRule->{'arg'};

  foreach my $i (@$candidates) {
    push $newargs,@{$plan->[$i]->{'arg'}};
    push $individualRules,$plan->[$i];
  }
  my $newin={};
  my $newout={};
  foreach my $i (@$candidates) {
    foreach my $j (@{$plan->[$i]->{'in'}}) {
      $newin->{$j}=1;
    }
    foreach my $j (@{$plan->[$i]->{'out'}}) {
      $newout->{$j}=1;
    }
  }
  my @newin=sort keys $newin;
  my @newout=sort keys $newout;
  $compoundRule->{'in'}=\@newin;
  $compoundRule->{'out'}=\@newout;
  return ($compoundRule,$candidates,$end);
}

sub registerSuccess() {
  my ($candidate,$plan)=@_;
  my $rule=$plan->[$candidate];
  my $fingerprintOut=&fingerprintArray($rule,'out');
  my $fingerprintIn=$rule->{'fingerprintIn'};
  my $key=&actionKey($rule);
  &out(2,"plan","Registering success of $key");
  $fingerprintCache{$key}="$fingerprintIn $fingerprintOut";
}

sub attempt() {
  my $todo=$_[0];
  my @candidateRules=@{$_[1]};
  @partiallydone=();
  my @execLine=($todo->{'actor'});
  push @execLine,map {uri_unescape($_)} @{$todo->{'arg'}} if (scalar @{$todo->{'arg'}});
  my $line=join(' ',@execLine);
  my $success=substr $line,0,72;
  $success.="..." if ($success ne $line);
  $execLine[0]='plan/bin/'.$todo->{'actor'};
  if ($todo->{'actor'} eq "AXIOM") {
    &out(2,'display',$success);
  } else {
    &out(1,'display',$success);
  }
  my @tab=();
  push @tab,@{$todo->{'out'}} if defined($todo->{'out'});
  push @tab,@{$todo->{'junk'}} if defined($todo->{'junk'});
  foreach my $file (@tab) {
    $generatedCache{$file}=1;
  }
  &writeCache(\%generatedCache,'generated');
  my $status=&execCommand(@execLine);
  if ($status) {
    foreach my $ok (@partiallydone) {
      my $protectedok=uri_escape($ok);
      foreach my $i (@candidateRules) {
        my $rule=$result->[$i];
        if (defined $rule->{'arg'}
            and scalar @{$rule->{'arg'}} == 1
            and $rule->{'arg'}->[0] eq $protectedok) {
          &registerSuccess($i,$result);
          last;
        }
      }
    }
    &writeCache(\%fingerprintCache,'fingerprint');
    &stop(1,"One rule failed with status $status") if ($status);
  }
  # register success of everybody
  &out(3,"plan","Everything was successful");
  foreach my $i (@candidateRules) {
    &registerSuccess($i,$result);
  }
  &writeCache(\%fingerprintCache,'fingerprint');
}

&readAxioms("axioms",$axiomdir,\%axioms);
&readAxioms("finals",$finaldir,\%finals);
&readCache(\%fingerprintCache,'fingerprint');

&readCache(\%generatedCache,'generated');
&removeGenerated(\%generatedCache,'generated',undef);

if ($mode eq "distclean" or $mode eq "clean") {
  my %protected=();
  foreach my $i (keys %axioms) {
    $protected{$i}=1;
  }
  if ($mode eq "clean") {
    foreach my $i (keys %finals) {
      $protected{$i}=1;
    }
  }
  &removeGenerated(\%generatedCache,'generated',\%protected);
  exit 0;
}

&readRules();
&out(3,"plan","Recording axioms");
foreach my $axiom (sort keys %axioms) {
  &recordGeneration({'gen'=>0,
                     'actor' => "AXIOM",
                     'in' => [],
                     'arg' => [$axiom],
                     'out' => [$axiom]
                    });
}
&bottomUp();
$result=&topDown();
my $todo;
my $todoIndividuals;
my $begin=0;
my $end=0;

my $done=0;
while ($end < scalar @$result) {
  ($todo,$todoIndividuals,$end)=&firstCompound($result,$begin);
  $begin=$end;
  next if ((scalar @{$todoIndividuals}) == 0);
  $done++;
  &attempt($todo,$todoIndividuals);
}

if ($done==0) {
  &out(1,"display","Everything is up to date");
}
exit 0;
