#!/usr/bin/perl

# Idea: allow for lazy axioms in plan/lazy
## These axioms would not be considered if option --hard is given
## Overwriting these axioms is not considered an error.
## A rule overwriting only these axioms must be ignored.
## Example: generating .pfb .afm from .sfd files
# Idea: manage inside files (both written and read in one actor)
# Idea: pseudo-target sweep to remove unmakeable non-axiom files


if ('' cmp 'DOC SYNOPSIS') {

=pod

=head1 NAME

plan - build files by applying a set of fixed rules

=head1 SYNOPSIS

plan [B<--target>] I<targetname> ...

plan [B<-->] I<goal> [I<goal>] (only goals)

plan B<--why> I<goal> [I<goal>] (only goals)

plan B<--how> I<goal> [I<goal>] (only goals)

plan B<--help>|B<--man>|B<--nroff>|B<--usage>

If a goal could be mistaken for another option, use the B<--> form.

=cut

}

use strict;
use warnings;
# Unicode safety
use utf8;
use Encode;
binmode(STDOUT,':utf8');
binmode(STDERR,':utf8');
binmode(STDIN,':utf8');

use JSON::PP;
use Data::Dumper;
use URI::Escape;
use Digest::MD5;
use Symbol 'gensym';
use File::Path qw(make_path);
use Cwd;
use Term::ANSIColor;
# command execution
use IPC::Open3;
use POSIX ":sys_wait_h";
use IO::Select;
use IO::Handle;

my $execContext;
my $planContext;
my $outContext;

# Directories

my $axiomdir='plan/axioms';
my $finaldir='plan/finals';
my $rulefile='plan/rules';
my $actordir='plan/bin';
my $targetdir='plan/targets';

# Convenience

sub clone {
  my $obj=shift @_;
  my $t=ref($obj);
  return $obj unless ($t);
  return [map {&clone($_)} @$obj] if ($t eq 'ARRAY');
  my $n={};
  foreach my $key (keys %$obj) {
    $n->{$key}=&clone($obj->{$key});
  }
  return $n;
}

sub findGitTopdir {
  my $oldcwd='';
  my $cwd=getcwd();
  while ($oldcwd ne $cwd and !opendir(GITDIR,".git")) {
    chdir('..');
    $cwd=getcwd();
  }
  closedir(GITDIR);
  &finish(1,"Could not find the top-level directory") if $cwd eq $oldcwd;
  &out(1,'init','Relocated to project top directory');
}

sub addHash {
  my $hash={};
  foreach my $h (@_) {
    foreach my $k (keys %$h) {
      $hash->{$k}=1;
    }
  }
  return $hash;
}
sub subHash {
  my $hash={}; # TODO optimize if first hash much larger than second?
  my $init=shift @_;
  foreach my $k (keys %$init) {
    $hash->{$k}=1;
  }
  foreach my $h (@_) {
    foreach my $k (keys %$h) {
      delete ($hash->{$k}) if (exists($hash->{$k}));
    }
  }
  return $hash;
}

sub main {
  my %implemented=('goal' => 1,
                   'distclean' => 1,
                   'clean' => 1,
                   'help-help' => 1,
                   'help-man' => 1,
                   'help-nroff' => 1,
                   'help-usage' => 1,
                  );
  &initLogging();
  &findGitTopdir();
  my ($goals,$targets,$mode)=&parseARGV();
  if ($mode =~ /^help-([a-z]+)/) {
    &usage($1);
  }
  &finish(1,"$mode is not implemented yet") unless defined($implemented{$mode});
  &setupCommand();
  &readRules();
  my $axioms=&readAxiomsFromGit();
  my $exceptions=&readFileList('plan/axioms');
  my $notaxioms=&readFileList('plan/notaxioms');
  my $realaxioms=addHash($axioms,$exceptions);
  $realaxioms=subHash($realaxioms,$notaxioms);
  my $plan=&preparePlan($realaxioms);
  &finish(0);
}

&main();

# Logging

sub initLogging {

=pod

=head2 GENERIC OPTIONS

B<--verbosity> I<category> I<level> Change the verbosity to I<level> in I<category>.

B<--I<category>> I<level> Shortcut, as above.

If verbosity can be mistaken for a target name, use the B<--verbosity> form, because the target will take precedence.

The verbosity level is a positive integer (including 0).

The various categories are :

=over

=item * B<init> initialization information (not usefule)

=item * B<plan> informations about the building plan (can be very verbose)

=item * B<exec> informations about the commands launched by the plan

=item * B<err> the error output of the various commands

=item * B<out> the console output of the various commands

=item * B<display> the summary of the building (1: each class, 2: each subclass, 3: each item)

=back

Each rule can define a class and a subclass, and each item built will be
output in a synthetic manner. The default setting is 3 for B<display>
and 1 for B<out> and B<err>. A quiet effect can be obtained by setting
everything to 0.

=cut

  my $verbosity={'exec'=>0,
                 'init'=>0,
                 'plan'=>0,
                 'out'=>1,
                 'err'=>1,
                 'dev'=>1,
                 'display'=>3};
  my $jsonEncoder=JSON::PP->new->pretty;
  $outContext={
               'color' => 1,
               'class' => '',
               'subclass' => '',
               'currentcol' => 0,
               'nomove' => 0,
               'countphase' => '',
               'lastcountcol' => 0,
               'verbosity' => $verbosity,
               'specialprefix' => qr/^PARTIAL PLAN:(.*)$/,
               'json' => $jsonEncoder,
              };
  $ENV{'SPECIALPREFIX'}="PARTIAL PLAN:";
  $outContext->{'color'}=0 unless -t STDOUT;
  &out(1,'init','Logging system ready');
}                               # DOC INSIDE
sub finish {
  my $status=shift @_;
  &newline();
  if ($status == 1) {
    print "Dying: ",@_,"\n";
  }
  exit($status);
}
sub newline {
  print "\n" if ($outContext->{'currentcol'});
  $outContext->{'currentcol'}=0;
  $outContext->{'nomove'}=0;
}
sub class {
  my $class=$_[0];
  if ($class ne $outContext->{'class'}) {
    &newline();
    $outContext->{'subclass'}='';
    print color 'bold' if ($outContext->{'color'});
    print $class,"\n";
    print color 'reset' if ($outContext->{'color'});
    $outContext->{'class'}=$class;
  }
}
sub subclass {
  my $subclass=$_[0];
  if ($subclass ne $outContext->{'subclass'}) {
    $outContext->{'subclass'}=$subclass;
    print color 'bold' if ($outContext->{'color'});
    &outDisplay($subclass);
    print color 'reset' if ($outContext->{'color'});
  }
}
sub outDisplay {
  my $str=join('',@_);
  my $storepos=0;
  if ($str =~ /^count:(.*):([0-9\/]+)$/) {
    $str="$1:$2";
    my $oldcountphase=$outContext->{'countphase'};
    my $countphase="$1";
    $outContext->{'countphase'}=$countphase;
    if ($outContext->{'color'} == 0) {
      my $lastcountcol=$outContext->{'lastcountcol'}+1;
      if ($lastcountcol == 500) {
        $lastcountcol=0;
      }
      if ($countphase ne $oldcountphase) {
        $lastcountcol=0;
      }
      $outContext->{'lastcountcol'}=$lastcountcol;
      return if ($lastcountcol != 0);
    } else {
      if ($outContext->{'nomove'} == 1 and $countphase eq $oldcountphase) {
        $storepos=2;
      } else {
        $storepos=1;
      }
    }
  } else {
    $outContext->{'countphase'}='';
  }
  my $len=length($str);
  if ($outContext->{'currentcol'}+2+$len>80) {
    &newline();
  }
  if ($outContext->{'currentcol'}==0) {
    print "    ";
    $outContext->{'currentcol'}=4;
  }
  if ($storepos == 1) {
    $outContext->{'nomove'}=1;
    $outContext->{'lastcountcol'}=$outContext->{'currentcol'};
    print "\x1b[s";
  } elsif ($storepos == 2) {
    $outContext->{'nomove'}=1;
    $outContext->{'currentcol'}=$outContext->{'lastcountcol'};
    print "\x1b[u";
  } else {
    $outContext->{'nomove'}=0;
  }
  $outContext->{'currentcol'}+=2+$len;
  print '[',$str,']';
}
sub out {
  my $v=shift @_;
  my $n=shift @_;
  if ($outContext->{'verbosity'}->{$n}>=$v) {
    if (ref($_[0])) {
      $_[1] = Data::Dumper->Dump([$_[0]],[$_[1]]);
      shift @_;
    }
    if ($n eq "display") {
      my $storepos=0;
      if ($v==1) {
        &class(@_);
      } elsif ($v==2) {
        &subclass(@_);
      } else {
        &outDisplay(@_);
      }
    } elsif ($n eq "out") {
      &newline();
      print color 'blue' if ($outContext->{'color'});
      print "      ",@_,"\n";
      print color 'reset' if ($outContext->{'color'});
    } elsif ($n eq 'err' or $n eq 'dev') {
      &newline();
      print color 'red' if ($outContext->{'color'});
      print @_,"\n";
      print color 'reset' if ($outContext->{'color'});
    } else {
      &newline();
      print $n,':',@_,"\n";
    }
  }
}

# ARGV

sub parseARGV {
  my $goals=[];
  my $mode="goal";
  my $targets=[];
  my %target=('all'=>1,'finals'=>1); # TODO read from the plan/targets/ DIR
  my $x=0;
  while ($x < scalar @ARGV) {
    my $arg=$ARGV[$x];
    if (defined($target{$arg}) or $arg eq '--target') {
      if ($arg eq '--target') {
        $x++;
        $arg=$ARGV[$x];
      }
      push $targets,$arg;
    } elsif ($arg eq '--verbosity') {
      &finish(1,"Wrong option: --verbosity must be followed by two arguments") unless defined($ARGV[$x+2]);
      my $cat=$ARGV[$x+1];
      my $level=$ARGV[$x+2];
      $x+=2;
      &finish(1,"Wrong option: --verbosity must be followed by one of ".join(' or ',keys %{$outContext->{'verbosity'}})) unless defined($outContext->{'verbosity'}->{$cat});
      &finish(1,"Wrong option: --verbosity must be followed by a category and an integer") unless $level =~ /^[0-9]+$/;
      $outContext->{'verbosity'}->{$cat}=$level;
    } elsif ($arg eq '--help') {
      $mode="help-help";
    } elsif ($arg eq '--help' or $arg eq '-h') {
      $mode="help-help";
    } elsif ($arg eq '--man') {
      $mode="help-man";
    } elsif ($arg eq '--usage') {
      $mode="help-usage";
    } elsif ($arg eq '--nroff') {
      $mode="help-nroff";
    } elsif ($arg eq 'why' or $arg eq '--why') {
      $mode="why";
    } elsif ($arg eq 'how' or $arg eq '--how') {
      $mode="how";
    } elsif ($arg eq 'clean' or $arg eq '--clean') {
      $mode="distclean";
    } elsif ($arg eq 'distclean' or $arg eq '--distclean') {
      $mode="distclean";
    } elsif ($arg =~ '--(\w+)' and defined($outContext->{'verbosity'}->{$1})) {
      my $cat=$1;
      my $level=$ARGV[$x+1];
      $x++;
      &finish(1,"Wrong option: --verbosity must be followed by a category and an integer") unless $level =~ /^[0-9]+$/;
      $outContext->{'verbosity'}->{$cat}=$level;
    } elsif ($arg eq '--') {
      $x++;
      while ($x < scalar @ARGV) {
        push $goals,$ARGV[$x];
        $x++;
      }
    } else {
      push $goals,$arg;
    }
    $x++;
  }
  if (scalar @$goals == 0 and scalar @$targets == 0) {
    push $targets,'finals';
  }
  &out(1,"init","Parsing ARGV done");
  return ($goals,$targets,$mode);
}
sub instantiateTargets {
  my $targets=shift @_;
  my $goals=shift @_;
  my $generation=shift @_;
  my $goalHash={};
  foreach my $g (@$goals) {
    $goalHash->{$g}++;
  }
  foreach my $f (@$targets) {
    if ($f eq 'all') {
      foreach my $g (keys %$generation) {
        $goalHash->{$g}++;
      }
    } else {
      if (open FILE,$targetdir.'/'.$f) {
        my $g=<FILE>;
        $g=decodeGoalLine($g);
        $goalHash->{$g}++;
        close FILE;
      }
    }
  }
  return sort keys %$goalHash;
}

# Help
sub usage {

=pod

=head2 HELP OPTIONS

B<--help>|B<-h> Generate this help (long version).

B<--usage> Generate this help (short version).

B<--man> Generate man page.

B<--nroff> Generate man page in NROFF format.

=cut

  ### usage ($option)
  ### Provides all kinds of textual help and stops
  my ($option)=@_;
  if (!defined($option)) {
    $option="usage";
  }
  my $cmd="pod2txt";
  my $release="0.6";
  my ($a,$out,$b);
  if ($option eq "man"||$option eq "nroff") {
    ($a,$out,$b)=@{&executeCommand("","pod2man","$0","--center","User commands","--release",$release)};
    if ($a==0 && $option eq "man") {
      ($a,$out,$b)=@{&executeCommand($out,"nroff","-man","-")};
    }
  } else {
    ($a,$out,$b)=@{&executeCommand("","pod2text","$0")};
  }
  if ($option eq "usage") {
    $out =~ s/OPTIONS.*$//s;
  }
  if ($option ne "man") {
    print $out;
  } else {
    open FILE,"|pager";
    print FILE $out;
    close FILE;
  }
  &finish(0);
}

# Command execution with stderr filtering
sub REAPER {
  my $child;
  while (($child = waitpid(-1, WNOHANG)) > 0) {
    $execContext->{'statusCommand'}->{$child} = $?;
    delete $execContext->{'children'}->{$child};
  }
  $SIG{CHLD} = \&REAPER;        # still loathe SysV
}
sub setupCommand {
  &out(1,'init','Initialize harness for command executions');
  select(STDERR); $| = 1;
  select(STDOUT); $| = 1;
  $execContext={
                'status' => {},
                'children' => {},
                'partiallyDone' => [],
               };
  $SIG{CHLD} = \&REAPER;
  $SIG{INT} = sub {
    foreach my $pid (keys %{$execContext->{'children'}}) {
      kill 2,$pid;
    }
  }
}
sub errorCommand {
  my $lines=$_[0];
  foreach my $line (split /\n/m,$lines) {
    chomp $line;
    if ($line =~ $outContext->{'specialprefix'}) {
      my $part=$1;
      &out(3,'display',$part);
      if ($part =~ /^failed:/ or $part =~ /^count:/) {
        1;
      } else {
        push $execContext->{'partiallydone'},$part;
      }
    } else {
      &out(1,'err',$line);
    }
  }
}
sub execCommand {
  my $line;
  &out(1,"exec",@_);
  my $out = gensym;
  my $err = gensym;
  my $pid = open3("<&STDIN",$out, $err, @_);
  if ($pid) {
    $execContext->{'children'}->{$pid}=1;
    my $sel= new IO::Select;
    $sel->add($err,$out);
    while (scalar keys %{$execContext->{'children'}} > 0) {
      foreach my $readhandle ($sel->can_read(.5)) {
        my $length=sysread $readhandle,$line,4096;
        if ($length) {
          if (fileno($readhandle)==fileno($err)) {
            &errorCommand($line);
          } else {
            chomp $line;
            &out(1,'out',$line);
          }
        }
      }
    }
  }
  my $status=0+$execContext->{'status'}->{$pid};
  delete $execContext->{'status'}->{$pid};
  &out(1,"exec","Command finished with status $status");
  return $status;
}
sub executeCommand {
  # a much simpler version for the manual page
  my $in=shift @_;
  &out(1,"exec",join(' ',@_));
  my $outputtext="";
  my $errtext="";
  my $pid=open3(\*INPUT, \*OUTPUT, \*ERR,@_);
  print INPUT $in if $in;
  close(INPUT);
  my $done=0;
  do {
    while (<OUTPUT>) {
      $outputtext.=$_;
    }
    while (<ERR>) {
      $errtext.=$_;
    }
    $done=waitpid($pid,WNOHANG);
  } until ($done>0);
  return [ $?, $outputtext, $errtext ];
}

# Disk Input/Output
sub fingerprint {
  my ($f)=@_;
  my $hash="0";
  return "0" unless (-e $f);
  return "0" if (-d $f);       # TODO: recursive version for directories
  open FILE,"$f" or return "$f:0";
  my $hashing = Digest::MD5->new;
  $hashing->addfile(*FILE);
  $hash=$hashing->hexdigest;
  close FILE;
  return $hash;
}
sub fingerprintArray {
  # example: $rule, 'in'
  my @a=@{$_[0]->{$_[1]}};
  return 'none' unless (scalar @a);
  my $hashing = Digest::MD5->new;
  my $fp;
  foreach my $file (@a) {
    $fp=&fingerprint($file);
    $hashing->add($file.$fp);
  }
  return $hashing->hexdigest;
}

sub encodeGoalLine {
  join("",
       map { ($_ > 127 || $_ < 32 || $_ == 37 )?
               sprintf("%%(%d)", $_) :
                 chr($_)
               } unpack("W*", &decode_utf8($_[0]))); # unpack Unicode characters
}
sub decodeGoalLine {
  my $a=$_[0];
  $a =~ s/%\(([0-9]+)\)/chr($1)/eg;
  return $a;
}

sub writeCache {
  my ($cacheHash,$path)=@_;
  &out(3,'init',"Storing $path cache");
  my $cachehandle;
  open STDIN,"/dev/null" unless fileno(STDIN);
  make_path('.tmp');
  open $cachehandle,'>',".tmp/$path" or &finish(1,"I cannot open my $path cache!");
  print $cachehandle $outContext->{'json'}->encode($cacheHash);
  $cachehandle->sync();
  close $cachehandle;
}
sub readCache {
  my ($cacheHash,$path)=@_;
  &out(1,'init',"Reading $path cache");
  local $/;
  open (my $fh,'<',".tmp/$path") or return;
  my $json=<$fh>;
  my $cache=decode_json($json);
  foreach (keys %{$cache}) {
    $cacheHash->{$_}=$cache->{$_};
  }
}

sub forceUnlink {
  my $_=shift @_;
  unlink $_;                    # TODO: this may be a directory
}
sub removeGenerated {
  my ($cacheHash,$path,$axioms)=@_;
  my $count=0;
  if (defined($axioms)) {
    &out(1,'display','Removing old files');
  } else {
    &out(1,'init','Cleaning old files cache');
  }
  # If $axioms not defined, just test presence
  # Else, unlink all files not in $axioms hash
  foreach my $key (keys %{$cacheHash}) {
    if (-f $key) {
      if (defined($axioms) and !defined($axioms->{$key})) {
        # clean or distclean
        $count++;
        &forceUnlink($key);
        delete $cacheHash->{$key};
      }
    } else {
      delete $cacheHash->{$key};
    }
  }
  &writeCache($cacheHash,$path);
  if (defined($axioms)) {
    &out(3,'display',"Removed $count old files");
  }
}

sub readAxiomsFromGit {
  open READ,"git ls-files -z|";
  my $a=<READ>;
  close READ;
  my @b=sort map {decode_utf8($_)} split("\x{00}",$a);
  &out(1,'init',"Reading axioms from git");
  &out(2,'init',\@b);
  my $hash={};
  foreach my $k (@b) {
    $hash->{$k}=1;
  }
  return $hash;
}
sub readRules {
  local $/;
  open (my $fh,'<',$rulefile);
  my $json=<$fh>;
  my $rules=decode_json($json);
  foreach my $rulename (keys %$rules) {
    my $rule=$rules->{$rulename};
    $rule->{'in'}=[] unless (defined($rule->{'in'}));
    $rule->{'arg'}=[] unless (defined($rule->{'arg'}));
  }
  $rules->{'AXIOM'}={'type' => 'axiom',
                     'actor' => 'AXIOM',
                     'class' => 'Checking axioms'};
  $planContext->{'pristineRules'}=$rules;
  &out(1,'init',"Read rules");
}
sub readFileList {
  my ($path,$mandatory)=@_;
  my $hash={};
  if (open FILE,'<:encoding(utf8)',$path) {
    my $line;
    while ($line=<FILE>) {
      chomp $line;
      my $g=&decodeGoalLine($line);
      $hash->{$g}++;
    }
    close FILE;
  } else {
    &out(1,'err',"Could not open $path") if $mandatory;
  }
  return $hash;
}

# Planning

sub actionKey {
  my $rule=shift @_;
  return $rule->{'key'} if (defined($rule->{'key'}));
  if (defined($rule->{'arg'}) and scalar @{$rule->{'arg'}} > 0) {
    $rule->{'key'}=join(' ',$rule->{'actor'},map {&encodeGoalLine($_)} @{$rule->{'arg'}});
  } else {
    $rule->{'key'}=$rule->{'actor'};
  }
  return $rule->{'key'};
}
sub recordGeneration {
  my $rule=shift @_;
  my $key=&actionKey($rule);
  my $gen=$rule->{'gen'};
  &out(2,'plan',"Rule $key is complete at generation $gen");
  $planContext->{'plan'}->{$key}=$rule;
  foreach my $outfile (keys %{$rule->{'out'}}) {
    $planContext->{'generated'}->{$outfile}=$key;
    $planContext->{'generatedgen'}->{$outfile}=$gen;
  }
}
sub recordAxioms {
  foreach my $axiom (keys %{$_[0]}) {
    my $axiomRule=&clone($planContext->{'pristineRules'}->{'AXIOM'});
    $axiomRule->{'type'}='simple';
    $axiomRule->{'out'}={$axiom => 1};
    $axiomRule->{'in'}={};
    $axiomRule->{'wanted'}={};
    $axiomRule->{'arg'}=[$axiom];
    $axiomRule->{'gen'}=0;
    &recordGeneration($axiomRule);
  }
}
sub sortRules {
  my $prule=$planContext->{'pristineRules'};
  foreach my $rulename (keys %$prule) {
    if ($prule->{$rulename}->{'type'} eq 'simple') {
      my $rule=&cleanRule(&clone($prule->{$rulename}));
      $planContext->{'simpleRules'}->{&actionKey($rule)}=$rule;
      $planContext->{'usedRules'}->{$rulename}=1;
    } elsif ($prule->{$rulename}->{'type'} eq 'pattern') {
      push $planContext->{'patternRules'},$rulename;
    }
  }
}

sub cleanRule {
  my ($rule,@list)=@_;
  my $list=scalar @list;
  my $in={};
  my $out={};
  foreach my $file (@{$rule->{'in'}}) {
    foreach my $counter (1..$list) {
      $file =~ s/\$$counter/$list[$counter-1]/ge;
    }
    $in->{$file}=1;
  }
  if (defined($rule->{'infile'})) {
    my $hash=[];
    foreach my $file (@{$rule->{'infile'}}) {
      foreach my $counter (1..$list) {
        $file =~ s/\$$counter/$list[$counter-1]/ge;
      }
      &out(2,'plan',"Expanding infile $file");
      push $hash,readFileList($file);
    }
    $in=&addHash($in,@$hash);
  }
  foreach my $file (@{$rule->{'out'}}) {
    foreach my $counter (1..$list) {
      $file =~ s/\$$counter/$list[$counter-1]/ge;
    }
    $out->{$file}=1;
  }
  if (defined($rule->{'outfile'})) {
    my $hash=[];
    foreach my $file (@{$rule->{'outfile'}}) {
      foreach my $counter (1..$list) {
        $file =~ s/\$$counter/$list[$counter-1]/ge;
      }
      &out(2,'plan',"Expanding outfile $file");
      push $hash,readFileList($file);
    }
    $out=&addHash($out,@$hash);
  }
  # Do something
  $rule->{'in'}=$in;
  $rule->{'out'}=$out;
  $rule->{'wanted'}=&clone($in);
  return $rule;
}

sub developPatterns {
  my ($gen,$theorems)=@_;
  foreach my $rulename (@{$planContext->{'patternRules'}}) {
    my $rule=$planContext->{'pristineRules'}->{$rulename};
    my $pattern=$rule->{'pattern'};
    my $patternRE=qr/$pattern/;
    foreach my $theorem (keys %$theorems) {
      my @list = ($theorem =~ $patternRE);
      next unless @list;
      my $arg=$rule->{'argument'};
      foreach my $counter (1..scalar @list) {
        $arg =~ s/\$$counter/$list[$counter-1]/ge;
      }
      if (defined($rule->{'allowedargs'})) {
        my $ok=0;
        foreach my $allow (@{$rule->{'allowedargs'}}) {
          if ($allow eq $arg) {
            $ok=1;last;
          }
        }
        next unless $ok;
      }
      $rule->{'arg'}=[$arg];
      &out(1,'dev',"Developping pattern $rulename with $theorem: $arg");
      my $newrule=&cleanRule(&clone($rule),@list);
      &out(1,'dev',$newrule);
      foreach my $wanted (keys %{$newrule->{'wanted'}}) {
        if (exists($planContext->{'generatedgen'}->{$wanted}) and
            $planContext->{'generatedgen'}->{$wanted} < $gen) {
          delete $planContext->{'generatedgen'}->{$wanted};
        }
      }
      $planContext->{'simpleRules'}->{&actionKey($rule)}=$newrule;
      $planContext->{'usedRules'}->{$rulename}++;
    }
  }
}

sub resolveSimpleRules {
  my $newtheorems={};
  my ($gen,$theorems)=@_;
  foreach my $key (keys %{$planContext->{'simpleRules'}}) {
    my $rule=$planContext->{'simpleRules'}->{$key};
    $rule->{'wanted'}=&subHash($rule->{'wanted'},$theorems);
    next if (scalar keys $rule->{'wanted'});
    # we found everyone!
    $rule->{'gen'}=$gen;
    &recordGeneration($rule);
    foreach my $out (keys %{$rule->{'out'}}) {
      $newtheorems->{$out}=1;
    }
    delete($planContext->{'simpleRules'}->{$key});
  }
  return $newtheorems;
}


sub preparePlan {
  &out(1,'plan','Initializing plan');
  my ($axioms)=@_;              # include list of lazy here
  $planContext->{'generated'}={};
  $planContext->{'plan'}={};
  $planContext->{'simpleRules'}={};
  $planContext->{'patternRules'}=[];
  $planContext->{'usedRules'}={};
  &out(2,'plan','Recording axioms');
  &recordAxioms($axioms);
  my $theorems=$axioms;
  my $gen=1;
  &out(3,'plan','Sorting rules');
  &sortRules();
  while (scalar keys %$theorems) {
    &out(2,'plan',"Building theorems (generation $gen), still ".
         (scalar keys %{$planContext->{'simpleRules'}}).' rules to go');
    &developPatterns($gen,$theorems);
    &out(1,'dev',$planContext->{'simpleRules'});
    $theorems=&resolveSimpleRules($gen,$theorems);
    &out(3,'plan','Found '.(scalar keys %$theorems).' new theorems');
  }
  die "";
}

# # Planning
# my %axioms=();
# my %finals=();
# my @theorems=();
# my %generation=();
# my $trigger=[];
# my %bottomupseen=();
# my %rules=();
# my %fingerprintCache=();
# my %generatedCache=();
# my $result=[];



# sub readAxioms() {
#   my $axiomtype=shift @_;
#   my $axiomdir=shift @_;
#   my $axioms=shift @_;
#   &out(1,"init","Reading $axiomtype from $axiomdir");
#   opendir(my $dh, $axiomdir) || return;
#   while (readdir $dh) {
#     next if /^[.]/;
#     my $axiomfile=$axiomdir."/".$_;
#     open FILE,$axiomfile;
#     while (my $line=<FILE>) {
#       chomp $line;
#       next if $line=~/^#/;
#       $axioms->{uri_unescape($line)}=1;
#     }
#     close FILE;
#   }
#   closedir $dh;
# }

# sub shallowCopy() {
#   my $a=[];
#   foreach my $b (@{$_[0]}) {
#     push $a,$b;
#   }
#   return $a;
# }

# sub shallowCopyRule() {
#   my ($oldrule,$rule)=@_;
#   foreach my $k (keys %$oldrule) {
#     if (ref($k) ne 'ARRAY') {
#       $rule->{$k}=$oldrule->{$k};
#     } else {
#       $rule->{$k}=[@{$oldrule->{$k}}];
#     }
#   }
#   $rule->{'arg'}=[] if (!defined($rule->{'arg'}));
#   $rule->{'class'}='' if (!defined($rule->{'class'}));
#   $rule->{'subclass'}='' if (!defined($rule->{'subclass'}));
# }

# sub recordGeneration() {
#   # Shallow cloning (2 levels is enough)
#   my $oldrule=$_[0];
#   foreach my $thm (@{$oldrule->{'out'}}) {
#     my $rule={};
#     &shallowCopyRule($oldrule,$rule);
#     &finish(1,"Regenerated $thm in generation ".$oldrule->{'gen'}) if (exists $generation{$thm});
#     $generation{$thm}=$rule;
#   }
# }

# sub listEqual() {
#   # Compares two arrays of strings
#   my ($a,$b)=@_;
#   return 0 unless (scalar @$a == scalar @$b);
#   foreach my $i (0..scalar @$a-1) {
#     return 0 if $a->[$i] ne $b->[$i];
#   }
#   return 1;
# }

# sub nextGeneration() {
#   my ($gen,$previousthm) = @_;
#   &out(3,"plan","Building list of buildable files, generation $gen");
#   my @current=@$previousthm;
#   my $found=[];
#   foreach my $rule (@{$outContext->{'simpleRules'}}) {
#     my $key=&actionKey($rule);
#     next if (exists($bottomupseen{$key}));
#     my $allfound=1;
#     if (defined($rule->{'infile'})) {
#       foreach my $infile (@{$rule->{'infile'}}) {
#         if (open FILE,$infile) {
#           foreach (<FILE>) {
#             chomp;
#             push $rule->{'in'},$_;
#           }
#           close FILE;
#         }
#       }
#       $rule->{'oldinfile'} = $rule->{'infile'};
#       delete $rule->{'infile'};
#     }
#     foreach my $requirement (@{$rule->{'in'}}) {
#       if (!exists($generation{$requirement})
#           or $generation{$requirement}->{'gen'} >= $gen) {
#         $allfound=0;last;
#       }
#     }
#     if ($allfound) {
#       $rules{$rule->{"actor"}}->{'seen'}=1;
#       $bottomupseen{$key}=1;
#       $rule->{'gen'}=$gen;
#       &recordGeneration($rule);
#       push $found,@{$rule->{'out'}};
#     }
#   }
#   foreach my $rule (@{$outContext->{'patternRules'}}) {
#     my $pattern=$rule->{'pattern'};
#     my $patternRE=qr/$pattern/;
#     foreach my $candidate (@current) {
#       my @list;
#       if (@list = ($candidate =~ $patternRE)) {
#         if (defined($rule->{'allowedargs'})) {
#           my $ok=0;
#           foreach my $allow (@{$rule->{'allowedargs'}}) {
#             if (&listEqual($allow,\@list)) {
#               $ok=1;
#               last;
#             }
#           }
#           next unless $ok;
#         }
#         my @in=();
#         my @out=();
#         foreach my $infile (@{$rule->{'in'}}) {
#           push @in, $infile;
#         }
#         foreach my $outfile (@{$rule->{'out'}}) {
#           push @out, $outfile;
#         }
#         if (defined($rule->{'infile'})) {
#           foreach my $infile (@{$rule->{'infile'}}) {
#             my $inf=''.$infile;
#             foreach my $counter (1..$#list+1) {
#               $inf =~ s/\$$counter/$list[$counter-1]/ge;
#             }
#             if (open FILE,$inf) {
#               foreach (<FILE>) {
#                 chomp;
#                 push @in,$_;
#               }
#               close FILE;
#             }
#           }
#         }
#         my $argument=$rule->{'argument'};
#         my $subclass='';
#         $subclass=$rule->{'subclass'} if (defined($rule->{'subclass'}));
#         foreach my $counter (1..$#list+1) {
#           $argument =~ s/\$$counter/$list[$counter-1]/ge;
#           $subclass =~ s/\$$counter/$list[$counter-1]/ge;
#           foreach (@in,@out) {
#             s/\$$counter/$list[$counter-1]/ge;
#           }
#         }
#         my $newrule={};
#         &shallowCopyRule($rule,$newrule);
#         $newrule->{'arg'}=[$argument];
#         $newrule->{'subclass'}=$subclass;
#         delete $newrule->{'key'};
#         my $key=&actionKey($newrule);
#         next if exists($bottomupseen{$key});
#         $bottomupseen{$key}=1;
#         $newrule->{'in'}=[@in];
#         $newrule->{'wanted'}=[@in];
#         $newrule->{'out'}=[@out];
#         push $trigger,$newrule;
#       }
#     }
#   }
#   my $delayednumber=0;
#   my $triggercopy=&shallowCopy($trigger);
#   foreach my $delayed (@$triggercopy) {
#     my @wanted=@{$delayed->{'wanted'}};
#     my $i=0;
#     my $wantedcopy=&shallowCopy(\@wanted);
#     foreach my $wanted (@$wantedcopy) {
#       if (exists($generation{$wanted}) and $generation{$wanted}->{'gen'}<$gen) {
#         splice $delayed->{'wanted'},$i,1;
#         $i--;
#       }
#       $i++;
#     }
#     @wanted=@{$delayed->{'wanted'}};
#     if (scalar @wanted == 0) {
#       $delayed->{'gen'}=$gen;
#       &recordGeneration($delayed);
#       push $found,@{$delayed->{'out'}};
#       splice $trigger,$delayednumber,1;
#       $delayednumber--;
#     }
#     $delayednumber++;
#   }
#   return $found;
# }

# sub bottomUp {
#   my @axioms=sort keys %axioms;
#   my $currentgen=\@axioms;
#   my $generation=1;
#   my $newlength=scalar @axioms;
#   &out(2,"plan","Building list of buildable files");
#   while ($newlength) {
#     $currentgen=&nextGeneration($generation,$currentgen);
#     $newlength=scalar @{$currentgen};
#     $generation++;
#   }
#   foreach my $actor (keys %rules) {
#     if (!defined($rules{$actor}->{'seen'})
#         and $rules{$actor}->{'type'} eq 'simple') {
#       &out(2,'plan',"The rule $actor was not used at all");
#       &out(3,'plan',Dumper($rules{$actor}));
#     }
#   }
# }

# sub topDown {
#   # Now, collect only the goals
#   &out(2,"plan","Isolating goals paths from $target");
#   my %topdownseen=();
#   my $mygoals=$goals;
#   my %idontknow=();
#   my %ineed=();

#   if ($target eq 'all') {
#     push $mygoals,keys %generation;
#   } elsif ($target eq 'finals') {
#     push $mygoals,keys %finals;
#   }

#   &out(4,"plan","Final list of goals established: ".join(' ',@$mygoals));
#   while (scalar @$mygoals) {
#     my $goal=pop $mygoals;
#     do {
#       $idontknow{$goal}=1;next;
#     } unless (exists($generation{$goal}));
#     my $key=&actionKey($generation{$goal});
#     next if exists($topdownseen{$key});
#     $topdownseen{$key}=1;
#     $ineed{$key}=$generation{$goal};
#     push $mygoals,@{$generation{$goal}->{'in'}};
#   }
#   if (scalar keys %idontknow) {
#     print "I do not know how to build the following goals:\n";
#     print join("\n",sort keys %idontknow),"\n";
#     &finish(1,"Stopping");
#   }
#   my @result=sort {
#     ($a->{'gen'} <=> $b->{'gen'}) || ($a->{'class'} cmp $b->{'class'}) || ($a->{'subclass'} cmp $b->{'subclass'}) || ($a->{'actor'} cmp $b->{'actor'}) || (join(' ',$a->{'arg'}) cmp join(' ',$b->{'arg'}))
#   } values %ineed;
#   return \@result;
# }

# sub firstCompound {
#   my ($plan,$begin) = @_;
#   my $newplan=[];
#   return undef unless (scalar @$plan);
#   my $end=$begin+1;
#   my $maxend;
#   my $axiom=$plan->[$begin]->{'actor'};
#   if (defined($rules{$axiom}->{'maxargs'})) {
#     $maxend=$begin+$rules{$axiom}->{'maxargs'};
#   } else {
#     $maxend=$begin+100000000;
#   }
#   while (
#          $end < scalar @$plan and
#          $end < $maxend and
#          $plan->[$end]->{'gen'} == $plan->[$begin]->{'gen'} and
#          $plan->[$end]->{'actor'} eq $plan->[$begin]->{'actor'}
#         ) {
#     $end++;
#   }
#   my $candidates=[];
#   # weed out already done candidates
#   foreach my $i ($begin..$end-1) {
#     my $key=&actionKey($plan->[$i]);
#     my $fingerprintIn=&fingerprintArray($plan->[$i],'in');
#     $plan->[$i]->{'fingerprintIn'}=$fingerprintIn;
#     my $fingerprintOut=&fingerprintArray($plan->[$i],'out');
#     if ((defined($fingerprintCache{$key})
#          and $fingerprintCache{$key} eq "$fingerprintIn $fingerprintOut")
#        ) {
#       &out(3,"plan","Not considering $key");
#       next;
#     } elsif (!defined($fingerprintCache{$key})) {
#       &out(2,"plan","Considering $key (never seen)");
#     } else {
#       &out(2,"plan","Considering $key (input or output changed)");
#     }
#     push $candidates,$i;
#   }
#   # TODO
#   my $compoundRule={};
#   &shallowCopyRule($plan->[$begin],$compoundRule);
#   delete $compoundRule->{'key'};
#   $compoundRule->{'arg'}=[];
#   my $individualRules=[];
#   my $newargs=$compoundRule->{'arg'};
#   my $newin={};
#   my $newout={};

#   foreach my $i (@$candidates) {
#     push $newargs,@{$plan->[$i]->{'arg'}};
#     push $individualRules,$plan->[$i];
#     foreach my $j (@{$plan->[$i]->{'in'}}) {
#       $newin->{$j}=1;
#     }
#     foreach my $j (@{$plan->[$i]->{'out'}}) {
#       $newout->{$j}=1;
#     }
#   }
#   my @newin=sort keys $newin;
#   my @newout=sort keys $newout;
#   $compoundRule->{'in'}=\@newin;
#   $compoundRule->{'out'}=\@newout;
#   return ($compoundRule,$candidates,$end);
# }

# sub registerSuccess() {
#   my ($candidate,$plan)=@_;
#   my $rule=$plan->[$candidate];
#   my $fingerprintOut=&fingerprintArray($rule,'out');
#   my $fingerprintIn=$rule->{'fingerprintIn'};
#   my $key=&actionKey($rule);
#   &out(4,"plan","Registering success of $key");
#   $fingerprintCache{$key}="$fingerprintIn $fingerprintOut";
# }

# sub attempt() {
#   my $todo=$_[0];
#   my @candidateRules=@{$_[1]};
#   @partiallydone=();
#   my @execLine=($todo->{'actor'});
#   push @execLine,@{$todo->{'arg'}} if (scalar @{$todo->{'arg'}});
#   my $line=join(' ',@execLine);
#   my $success=substr $line,0,72;
#   $success.="..." if ($success ne $line);
#   $execLine[0]=$actordir.'/'.$todo->{'actor'};
#   if ($todo->{'class'} ne '') {
#     &out(1,'display',$todo->{'class'});
#     if ($todo->{'subclass'} ne '') {
#       &out(2,'display',$todo->{'subclass'});
#     }
#   } else {
#     &out(1,'display',$success);
#   }
#   my @tab=();
#   push @tab,@{$todo->{'out'}} if defined($todo->{'out'});
#   push @tab,@{$todo->{'junk'}} if defined($todo->{'junk'});
#   foreach my $file (@tab) {
#     $generatedCache{$file}=1;
#   }
#   &writeCache(\%generatedCache,'generated');
#   my $status=&execCommand(@execLine);
#   if ($status) {
#     foreach my $ok (@partiallydone) {
#       my $protectedok=uri_escape($ok); # TODO: Really use actionKeys here, not filenames
#       foreach my $i (@candidateRules) {
#         my $rule=$result->[$i];
#         if (defined $rule->{'arg'}
#             and scalar @{$rule->{'arg'}} == 1
#             and $rule->{'arg'}->[0] eq $protectedok) {
#           &registerSuccess($i,$result);
#           last;
#         }
#       }
#     }
#     &writeCache(\%fingerprintCache,'fingerprint');
#     &finish(1,"One rule failed with status $status") if ($status);
#   }
#   # register success of everybody
#   &out(3,"plan","Everything was successful");
#   foreach my $i (@candidateRules) {
#     &registerSuccess($i,$result);
#   }
#   &writeCache(\%fingerprintCache,'fingerprint');
# }

# &findGitTopdir();

# &readAxioms("axioms",$axiomdir,\%axioms);
# &readAxioms("finals",$finaldir,\%finals);
# &readCache(\%fingerprintCache,'fingerprint');

# &readCache(\%generatedCache,'generated');
# &removeGenerated(\%generatedCache,'generated',undef);

# if ($mode eq "distclean" or $mode eq "clean") {
#   my %protected=();
#   foreach my $i (keys %axioms) {
#     $protected{$i}=1;
#   }
#   if ($mode eq "clean") {
#     foreach my $i (keys %finals) {
#       $protected{$i}=1;
#     }
#   }
#   &removeGenerated(\%generatedCache,'generated',\%protected);
#   &finish(0);
# }

# &readRules();
# &out(3,"plan","Recording axioms");
# foreach my $axiom (sort keys %axioms) {
#   my $axiomrule={};
#   &shallowCopyRule($rules{'AXIOM'},$axiomrule);
#   $axiomrule->{'gen'}=0;
#   $axiomrule->{'in'}=[] if ($axiom eq $actordir.'/AXIOM');
#   $axiomrule->{'arg'}=[$axiom];
#   $axiomrule->{'out'}=[$axiom];
#   &recordGeneration($axiomrule);
# }
# &bottomUp();
# $result=&topDown();

# my $todo;
# my $todoIndividuals;
# my $begin=0;
# my $end=0;

# my $done=0;
# while ($end < scalar @$result) {
#   ($todo,$todoIndividuals,$end)=&firstCompound($result,$begin);
#   $begin=$end;
#   next if ((scalar @{$todoIndividuals}) == 0);
#   $done++;
#   &attempt($todo,$todoIndividuals);
# }

# if ($done==0) {
#   &out(1,"display","Everything is up to date");
# }
# &newline();
# &finish(0);

=pod

=head1 PRINCIPLE

TODO

=head1 RULES

TODO

=head1 EXPLAINING

The B<--why> and B<--how> specifiers will disable file generation and
explain by a simple graph which file is output starting from the
specified goals (B<--why>) or an input from the specified goals
(B<--how>). The graph is in I<graphviz> format.

=head1 GOALS AND TARGETS

The various goals files are filenames with one name per line. The names
may be escaped by using the %(hexadecimal) notation (you will most
probably never encounter that).

Targets are predefined list of goals that can be used instead of
specifying individual goals. The target names are usually sufficient to
use them as goals.

There is one default target: the I<all> target is the list of all
buildable files.

If no goals are given, then the target I<finals> will be used by default
(even if it is not defined).

=head1 FILES

=over

=item * C<plan/targets/I<target>> a list of goals aliased as a target

=item * C<plan/lazy> a list of goals stored in git but not axioms

=item * C<plan/axioms> a list of goals not stored in git but considered as axioms

Beware that if plan/axioms is not empty, your project may be buildable
locally, but fail from the repository.

=item * C<plan/in/I<name>> a good place to put files read by "infile" directives.

=item * C<plan/out/I<name>> a good place to put files read by "outfile" directives.

=item * C<plan/actors/I<ACTOR>> a short script that executes the rule named
I<ACTOR> and receives the various arguments as $1, $2, etc.

=item * C<plan/rules> a JSON encoded file containing the rules.

=back

=head1 AUTHOR

Copyright Jean-Christophe Dubacq 2013

=head1 COPYING

This work is licensed under the BSD licence. It is explicitly stated
here that the license does not extend to the data managed by the
program, in case anyone had doubts.

=cut
