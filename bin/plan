#!/usr/bin/perl

# Idea: allow for lazy axioms in plan/lazy
## These axioms would not be considered if option --hard is given
## Overwriting these axioms is not considered an error.
## A rule overwriting only these axioms must be ignored.
## Example: generating .pfb .afm from .sfd files
# Idea: manage inside files (both written and read in one actor)
# Idea: pseudo-target sweep to remove unmakeable non-axiom files

use strict;
use warnings;
use JSON::PP;
use Data::Dumper;
use URI::Escape;
use Digest::MD5;
use Symbol 'gensym';
use File::Path qw(make_path);
use Cwd;
use Term::ANSIColor;

my %verbosity=('exec'=>0,
               'init'=>0,
               'plan'=>0,
               'out'=>1,
               'err'=>1,
               'display'=>3);
my $color=1;
$color=0 unless -t STDOUT;
my $trace=1;
# Logging

my $class='';
my $oldclass='';
my $subclass='';
my $oldsubclass='';
my $currentcol=0;
sub finish {
  my $status=shift @_;
  &newline();
  if ($status == 1) {
    die @_;
  }
  exit($status);
}
sub newline {
  print "\n" if ($currentcol);
  $currentcol=0;
}
sub class {
  $oldclass=$class;
  $class=$_[0];
  if ($class ne $oldclass) {
    &newline();
    $subclass='';
    print color 'bold' if ($color);
    print $class,"\n";
    print color 'reset' if ($color);
  }
}
sub subclass {
  $oldsubclass=$subclass;
  $subclass=$_[0];
  if ($subclass ne $oldsubclass) {
    print color 'bold' if ($color);
    &out(3,'display',$subclass);
    print color 'reset' if ($color);
  }
}

sub out {
  my $v=shift @_;
  my $n=shift @_;
  if ($verbosity{$n}>=$v) {
    if ($n eq "display") {
      if ($v==1) {
        &class(@_);
      } elsif ($v==2) {
        &subclass(@_);
      } else {
        my $str=join('',@_);
        my $len=length($str);
        if ($currentcol+2+$len>80) {
          &newline();
        }
        if ($currentcol==0) {
          print "    ";
          $currentcol=4;
        }
        print '[',$str,']';
        $currentcol+=2+$len;
      }
    } elsif ($n eq "out") {
      &newline();
      print color 'blue' if ($color);
      print "      ",@_,"\n";
      print color 'reset' if ($color);
    } elsif ($n eq 'err') {
      &newline();
      print color 'red' if ($color);
      print @_,"\n";
      print color 'reset' if ($color);
    } else {
      &newline();
      print $n,':',@_,"\n";
    }
  }
}

# ARGV

sub parseARGV {
  my $goals=[];
  my $mode="goal";
  my $target="finals";
  my %target=('all'=>1,'finals'=>1);
  my $x=0;
  while ($x < scalar @ARGV) {
    my $arg=$ARGV[$x];
    if ($arg eq '--verbosity') {
      &finish(1,"Wrong option: --verbosity must be followed by two arguments") unless defined($ARGV[$x+2]);
      my $cat=$ARGV[$x+1];
      my $level=$ARGV[$x+2];
      $x+=2;
      &finish(1,"Wrong option: --verbosity must be followed by either ".join(' or ',keys %verbosity)) unless defined($verbosity{$cat});
      &finish(1,"Wrong option: --verbosity must be followed by a category and an integer") unless $level =~ /^[0-9]+$/;
      $verbosity{$cat}=$level;
    } elsif ($arg eq 'clean' or $arg eq '--clean') {
      $mode="clean";
    } elsif ($arg eq 'distclean' or $arg eq '--distclean') {
      $mode="distclean";
    } elsif (defined($target{$arg}) or $arg eq '--target') {
      if ($arg eq '--target') {
        $x++;
        $arg=$ARGV[$x];
      }
      $target=$arg;
    } elsif ($arg eq '--') {
      $x++;
      while ($x < scalar @ARGV) {
        push $goals,$ARGV[$x];
        $x++;
      }
    } else {
      push $goals,$arg;
    }
    $x++;
  }
  return ($goals,$target,$mode);
}

my ($goals,$target,$mode)=&parseARGV();
&out(1,"init","Parsing ARGV done");

my %implemented=('goal' => 1,'distclean' => 1, 'clean' => 1);
finish(1,"$mode is not implemented yet") unless defined($implemented{$mode});

# Command execution with stderr filtering

use IPC::Open3;
use POSIX ":sys_wait_h";
use IO::Select;
use IO::Handle;
my %statusCommand=();
my %childCommand=();
select(STDERR); $| = 1;
select(STDOUT); $| = 1;

sub REAPER {
  my $child;
  while (($child = waitpid(-1, WNOHANG)) > 0) {
    $statusCommand{$child} = $?;
    delete $childCommand{$child};
  }
  $SIG{CHLD} = \&REAPER;        # still loathe SysV
}
sub setupCommand {
  $SIG{CHLD} = \&REAPER;
  $SIG{INT} = sub {
    foreach my $pid (keys %childCommand) {
      kill 2,$pid;
    }
  };
}

my $specialprefix=qr/^PARTIAL PLAN:(.*)$/;
$ENV{'SPECIALPREFIX'}="PARTIAL PLAN:";
my @partiallydone=();

sub errorCommand {
  my $line=$_[0];
  chomp $line;
  if ($line =~ $specialprefix) {
    my $part=$1;
    &out(3,'display',$part);
    if ($part =~ /^failed:/) {
    } else {
      push @partiallydone,$part;
    }
  } else {
    &out(1,'err',$line);
  }
}

sub execCommand {
  my $line;
  &out(1,"exec",@_);
  my $out = gensym;
  my $err = gensym;
  my $pid = open3("<&STDIN",$out, $err, @_);
  if ($pid) {
    $childCommand{$pid}=1;
    my $sel= new IO::Select;
    $sel->add($err,$out);
    while (scalar keys %childCommand > 0) {
      foreach my $readhandle ($sel->can_read(.5)) {
        my $length=sysread $readhandle,$line,4096;
        if ($length) {
          if (fileno($readhandle)==fileno($err)) {
            &errorCommand($line);
          } else {
            chomp $line;
            &out(1,'out',$line);
          }
        }
      }
    }
  }
  my $status=0+$statusCommand{$pid};
  delete $statusCommand{$pid};
  &out(1,"exec","Command finished with status $status");
  return $status;
}

&out(1,'init','Initialize harness for command executions');
&setupCommand;

my $axiomdir='plan/axioms';
my $finaldir='plan/finals';
my $rulefile='plan/rules';

my %axioms=();
my %finals=();
my @theorems=();
my %generation=();
my @rules;
my $trigger=[];
my %bottomupseen=();
my %rules=();
my %fingerprintCache=();
my %generatedCache=();
my $result=[];

sub fingerprint() {
  my ($f)=@_;
  my $hash="0";
  return "0" if (-d $f);
  return "0" unless (-e $f);
  open FILE,"$f" or return "$f:0";
  my $hashing = Digest::MD5->new;
  $hashing->addfile(*FILE);
  $hash=$hashing->hexdigest;
  close FILE;
  return $hash;
}

sub fingerprintArray() {
  # example: $rule, 'in'
  my @a=@{$_[0]->{$_[1]}};
  return 'none' unless (scalar @a);
  my $hashing = Digest::MD5->new;
  my $fp;
  foreach my $file (@a) {
    $fp=&fingerprint($file);
    $hashing->add($file.$fp);
  }
  return $hashing->hexdigest;
}

sub findGitTopdir {
  my $oldcwd='';
  my $cwd=getcwd();
  while ($oldcwd ne $cwd and !opendir(GITDIR,".git")) {
    chdir('..');
    $cwd=getcwd();
  }
  &finish(1,"Could not find the top-level directory") if $cwd eq $oldcwd;
  closedir(GITDIR);
}

my $jsonEncoder=JSON::PP->new->pretty;
sub writeCache() {
  my ($cacheHash,$path)=@_;
  &out(3,'init',"Storing $path cache");
  my $cachehandle;
  open STDIN,"/dev/null" unless fileno(STDIN);
  make_path('.tmp');
  open $cachehandle,'>',".tmp/$path" or &finish(1,"I cannot open my $path cache!");
  print $cachehandle $jsonEncoder->encode($cacheHash);
  $cachehandle->sync();
  close $cachehandle;
}

sub readCache() {
  my ($cacheHash,$path)=@_;
  &out(1,'init',"Reading $path cache");
  local $/;
  open (my $fh,'<',".tmp/$path") or return;
  my $json=<$fh>;
  my $cache=decode_json($json);
  foreach (keys %{$cache}) {
    $cacheHash->{$_}=$cache->{$_};
  }
}

sub removeGenerated() {
  my ($cacheHash,$path,$axioms)=@_;
  my $count=0;
  if (defined($axioms)) {
    &out(1,'display','Removing old files');
  } else {
    &out(1,'init','Cleaning old files cache');
  }
  # If not defined, just test presence
  # Else, unlink all files not in $axioms hash
  foreach my $key (keys %{$cacheHash}) {
    if (-f $key) {
      if (defined($axioms) and !defined($axioms->{$key})) {
        # clean or distclean
        $count++;
        unlink $key;
        delete $cacheHash->{$key};
      }
    } else {
      delete $cacheHash->{$key};
    }
  }
  &writeCache($cacheHash,$path);
  if (defined($axioms)) {
    &out(3,'display',"Removed $count old files");
  }
}

sub readAxioms() {
  my $axiomtype=shift @_;
  my $axiomdir=shift @_;
  my $axioms=shift @_;
  &out(1,"init","Reading $axiomtype from $axiomdir");
  opendir(my $dh, $axiomdir) || return;
  while (readdir $dh) {
    next if /^[.]/;
    my $axiomfile=$axiomdir."/".$_;
    open FILE,$axiomfile;
    while (my $line=<FILE>) {
      chomp $line;
      next if $line=~/^#/;
      $axioms->{uri_unescape($line)}=1;
    }
    close FILE;
  }
  closedir $dh;
}

sub shallowCopy() {
  my $a=[];
  foreach my $b (@{$_[0]}) {
    push $a,$b;
  }
  return $a;
}

sub readRules() {
  local $/;
  open (my $fh,'<',$rulefile);
  my $json=<$fh>;
  my $rules=decode_json($json);
  @rules=values %{$rules};
  foreach my $rule (@rules) {
    $rule->{'in'}=[] unless (defined($rule->{'in'}));
    push $rule->{'in'},'plan/bin/'.$rule->{'actor'};
    $rules{$rule->{"actor"}}=$rule;
  }
  $rules{'AXIOM'}={'type' => 'simple',
                   'actor' => 'AXIOM',
                   'in'=>['plan/bin/AXIOM'],
                   'class' => 'Checking axioms'};
}

sub shallowCopyRule() {
  my ($oldrule,$rule)=@_;
  foreach my $k (keys %$oldrule) {
    if (ref($k) ne 'ARRAY') {
      $rule->{$k}=$oldrule->{$k};
    } else {
      $rule->{$k}=[@{$oldrule->{$k}}];
    }
  }
  $rule->{'arg'}=[] if (!defined($rule->{'arg'}));
  $rule->{'class'}='' if (!defined($rule->{'class'}));
  $rule->{'subclass'}='' if (!defined($rule->{'subclass'}));
}

sub recordGeneration() {
  # Shallow cloning (2 levels is enough)
  my $oldrule=$_[0];
  foreach my $thm (@{$oldrule->{'out'}}) {
    my $rule={};
    &shallowCopyRule($oldrule,$rule);
    &finish(1,"Regenerated $thm in generation ".$oldrule->{'gen'}) if (exists $generation{$thm});
    $generation{$thm}=$rule;
  }
}

sub actionKey() {
  my $a=shift @_;
  if (defined($a->{'key'})) {
    return $a->{'key'};
  }
  if (defined($a->{'arg'}) and scalar @{$a->{'arg'}} > 0) {
    $a->{'key'}=join(' ',$a->{'actor'},map {&uri_escape($_)} @{$a->{'arg'}});
  } else {
    $a->{'key'}=$a->{'actor'};
  }
  return $a->{'key'};
}

sub nextGeneration() {
  my ($gen,$previousthm) = @_;
  &out(3,"plan","Building list of buildable files, generation $gen");
  my @current=@$previousthm;
  my $found=[];
  foreach my $rule (@rules) {
    if ($rule->{'type'} eq 'simple' ) {
      my $key=&actionKey($rule);
      next if (exists($bottomupseen{$key}));
      my $allfound=1;
      if (defined($rule->{'infile'})) {
        foreach my $infile (@{$rule->{'infile'}}) {
          if (open FILE,$infile) {
            foreach (<FILE>) {
              chomp;
              push $rule->{'in'},$_;
            }
            close FILE;
          }
        }
        $rule->{'oldinfile'} = $rule->{'infile'};
        delete $rule->{'infile'};
      }
      foreach my $requirement (@{$rule->{'in'}}) {
        if (!exists($generation{$requirement})
            or $generation{$requirement}->{'gen'} >= $gen) {
          $allfound=0;last;
        }
      }
      if ($allfound) {
        $rules{$rule->{"actor"}}->{'seen'}=1;
        $bottomupseen{$key}=1;
        $rule->{'gen'}=$gen;
        &recordGeneration($rule);
        push $found,@{$rule->{'out'}};
      }
    } elsif ($rule->{'type'} eq 'pattern' ) {
      my $pattern=$rule->{'pattern'};
      my $patternRE=qr/$pattern/;
      foreach my $candidate (@current) {
        my @list;
        if (@list = ($candidate =~ $patternRE)) {
          my @in=();
          my @out=();
          foreach my $infile (@{$rule->{'in'}}) {
            push @in, $infile;
          }
          foreach my $outfile (@{$rule->{'out'}}) {
            push @out, $outfile;
          }
          if (defined($rule->{'infile'})) {
            foreach my $infile (@{$rule->{'infile'}}) {
              my $inf=''.$infile;
              foreach my $counter (1..$#list+1) {
                $inf =~ s/\$$counter/$list[$counter-1]/ge;
              }
              if (open FILE,$inf) {
                foreach (<FILE>) {
                  chomp;
                  push @in,$_;
                }
                close FILE;
              }
            }
          }
          my $argument=$rule->{'argument'};
          my $subclass='';
          $subclass=$rule->{'subclass'} if (defined($rule->{'subclass'}));
          foreach my $counter (1..$#list+1) {
            $argument =~ s/\$$counter/$list[$counter-1]/ge;
            $subclass =~ s/\$$counter/$list[$counter-1]/ge;
            foreach (@in,@out) {
              s/\$$counter/$list[$counter-1]/ge;
            }
          }
          my $newrule={};
          &shallowCopyRule($rule,$newrule);
          $newrule->{'arg'}=[$argument];
          $newrule->{'subclass'}=$subclass;
          delete $newrule->{'key'};
          my $key=&actionKey($newrule);
          next if exists($bottomupseen{$key});
          $bottomupseen{$key}=1;
          $newrule->{'in'}=[@in];
          $newrule->{'wanted'}=[@in];
          $newrule->{'out'}=[@out];
          push $trigger,$newrule;
        }
      }
    }
  }
  my $delayednumber=0;
  my $triggercopy=&shallowCopy($trigger);
  foreach my $delayed (@$triggercopy) {
    my @wanted=@{$delayed->{'wanted'}};
    my $i=0;
    my $wantedcopy=&shallowCopy(\@wanted);
    foreach my $wanted (@$wantedcopy) {
      if (exists($generation{$wanted}) and $generation{$wanted}->{'gen'}<$gen) {
        splice $delayed->{'wanted'},$i,1;
        $i--;
      }
      $i++;
    }
    @wanted=@{$delayed->{'wanted'}};
    if (scalar @wanted == 0) {
      $delayed->{'gen'}=$gen;
      &recordGeneration($delayed);
      push $found,@{$delayed->{'out'}};
      splice $trigger,$delayednumber,1;
      $delayednumber--;
    }
    $delayednumber++;
  }
  return $found;
}

sub bottomUp {
  my @axioms=sort keys %axioms;
  my $currentgen=\@axioms;
  my $generation=1;
  my $newlength=scalar @axioms;
  &out(2,"plan","Building list of buildable files");
  while ($newlength) {
    $currentgen=&nextGeneration($generation,$currentgen);
    $newlength=scalar @{$currentgen};
    $generation++;
  }
  foreach my $actor (keys %rules) {
    if (!defined($rules{$actor}->{'seen'})
        and $rules{$actor}->{'type'} eq 'simple') {
      &out(2,'plan',"The rule $actor was not used at all");
      &out(3,'plan',Dumper($rules{$actor}));
    }
  }
}

sub topDown {
  # Now, collect only the goals
  &out(2,"plan","Isolating goals paths from $target");
  my %topdownseen=();
  my $mygoals=$goals;
  my %idontknow=();
  my %ineed=();

  if ($target eq 'all') {
    push $mygoals,keys %generation;
  } elsif ($target eq 'finals') {
    push $mygoals,keys %finals;
  }

  &out(4,"plan","Final list of goals established: ".join(' ',@$mygoals));
  while (scalar @$mygoals) {
    my $goal=pop $mygoals;
    do {
      $idontknow{$goal}=1;next;
    } unless (exists($generation{$goal}));
    my $key=&actionKey($generation{$goal});
    next if exists($topdownseen{$key});
    $topdownseen{$key}=1;
    $ineed{$key}=$generation{$goal};
    push $mygoals,@{$generation{$goal}->{'in'}};
  }
  if (scalar keys %idontknow) {
    print "I do not know how to build the following goals:\n";
    print join("\n",sort keys %idontknow),"\n";
    &finish(1,"Stopping");
  }
  my @result=sort {
    ($a->{'gen'} <=> $b->{'gen'}) || ($a->{'class'} cmp $b->{'class'}) || ($a->{'subclass'} cmp $b->{'subclass'}) || ($a->{'actor'} cmp $b->{'actor'}) || (join(' ',$a->{'arg'}) cmp join(' ',$b->{'arg'}))
  } values %ineed;
  return \@result;
}

sub firstCompound {
  my ($plan,$begin) = @_;
  my $newplan=[];
  return undef unless (scalar @$plan);
  my $end=$begin+1;
  my $maxend;
  my $axiom=$plan->[$begin]->{'actor'};
  if (defined($rules{$axiom}->{'maxargs'})) {
    $maxend=$begin+$rules{$axiom}->{'maxargs'};
  } else {
    $maxend=$begin+100000000;
  }
  while (
         $end < scalar @$plan and
         $end < $maxend and
         $plan->[$end]->{'gen'} == $plan->[$begin]->{'gen'} and
         $plan->[$end]->{'actor'} eq $plan->[$begin]->{'actor'}
        ) {
    $end++;
  }
  my $candidates=[];
  # weed out already done candidates
  foreach my $i ($begin..$end-1) {
    my $key=&actionKey($plan->[$i]);
    my $fingerprintIn=&fingerprintArray($plan->[$i],'in');
    $plan->[$i]->{'fingerprintIn'}=$fingerprintIn;
    my $fingerprintOut=&fingerprintArray($plan->[$i],'out');
    if ((defined($fingerprintCache{$key})
         and $fingerprintCache{$key} eq "$fingerprintIn $fingerprintOut")
       ) {
      &out(3,"plan","Not considering $key");
      next;
    } elsif (!defined($fingerprintCache{$key})) {
      &out(2,"plan","Considering $key (never seen)");
    } else {
      &out(2,"plan","Considering $key (input or output changed)");
    }
    push $candidates,$i;
  }
  # TODO
  my $compoundRule={};
  &shallowCopyRule($plan->[$begin],$compoundRule);
  delete $compoundRule->{'key'};
  $compoundRule->{'arg'}=[];
  my $individualRules=[];
  my $newargs=$compoundRule->{'arg'};
  my $newin={};
  my $newout={};

  foreach my $i (@$candidates) {
    push $newargs,@{$plan->[$i]->{'arg'}};
    push $individualRules,$plan->[$i];
    foreach my $j (@{$plan->[$i]->{'in'}}) {
      $newin->{$j}=1;
    }
    foreach my $j (@{$plan->[$i]->{'out'}}) {
      $newout->{$j}=1;
    }
  }
  my @newin=sort keys $newin;
  my @newout=sort keys $newout;
  $compoundRule->{'in'}=\@newin;
  $compoundRule->{'out'}=\@newout;
  return ($compoundRule,$candidates,$end);
}

sub registerSuccess() {
  my ($candidate,$plan)=@_;
  my $rule=$plan->[$candidate];
  my $fingerprintOut=&fingerprintArray($rule,'out');
  my $fingerprintIn=$rule->{'fingerprintIn'};
  my $key=&actionKey($rule);
  &out(4,"plan","Registering success of $key");
  $fingerprintCache{$key}="$fingerprintIn $fingerprintOut";
}

sub attempt() {
  my $todo=$_[0];
  my @candidateRules=@{$_[1]};
  @partiallydone=();
  my @execLine=($todo->{'actor'});
  push @execLine,@{$todo->{'arg'}} if (scalar @{$todo->{'arg'}});
  my $line=join(' ',@execLine);
  my $success=substr $line,0,72;
  $success.="..." if ($success ne $line);
  $execLine[0]='plan/bin/'.$todo->{'actor'};
  if ($todo->{'class'} ne '') {
    &out(1,'display',$todo->{'class'});
    if ($todo->{'subclass'} ne '') {
      &out(2,'display',$todo->{'subclass'});
    }
  } else {
    &out(1,'display',$success);
  }
  my @tab=();
  push @tab,@{$todo->{'out'}} if defined($todo->{'out'});
  push @tab,@{$todo->{'junk'}} if defined($todo->{'junk'});
  foreach my $file (@tab) {
    $generatedCache{$file}=1;
  }
  &writeCache(\%generatedCache,'generated');
  my $status=&execCommand(@execLine);
  if ($status) {
    foreach my $ok (@partiallydone) {
      my $protectedok=uri_escape($ok);
      foreach my $i (@candidateRules) {
        my $rule=$result->[$i];
        if (defined $rule->{'arg'}
            and scalar @{$rule->{'arg'}} == 1
            and $rule->{'arg'}->[0] eq $protectedok) {
          &registerSuccess($i,$result);
          last;
        }
      }
    }
    &writeCache(\%fingerprintCache,'fingerprint');
    &finish(1,"One rule failed with status $status") if ($status);
  }
  # register success of everybody
  &out(3,"plan","Everything was successful");
  foreach my $i (@candidateRules) {
    &registerSuccess($i,$result);
  }
  &writeCache(\%fingerprintCache,'fingerprint');
}

&findGitTopdir();

&readAxioms("axioms",$axiomdir,\%axioms);
&readAxioms("finals",$finaldir,\%finals);
&readCache(\%fingerprintCache,'fingerprint');

&readCache(\%generatedCache,'generated');
&removeGenerated(\%generatedCache,'generated',undef);

if ($mode eq "distclean" or $mode eq "clean") {
  my %protected=();
  foreach my $i (keys %axioms) {
    $protected{$i}=1;
  }
  if ($mode eq "clean") {
    foreach my $i (keys %finals) {
      $protected{$i}=1;
    }
  }
  &removeGenerated(\%generatedCache,'generated',\%protected);
  &finish(0);
}

&readRules();
&out(3,"plan","Recording axioms");
foreach my $axiom (sort keys %axioms) {
  my $axiomrule={};
  &shallowCopyRule($rules{'AXIOM'},$axiomrule);
  $axiomrule->{'gen'}=0;
  $axiomrule->{'in'}=[] if ($axiom eq 'plan/bin/AXIOM');
  $axiomrule->{'arg'}=[$axiom];
  $axiomrule->{'out'}=[$axiom];
  &recordGeneration($axiomrule);
}
&bottomUp();
$result=&topDown();

my $todo;
my $todoIndividuals;
my $begin=0;
my $end=0;

my $done=0;
while ($end < scalar @$result) {
  ($todo,$todoIndividuals,$end)=&firstCompound($result,$begin);
  $begin=$end;
  next if ((scalar @{$todoIndividuals}) == 0);
  $done++;
  &attempt($todo,$todoIndividuals);
}

if ($done==0) {
  &out(1,"display","Everything is up to date");
}
&newline();
&finish(0);
