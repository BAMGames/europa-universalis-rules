#!/usr/bin/perl


use strict;
use warnings;
use JSON::PP;
use Data::Dumper;
use URI::Escape;

my $axiomdir='./plan/axioms';
my $rulefile='./plan/rules';

my @axioms=();
my @theorems=();
my %generation=();
my @rules;
my $trigger=[];
my %bottomupseen=();

sub readAxioms() {
  opendir(my $dh, $axiomdir) || die;
  while (readdir $dh) {
    next if /^[.]/;
    my $axiomfile=$axiomdir."/".$_;
    open FILE,$axiomfile;
    while (my $line=<FILE>) {
      chomp $line;
      next if $line=~/^#/;
      push @axioms,uri_unescape($line);
    }
    close FILE;
  }
  closedir $dh;
}

sub shallowCopy() {
  my $a=[];
  foreach my $b (@{$_[0]}) {
    push $a,$b;
  }
  return $a;
}

sub readRules() {
  local $/;
  open (my $fh,'<',$rulefile);
  my $json=<$fh>;
  my $rules=decode_json($json);
  @rules=@{$rules};
}

sub recordGeneration() {
  my $gen=shift @_;
  my $in=shift @_;
  my $actor=shift @_;
  my $arg=shift @_;
  my $out=shift @_;
  foreach my $thm (@$out) {
    warn "Regenerated $thm in generation $gen" if (exists $generation{$thm});
    $generation{$thm}=[$gen,$actor,$arg,[@$in],[@$out]];
  }
}

sub actionKey() {
  my @a=@{$_[0]};
  return &uri_escape($a[1])." ".&uri_escape($a[2]) if (defined($a[2]));
  return &uri_escape($a[1]);
}

sub nextGeneration() {
  my ($gen,$previousthm) = @_;
  my @current=@$previousthm;
  my $rulenum=-1;
  my $found=[];
  foreach my $rule (@rules) {
    $rulenum++;
    if ($rule->{'type'} eq 'simple' ) {
      my $key=&actionKey([undef,$rule->{'actor'},undef]);
      next if (exists($bottomupseen{$key}));
      my $allfound=1;
      foreach my $requirement (@{$rule->{'in'}}) {
        if (!exists($generation{$rule}) && $generation{$rule} < $gen) {
          $allfound=0;last;
        }
      }
      if ($allfound) {
        $bottomupseen{$key}=1;
        &recordGeneration($gen,$rule->{'in'},$rule->{'actor'},undef,$rule->{'out'});
        push $found,@{$rule->{'out'}};
      }
    } elsif ($rule->{'type'} eq 'pattern' ) {
      my $pattern=$rule->{'pattern'};
      my $patternRE=qr/$pattern/;
      foreach my $candidate (@current) {
        my @list;
        if (@list = ($candidate =~ $patternRE)) {
          my @in=();
          my @out=();
          foreach my $infile (@{$rule->{'in'}}) {
            push @in, $infile;
          }
          foreach my $infile (@{$rule->{'out'}}) {
            push @out, $infile;
          }
          my $argument=$rule->{'argument'};
          foreach my $counter (1..$#list+1) {
            $argument =~ s/\$$counter/$list[$counter-1]/ge;
            foreach (@in,@out) {
              s/\$$counter/$list[$counter-1]/ge;
            }
          }
          my $key=&actionKey([undef,$rule->{'actor'},$argument]);
          next if exists($bottomupseen{$key});
          $bottomupseen{$key}=1;
          push $trigger,{
                         'rulenum' => $rulenum,
                         'actor' => $rule->{'actor'},
                         'arg' => $argument,
                         'in' => [ @in ],
                         'wanted' => [ @in ],
                         'out' => [ @out ]
                        };
        }
      }
    }
  }
  my $delayednumber=0;
  my $triggercopy=&shallowCopy($trigger);
  foreach my $delayed (@$triggercopy) {
    my @wanted=@{$delayed->{'wanted'}};
    my $i=0;
    my $wantedcopy=&shallowCopy(\@wanted);
    foreach my $wanted (@$wantedcopy) {
      if (exists($generation{$wanted}) && $generation{$wanted}->[0]<$gen) {
        splice $delayed->{'wanted'},$i,1;
        $i--;
      }
      $i++;
    }
    @wanted=@{$delayed->{'wanted'}};
    if (scalar @wanted == 0) {
      &recordGeneration($gen,$delayed->{'in'},$delayed->{'actor'},$delayed->{'arg'},$delayed->{'out'});
      push $found,@{$delayed->{'out'}};
      splice $trigger,$delayednumber,1;
      $delayednumber--;
    }
    $delayednumber++;
  }
  return $found;
}

&readAxioms(@ARGV);
&readRules();
&recordGeneration(0,[],"AXIOM",undef,[@axioms]);
my $currentgen=\@axioms;
my $generation=1;
my $newlength=scalar @axioms;
while ($newlength) {
  $currentgen=&nextGeneration($generation,$currentgen);
  $newlength=scalar @{$currentgen};
  $generation++;
}

my $morefiles=0;

# Now, collect only the goals

my %topdownseen=();
my $goals=[@ARGV];
my %idontknow=();
my %ineed=();

while (scalar @$goals) {
  my $goal=pop $goals;
  do {
    $idontknow{$goal}=1;next;
  } unless (exists($generation{$goal}));
  my $key=&actionKey($generation{$goal});
  next if exists($topdownseen{$key});
  $topdownseen{$key}=1;
  $ineed{$key}=$generation{$goal};
  push $goals,@{$generation{$goal}->[3]};
}

if (scalar keys %idontknow) {
  print "I do not know how to build the following goals:\n";
  print join("\n",sort keys %idontknow),"\nStopping.\n";
  exit 1;
}

my @sresult=sort {
  ($a->[0] <=> $b->[0]) || ($a->[1] cmp $b->[1]) || (!defined($a->[2])?1:(!defined($b->[2])?-1:$a->[2] cmp $b->[2]))
} values %ineed;

foreach (@sresult) {
  my @a = @{$_};
  print $a[0].' '.$a[1],(defined($a[2])?' '.$a[2]:''),"\n";
}
