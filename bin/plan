#!/usr/bin/perl

# Idea: allow for lazy axioms in plan/lazy
## These axioms would not be considered if option --hard is given
## Overwriting these axioms is not considered an error.
## A rule overwriting only these axioms must be ignored.
## Example: generating .pfb .afm from .sfd files

use strict;
use warnings;
use JSON::PP;
use Data::Dumper;
use URI::Escape;
use Digest::MD5;

my $axiomdir='./plan/axioms';
my $rulefile='./plan/rules';

my @axioms=();
my @theorems=();
my %generation=();
my @rules;
my $trigger=[];
my %bottomupseen=();
my %rules=();
my %fingerprintCache=();

sub fingerprint() {
  my ($f)=@_;
  my $hash="0";
  return "$f:0" if (-d $f);
  return "$f:0" unless (-e $f);
  open FILE,"$f" or return "$f:0";
  my $hashing = Digest::MD5->new;
  $hashing->addfile(*FILE);
  $hash=$hashing->hexdigest;
  close FILE;
}

sub fingerprintArray() {
  my @a=@{$_[0]};
  my @hashArray=sort map {&fingerprint($_)} @a;
  return \@hashArray;
}

sub writeCache() {
  open CACHE,">.tmp/cache";
  print CACHE encode_json \%fingerprintCache;
  close CACHE;
}

sub readCache() {
  local $/;
  open (my $fh,'<',".tmp/cache") or return;
  my $json=<$fh>;
  my $cache=decode_json($json);
  foreach (keys %{$cache}) {
    $fingerprintCache{$_}=$cache->{$_};
  }
}

sub readAxioms() {
  opendir(my $dh, $axiomdir) || die;
  while (readdir $dh) {
    next if /^[.]/;
    my $axiomfile=$axiomdir."/".$_;
    open FILE,$axiomfile;
    while (my $line=<FILE>) {
      chomp $line;
      next if $line=~/^#/;
      push @axioms,uri_unescape($line);
    }
    close FILE;
  }
  closedir $dh;
}

sub shallowCopy() {
  my $a=[];
  foreach my $b (@{$_[0]}) {
    push $a,$b;
  }
  return $a;
}

sub readRules() {
  local $/;
  open (my $fh,'<',$rulefile);
  my $json=<$fh>;
  my $rules=decode_json($json);
  @rules=@{$rules};
  foreach my $rule (@rules) {
    $rules{$rule->{"actor"}}=$rule;
  }
  $rules{'AXIOM'}={};
}

sub recordGeneration() {
  my %rule=%{$_[0]};
  my $gen=$rule{'gen'};
  my $arrayarg=[];
  if (defined($rule{'arg'})) {
    push $arrayarg,map {&uri_escape($_)} @{$rule{'arg'}};
  }
  $rule{'arg'}=$arrayarg;
  foreach my $thm (@{$rule{'out'}}) {
    die "Regenerated $thm in generation $gen" if (exists $generation{$thm});
    $generation{$thm}={'gen' => $gen,
                       'actor' => uri_escape($rule{'actor'}),
                       'arg' => $arrayarg,
                       'in' => [@{$rule{'in'}}],
                       'out' => [@{$rule{'out'}}],
                      };
  }
}

sub actionKey() {
  my %a=%{$_[0]};
  return $a{'actor'}." ".uri_escape($a{'arg'}) if (defined($a{'arg'}));
  return $a{'actor'};
}

sub nextGeneration() {
  my ($gen,$previousthm) = @_;
  my @current=@$previousthm;
  my $rulenum=-1;
  my $found=[];
  foreach my $rule (@rules) {
    $rulenum++;
    if ($rule->{'type'} eq 'simple' ) {
      my $key=&actionKey($rule);
      next if (exists($bottomupseen{$key}));
      my $allfound=1;
      foreach my $requirement (@{$rule->{'in'}}) {
        if (!exists($generation{$requirement}) || $generation{$requirement} < $gen) {
          $allfound=0;last;
        }
      }
      if ($allfound) {
        $bottomupseen{$key}=1;
        &recordGeneration({'gen' => $gen,
                           'in' => $rule->{'in'},
                           'actor' => $rule->{'actor'},
                           'out' => $rule->{'out'}});
        push $found,@{$rule->{'out'}};
      }
    } elsif ($rule->{'type'} eq 'pattern' ) {
      my $pattern=$rule->{'pattern'};
      my $patternRE=qr/$pattern/;
      foreach my $candidate (@current) {
        my @list;
        if (@list = ($candidate =~ $patternRE)) {
          my @in=();
          my @out=();
          foreach my $infile (@{$rule->{'in'}}) {
            push @in, $infile;
          }
          foreach my $outfile (@{$rule->{'out'}}) {
            push @out, $outfile;
          }
          if (defined($rule->{'infile'})) {
            foreach my $infile (@{$rule->{'infile'}}) {
              my $inf=''.$infile;
              foreach my $counter (1..$#list+1) {
                $inf =~ s/\$$counter/$list[$counter-1]/ge;
              }
              if (open FILE,$inf) {
                foreach (<FILE>) {
                  chomp;
                  push @in,$_;
                }
                close FILE;
              }
            }
          }
          my $argument=$rule->{'argument'};
          foreach my $counter (1..$#list+1) {
            $argument =~ s/\$$counter/$list[$counter-1]/ge;
            foreach (@in,@out) {
              s/\$$counter/$list[$counter-1]/ge;
            }
          }
          my $key=&actionKey({'actor'=>$rule->{'actor'},'arg'=>[$argument]});
          next if exists($bottomupseen{$key});
          $bottomupseen{$key}=1;
          push $trigger,{
                         'rulenum' => $rulenum,
                         'actor' => $rule->{'actor'},
                         'arg' => [$argument],
                         'in' => [ @in ],
                         'wanted' => [ @in ],
                         'out' => [ @out ]
                        };
        }
      }
    }
  }
  my $delayednumber=0;
  my $triggercopy=&shallowCopy($trigger);
  foreach my $delayed (@$triggercopy) {
    my @wanted=@{$delayed->{'wanted'}};
    my $i=0;
    my $wantedcopy=&shallowCopy(\@wanted);
    foreach my $wanted (@$wantedcopy) {
      if (exists($generation{$wanted}) && $generation{$wanted}->{'gen'}<$gen) {
        splice $delayed->{'wanted'},$i,1;
        $i--;
      }
      $i++;
    }
    @wanted=@{$delayed->{'wanted'}};
    if (scalar @wanted == 0) {
      $delayed->{'gen'}=$gen;
      &recordGeneration($delayed);
      push $found,@{$delayed->{'out'}};
      splice $trigger,$delayednumber,1;
      $delayednumber--;
    }
    $delayednumber++;
  }
  return $found;
}

sub bottomUp {
  my $currentgen=\@axioms;
  my $generation=1;
  my $newlength=scalar @axioms;
  while ($newlength) {
    $currentgen=&nextGeneration($generation,$currentgen);
    $newlength=scalar @{$currentgen};
    $generation++;
  }
}


sub topDown {
  # Now, collect only the goals
  my %topdownseen=();
  my $goals=[@ARGV];
  my %idontknow=();
  my %ineed=();

  if (scalar @$goals == 0) {
    $goals=[keys %generation];
  }
  while (scalar @$goals) {
    my $goal=pop $goals;
    do {
      $idontknow{$goal}=1;next;
    } unless (exists($generation{$goal}));
    my $key=&actionKey($generation{$goal});
    next if exists($topdownseen{$key});
    $topdownseen{$key}=1;
    $ineed{$key}=$generation{$goal};
    push $goals,@{$generation{$goal}->{'in'}};
  }
  if (scalar keys %idontknow) {
    print "I do not know how to build the following goals:\n";
    print join("\n",sort keys %idontknow),"\nStopping.\n";
    exit 1;
  }
  my @result=sort {
    ($a->{'gen'} <=> $b->{'gen'}) || ($a->{'actor'} cmp $b->{'actor'}) || (join(' ',$a->{'arg'}) cmp join(' ',$a->{'arg'}))
  } values %ineed;
  return \@result;
}

sub firstCompound {
  my $plan = $_[0];
  my $newplan=[];
  return undef unless (scalar @$plan);
  my $begin=0;
  my $end=1;
  my $maxend;
  my $axiom=$plan->[$begin]->{'actor'};
  if (defined($rules{$axiom}->{'maxargs'})) {
    $maxend=$begin+$rules{$axiom}->{'maxargs'};
  } else {
    $maxend=$begin+100000000;
  }
  while (
         $end < scalar @$plan and
         $end < $maxend and
         $plan->[$end]->{'gen'} == $plan->[$begin]->{'gen'} and
         $plan->[$end]->{'actor'} eq $plan->[$begin]->{'actor'}
        ) {
    $end++;
  }
  my $newplanrule={'gen' =>$plan->[$begin]->{'gen'},
                   'actor' =>$plan->[$begin]->{'actor'},
                   'arg' => [],
                  };
  my $newargs=$newplanrule->{'arg'};
  foreach my $i ($begin..$end-1) {
    push $newargs,@{$plan->[$i]->{'arg'}};
  }
  my $newin={};
  my $newout={};
  foreach my $i ($begin..$end-1) {
    foreach my $j (@{$plan->[$i]->{'in'}}) {
      $newin->{$j}=1;
    }
    foreach my $j (@{$plan->[$i]->{'out'}}) {
      $newout->{$j}=1;
    }
  }
  my @newin=sort keys $newin;
  my @newout=sort keys $newout;
  $newplanrule->{'in'}=\@newin;
  $newplanrule->{'out'}=\@newout;
  splice $plan,$begin,$end;
  return $newplanrule;
}

sub attempt() {
  my $todo=$_[0];
  print $todo->{'actor'};
  print " ",join(' , ',@{$todo->{'arg'}}) if (scalar @{$todo->{'arg'}});
  print "\n";
}

&readAxioms(@ARGV);
&readCache();
&readRules();
foreach my $axiom (@axioms) {
  &recordGeneration({'gen'=>0,
                     'actor' => "AXIOM",
                     'in' => [],
                     'arg' => [$axiom],
                     'out' => [$axiom]
                    });
}
&bottomUp();
my $result=&topDown();
my $todo;
while ($todo=&firstCompound($result)) {
  &attempt($todo);
}
foreach (@$result) {
  my @a = @{$_};
  print $a[0].' '.$a[1],(defined($a[2])?' '.$a[2]:''),"\n";
  print "In: ",join(' ',@{$a[3]}),"\n";
}
