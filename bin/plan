#!/usr/bin/perl

# Idea: manage inside files (both written and read in one actor)
# Idea: pseudo-target sweep to remove unmakeable non-axiom files
# Idea: automatic diagnostic of out, junk and in files.

if ('' cmp 'DOC SYNOPSIS') {

=pod

=head1 NAME

plan - build files by applying a set of fixed rules

=head1 SYNOPSIS

=head2 RULES AND GOALS

plan [B<--target>] I<targetname> ... (see L</"GOALS AND TARGETS">).

plan [B<--hard>] ... (see L</"LAZY AXIOMS">).

plan [B<-->] [I<goals>] (only goals after B<-->) (see L</"GOALS AND TARGETS">).

=head2 ACTIONS

plan B<[--]ignore>

plan B<[--]what>

plan B<[--]how> [I<goals>]

plan B<[--]why> [I<goals>]

plan B<--help>|B<--man>|B<--nroff>|B<--usage>

If a goal could be mistaken for another option, use the B<--> syntax.

=cut

}

use strict;
use warnings;
# Unicode safety
use utf8;
use Encode;

use JSON::PP;
use Data::Dumper;
use URI::Escape;
use Digest::MD5;
use Symbol 'gensym';
use File::Path qw(make_path);
use Cwd;
use Term::ANSIColor;
# command execution
use IPC::Open3;
use POSIX ":sys_wait_h";
use IO::Select;
use IO::Handle;

my ($execContext,$planContext,$outContext);

# Directories

my $axiomdir='plan/axioms';
my $rulefile='plan/rules';
my $actordir='plan/actors';
my $targetdir='plan/targets';

# Convenience

sub clone {
  my $obj=shift @_;
  my $t=ref($obj);
  return $obj unless ($t);
  return [map {&clone($_)} @$obj] if ($t eq 'ARRAY');
  my $n={};
  foreach my $key (keys %$obj) {
    $n->{$key}=&clone($obj->{$key});
  }
  return $n;
}

sub findGitTopdir {
  my $oldcwd='';
  my $cwd=getcwd();
  while ($oldcwd ne $cwd and !opendir(GITDIR,".git")) {
    chdir('..');
    $cwd=getcwd();
  }
  closedir(GITDIR);
  &finish(1,'Could not find the top-level directory') if $cwd eq $oldcwd;
  &out(1,'init','Relocated to project top directory');
}

sub addHash {
  my $hash={};
  foreach my $h (@_) {
    foreach my $k (keys %$h) {
      $hash->{$k}=1;
    }
  }
  return $hash;
}
sub addHashInPlace {
  my $hash=shift @_;
  foreach my $h (@_) {
    foreach my $k (keys %$h) {
      $hash->{$k}=$h->{$k};
    }
  }
}
sub subHash {
  my $hash={};    # TODO optimize if first hash much larger than second?
  my $init=shift @_;
  foreach my $k (keys %$init) {
    $hash->{$k}=1;
  }
  foreach my $h (@_) {
    foreach my $k (keys %$h) {
      delete ($hash->{$k}) if (exists($hash->{$k}));
    }
  }
  return $hash;
}

sub main {
  my $goalHash;
  my $unbuildable;
  &initLogging();
  &findGitTopdir();
  my ($goals,$targets,$mode)=&parseARGV();
  if ($mode =~ /^help-([a-z]+)/) {
    &usage($1);
  }
  &readRules();
  my $axioms=&readAxiomsFromGit();
  &setupCommand();
  my $exceptions=&readFileList('plan/axioms');
  my $notaxioms=&readFileList('plan/notaxioms');
  my $realaxioms=addHash($axioms,$exceptions);
  $realaxioms=subHash($realaxioms,$notaxioms);
  if ($mode eq 'clean' or $mode eq 'distclean') {
    my $finals={};
    $finals=&readFileList('plan/targets/finals') if $mode eq 'clean';
    my $preserve=addHash($realaxioms,$finals);
    &readCache($planContext,'junk');
    &removeGenerated($planContext,'junk',$preserve);
    &finish(0);
  } elsif ($mode eq 'what') {
    &preparePlan($realaxioms);
    $goalHash=&instantiateTargets($targets,$goals,$planContext->{'generated'},$realaxioms);
    $unbuildable=&subHash($goalHash,$planContext->{'generated'});
    &explainPlan($unbuildable);
    &finish(0);
  } elsif ($mode eq 'ignore') {
    &preparePlan($realaxioms);
    my $generable={};
    foreach my $k (keys %{$planContext->{'generated'}}) {
      $generable->{$k}=1 unless $k =~ '^.tmp';
    }
    $generable=&subHash($generable,$axioms);
    $generable->{'.tmp'} = 1;
    my $data='/'.join("\n/",sort keys %$generable)."\n";
    &outputSection('.gitignore','plan',$data);
    &finish(0);
  } elsif ($mode eq 'how') {
    &preparePlan($realaxioms);
    $goalHash=&instantiateTargets($targets,$goals,$planContext->{'generated'},$realaxioms);
    my $narrowPlan=&reducePlan($goalHash,$planContext->{'generated'});
    &graphviz($narrowPlan,$goalHash);
    &finish(0);
  } elsif ($mode eq 'goal') {
    my $steps=0;
    my $finished=0;
    $planContext->{'fingerprint'}={};
    $planContext->{'generated'}={};
    &readCache($planContext,'fingerprint');
    &readCache($planContext,'lazyfingerprint');
    &addHashInPlace($planContext->{'fingerprint'},$planContext->{'lazyfingerprint'});
    &readCache($planContext,'junk');
    &removeGenerated($planContext,'junk',undef);
    my $narrowPlan;
    while (!$finished) {
      &preparePlan($realaxioms);
      $goalHash=&instantiateTargets($targets,$goals,$planContext->{'generated'},$realaxioms);
      $narrowPlan=&reducePlan($goalHash,$planContext->{'generated'});
      my $begin=0;
      my $xfinished=0;
      my $todo=undef;
      while (!$xfinished) {
        my $end;
        ($todo,$end)=&firstCompound($narrowPlan,$begin);
        if (defined($todo)) {
          $steps++;
          $xfinished=1;
        } else {
          $begin=$end;
          if ($begin >= scalar @$narrowPlan) {
            $xfinished=1;
            $finished=1;
          }
        }
      }
      &attempt($todo) if defined($todo);
    }
    $unbuildable=&subHash($goalHash,$planContext->{'generated'});
    if (scalar keys %$unbuildable) {
      &explainPlan($unbuildable);
      &finish(1,'Some files could not be built');
    }
    if ($steps==0) {
      if (scalar @$narrowPlan) { 
        &out(1,'display','Everything is up to date');
      } else {
        &out(1,'display','Nothing to be done');
      }
    }
    &finish(0);
  }
  &finish(1,"$mode is not implemented yet");
}

&main();

# Logging
sub initLogging {

=pod

=head2 OUTPUT OPTIONS

B<--verbosity> I<category> I<level> Change the verbosity to I<level> in I<category>.

B<--I<category>> I<level> Shortcut, as above (see L</"VERBOSITY">).

If verbosity can be mistaken for a target name, use the B<--verbosity> form, because the target will take precedence.

The verbosity level is a positive integer (including 0).

The various categories are :

=over

=item * B<init> initialization information (not usefule)

=item * B<plan> informations about the building plan (can be very verbose)

=item * B<exec> informations about the commands launched by the plan

=item * B<err> the error output of the various commands

=item * B<out> the console output of the various commands

=item * B<display> the summary of the building (1: each class, 2: each subclass, 3: each item)

=back

Each rule can define a class and a subclass, and each item built will be
output in a synthetic manner. The default setting is 3 for B<display>
and 1 for B<out> and B<err>. A quiet effect can be obtained by setting
everything to 0.

=cut

  binmode(STDOUT,':utf8');
  binmode(STDERR,':utf8');
  binmode(STDIN,':utf8');
  my $verbosity={'exec'=>0,
                 'init'=>0,
                 'plan'=>0,
                 'out'=>1,
                 'err'=>1,
                 'dev'=>1,
                 'display'=>3};
  my $jsonEncoder=JSON::PP->new->pretty->canonical;
  $outContext={
               'color' => 1,
               'class' => '',
               'subclass' => '',
               'currentcol' => 0,
               'nomove' => 0,
               'countphase' => '',
               'lastcountcol' => 0,
               'verbosity' => $verbosity,
               'specialprefix' => qr/^PARTIAL PLAN:(.*)$/,
               'json' => $jsonEncoder,
              };
  &columns();
  $SIG{WINCH} = sub { &columns(); };
  $ENV{'SPECIALPREFIX'}="PARTIAL PLAN:";
  $outContext->{'color'}=0 unless -t STDOUT;
  &out(1,'init','Logging system ready');
}                               # DOC INSIDE
sub columns {
  require 'sys/ioctl.ph';
  my $winsize;
  die 'no TIOCGWINSZ' unless defined &TIOCGWINSZ;
  open(TTY, "+</dev/tty") or die "No tty: $!";
  unless (ioctl(TTY, &TIOCGWINSZ, $winsize='')) {
    die sprintf "$0: ioctl TIOCGWINSZ (%08x: $!)\n", &TIOCGWINSZ;
  }
  my ($row, $col, $xpixel, $ypixel) = unpack('S4', $winsize);
  $outContext->{'columns'}=$col;
}
sub finish {
  my $status=shift @_;
  &newline();
  if ($status == 1) {
    print "Dying: ",@_,"\n";
  }
  exit($status);
}
sub newline {
  print "\n" if ($outContext->{'currentcol'});
  $outContext->{'currentcol'}=0;
  $outContext->{'nomove'}=0;
}
sub class {
  my $class=$_[0];
  if ($class ne $outContext->{'class'}) {
    &newline();
    $outContext->{'subclass'}='';
    print color 'bold' if ($outContext->{'color'});
    print $class,"\n";
    print color 'reset' if ($outContext->{'color'});
    $outContext->{'class'}=$class;
  }
}
sub subclass {
  my $subclass=$_[0];
  if ($subclass ne $outContext->{'subclass'}) {
    $outContext->{'subclass'}=$subclass;
    print color 'bold' if ($outContext->{'color'});
    &outDisplay($subclass);
    print color 'reset' if ($outContext->{'color'});
  }
}
sub outDisplay {
  my $str=join('',@_);
  my $storepos=0;
  if ($str =~ /^count:(.*):([0-9\/]+)$/) {
    $str="$1:$2";
    my $oldcountphase=$outContext->{'countphase'};
    my $countphase="$1";
    $outContext->{'countphase'}=$countphase;
    if ($outContext->{'color'} == 0) {
      my $lastcountcol=$outContext->{'lastcountcol'}+1;
      if ($lastcountcol == 500) {
        $lastcountcol=0;
      }
      if ($countphase ne $oldcountphase) {
        $lastcountcol=0;
      }
      $outContext->{'lastcountcol'}=$lastcountcol;
      return if ($lastcountcol != 0);
    } else {
      if ($outContext->{'nomove'} == 1 and $countphase eq $oldcountphase) {
        $storepos=2;
      } else {
        $storepos=1;
      }
    }
  } else {
    $outContext->{'countphase'}='';
  }
  if ($storepos == 2) {
    $outContext->{'nomove'}=1;
    $outContext->{'currentcol'}=$outContext->{'lastcountcol'};
    print "\x1b[u";
  }
  my $len=length($str);
  my $margin=2;                 # Two chars required for []
  if ($outContext->{'currentcol'}+$margin+$len>$outContext->{'columns'}) {
    &newline();
  }
  if ($outContext->{'currentcol'}==0) {
    print '    ';
    $outContext->{'currentcol'}=4;
  }
  if ($storepos == 1) {
    $outContext->{'nomove'}=1;
    $outContext->{'lastcountcol'}=$outContext->{'currentcol'};
    print "\x1b[s";
  } elsif ($storepos != 2) {
    $outContext->{'nomove'}=0;
  }
  $outContext->{'currentcol'}+=2+$len;
  print '[',$str,']';
}
sub out {
  my $v=shift @_;
  my $n=shift @_;
  if ($outContext->{'verbosity'}->{$n}>=$v) {
    if (ref($_[0])) {
      $_[1] = Data::Dumper->Dump([$_[0]],[$_[1]]);
      shift @_;
    }
    if ($n eq 'display') {
      my $storepos=0;
      if ($v==1) {
        &class(@_);
      } elsif ($v==2) {
        &subclass(@_);
      } else {
        &outDisplay(@_);
      }
    } elsif ($n eq 'out') {
      &newline();
      print color 'blue' if ($outContext->{'color'});
      print '      ',@_,"\n";
      print color 'reset' if ($outContext->{'color'});
    } elsif ($n eq 'err' or $n eq 'dev') {
      &newline();
      print color 'red' if ($outContext->{'color'});
      print @_,"\n";
      print color 'reset' if ($outContext->{'color'});
    } else {
      &newline();
      print $n,':',@_,"\n";
    }
  }
}

# ARGV
if ('' eq 'DOC OUTPUT OPTIONS') {
}
sub parseARGV {
  my $goals=[];
  my $mode='goal';
  my $targets=[];
  my @target=&readDir('plan/targets');
  my %target=('all' => 1);
  foreach my $t (@target) {
    $target{$t}=1;
  }
  my $lazy=1;
  my $x=0;
  while ($x < scalar @ARGV) {
    my $arg=$ARGV[$x];
    if (defined($target{$arg}) or $arg eq '--target') {
      if ($arg eq '--target') {
        $x++;
        $arg=$ARGV[$x];
      }
      push $targets,$arg;
    } elsif ($arg eq '--verbosity') {
      &finish(1,"Wrong option: --verbosity must be followed by two arguments") unless defined($ARGV[$x+2]);
      my $cat=$ARGV[$x+1];
      my $level=$ARGV[$x+2];
      $x+=2;
      &finish(1,"Wrong option: --verbosity must be followed by one of ".join(' or ',keys %{$outContext->{'verbosity'}})) unless defined($outContext->{'verbosity'}->{$cat});
      &finish(1,"Wrong option: --verbosity must be followed by a category and an integer") unless $level =~ /^[0-9]+$/;
      $outContext->{'verbosity'}->{$cat}=$level;
    } elsif ($arg eq '--nroff') {
      $mode='help-nroff';
    } elsif ($arg eq '--hard') {
      $lazy=0;
    } elsif ($arg eq '--help' or $arg eq '-h') {
      $mode='help-help';
    } elsif ($arg eq '--man') {
      $mode='help-man';
    } elsif ($arg eq '--usage') {
      $mode='help-usage';
    } elsif ($arg eq '--nroff') {
      $mode='help-nroff';
    } elsif ($arg eq 'what' or $arg eq '--what') {
      $mode='what';
    } elsif ($arg eq 'ignore' or $arg eq '--ignore') {
      $mode='ignore';
    } elsif ($arg eq 'why' or $arg eq '--why') {
      $mode='why';
    } elsif ($arg eq 'how' or $arg eq '--how') {
      $mode='how';
    } elsif ($arg eq 'clean' or $arg eq '--clean') {
      $mode='distclean';
    } elsif ($arg eq 'distclean' or $arg eq '--distclean') {
      $mode='distclean';
    } elsif ($arg =~ '--(\w+)' and defined($outContext->{'verbosity'}->{$1})) {
      my $cat=$1;
      my $level=$ARGV[$x+1];
      $x++;
      &finish(1,"Wrong option: --verbosity must be followed by a category and an integer") unless $level =~ /^[0-9]+$/;
      $outContext->{'verbosity'}->{$cat}=$level;
    } elsif ($arg eq '--') {
      $x++;
      while ($x < scalar @ARGV) {
        push $goals,$ARGV[$x];
        $x++;
      }
    } else {
      push $goals,$arg;
    }
    $x++;
  }
  if (scalar @$goals == 0 and scalar @$targets == 0) {
    push $targets,'finals';
  }
  &out(1,'init','Parsing ARGV done');
  $planContext->{'lazyOption'}=$lazy;
  return ($goals,$targets,$mode);
}
sub instantiateTargets {
  my ($targets,$goals,$generation,$axioms)=@_;
  my $goalHash={};
  my $targetHashes=[];
  my $all=0;
  foreach my $g (@$goals) {
    $goalHash->{$g}++;
  }
  foreach my $f (@$targets) {
    if ($f eq 'all') {
      my $allHash=subHash($generation,$axioms);
      push $targetHashes,$allHash;
    } else {
      push $targetHashes,&readFileList($targetdir.'/'.$f,1);
    }
  }
  &addHashInPlace($goalHash,@$targetHashes);
  return $goalHash;
}

# Help
sub usage {

=pod

=head2 HELP OPTIONS

B<--help>|B<-h> Generate this help (long version).

B<--usage> Generate this help (short version).

B<--man> Generate man page.

B<--nroff> Generate man page in NROFF format.

=cut

  ### usage ($option)
  ### Provides all kinds of textual help and stops
  my ($option)=@_;
  if (!defined($option)) {
    $option='usage';
  }
  my $cmd='pod2txt';
  my $release="0.6";
  my ($a,$out,$b);
  if ($option eq 'man'||$option eq 'nroff') {
    ($a,$out,$b)=@{&executeCommand('','pod2man',"$0",'--center','User commands','--release',$release)};
    if ($a==0 && $option eq 'man') {
      ($a,$out,$b)=@{&executeCommand($out,'nroff','-man','-')};
    }
  } else {
    ($a,$out,$b)=@{&executeCommand('','pod2text',"$0")};
  }
  if ($option eq 'usage') {
    $out =~ s/OPTIONS.*$//s;
  }
  if ($option ne 'man') {
    print $out;
  } else {
    open FILE,"|pager";
    print FILE $out;
    close FILE;
  }
  &finish(0);
}

# Command execution with stderr filtering
sub REAPER {
  my $child;
  while (($child = waitpid(-1, WNOHANG)) > 0) {
    &out(1,'exec',"Caught $child dying with status $?");
    $execContext->{'status'}->{$child} = $?;
    delete $execContext->{'children'}->{$child};
  }
  $SIG{CHLD} = \&REAPER;        # still loathe SysV
}
sub setupCommand {
  &out(1,'init','Initialize harness for command executions');
  select(STDERR); $| = 1;
  select(STDOUT); $| = 1;
  $execContext={
                'status' => {},
                'children' => {},
               };
  $SIG{CHLD} = \&REAPER;
  $SIG{INT} = sub {
    foreach my $pid (keys %{$execContext->{'children'}}) {
      kill 2,$pid;
    }
  }
}
sub errorCommand {
  my $lines=$_[0];
  foreach my $line (split /\n/m,$lines) {
    chomp $line;
    if ($line =~ $outContext->{'specialprefix'}) {
      my $part=$1;
      if ($part =~ /^done:(.*)$/) {
        $part=$1;
        push $execContext->{'partiallyDone'},$part;
      }
      &out(3,'display',$part);
    } else {
      &out(1,'err',$line);
    }
  }
}
sub execCommand {
  my $line;
  &out(1,'exec','Executing '.join(' ',@_));
  my $out = gensym;
  my $err = gensym;
  $execContext->{'partiallyDone'}=[];
  my $pid = open3("<&STDIN",$out, $err, @_);
  return 1 if (!$pid);
  &out(1,'exec',"Forked pid $pid");
  $execContext->{'children'}->{$pid}=1;
  my $sel= new IO::Select;
  $sel->add($err,$out);
  while (scalar keys %{$execContext->{'children'}} > 0) {
    foreach my $readhandle ($sel->can_read(.5)) {
      my $length=sysread $readhandle,$line,4096;
      if ($length) {
        if (fileno($readhandle)==fileno($err)) {
          &errorCommand($line);
        } else {
          chomp $line;
          &out(1,'out',$line);
        }
      }
    }
  }
  &out(3,'exec',$execContext);
  my $status=0+$execContext->{'status'}->{$pid};
  delete $execContext->{'status'}->{$pid};
  &out(1,'exec',"Command finished with status $status");
  return $status;
}
sub executeCommand {
  # a much simpler version for the manual page
  my $in=shift @_;
  &out(1,'exec',join(' ',@_));
  my $outputtext='';
  my $errtext='';
  my $pid=open3(\*INPUT, \*OUTPUT, \*ERR,@_);
  print INPUT $in if $in;
  close(INPUT);
  my $done=0;
  do {
    while (<OUTPUT>) {
      $outputtext.=$_;
    }
    while (<ERR>) {
      $errtext.=$_;
    }
    $done=waitpid($pid,WNOHANG);
  } until ($done>0);
  return [ $?, $outputtext, $errtext ];
}

# Disk Input/Output
sub fingerprint {
  my ($f)=@_;
  my $hash='0';
  return '0' unless (-e $f);
  return '0' if (-d $f);       # TODO: recursive version for directories
  open FILE,"$f" or return "$f:0";
  my $hashing = Digest::MD5->new;
  $hashing->addfile(*FILE);
  $hash=$hashing->hexdigest;
  close FILE;
  return $hash;
}
sub fingerprintArray {
  # example: $rule, 'in'
  my @a=sort keys %{$_[0]->{$_[1]}};
  return 'none' unless (scalar @a);
  my $hashing = Digest::MD5->new;
  my $fp;
  foreach my $file (@a) {
    $fp=&fingerprint($file);
    $hashing->add($file.$fp);
  }
  return $hashing->hexdigest;
}

sub encodeGoalLine {
  join('',
       map { ($_ > 127 || $_ < 32 || $_ == 37 )?
               sprintf("%%(%d)", $_) :
                 chr($_)
               } unpack("W*", &decode_utf8($_[0]))); # unpack Unicode characters
}
sub decodeGoalLine {
  my $a=$_[0];
  $a =~ s/%\(([0-9]+)\)/chr($1)/eg;
  return $a;
}

sub writeCache {
  my ($cacheHash,$path)=@_;
  &out(3,'init',"Storing $path cache");
  my $cachehandle;
  open STDIN,"/dev/null" unless fileno(STDIN);
  if ($path eq 'lazyfingerprint') {
    make_path('plan');
    open $cachehandle,'>',"plan/$path" or &finish(1,"I cannot open my $path cache!");
  } else {
    make_path('.tmp');
    open $cachehandle,'>',".tmp/$path" or &finish(1,"I cannot open my $path cache!");
  }
  print $cachehandle $outContext->{'json'}->encode($cacheHash->{$path});
  $cachehandle->sync();
  close $cachehandle;
}
sub readCache {
  my ($cacheHash,$path)=@_;
  if (!defined($cacheHash->{$path})) {
    $cacheHash->{$path}={};
  }
  &out(1,'init',"Reading $path cache");
  my $filepath=".tmp/$path";
  $filepath="plan/$path" if ($path eq 'lazyfingerprint');
  local $/;
  open (my $fh,'<',$filepath) or return;
  my $json=<$fh>;
  my $cache=decode_json($json);
  foreach my $f (keys %{$cache}) {
    $cacheHash->{$path}->{$f}=$cache->{$f};
  }
}
sub outputSection {
  my ($file,$section,$data)=@_;
  my @lines=();
  my $inside=0;
  my $done=0;
  if (-f $file and -r $file) {
    open FILE,$file;
    while (my $line=<FILE>) {
      chomp $line;
      if ($line =~ /^# start automatic section for $section$/) {
        $inside=1;
        if (!$done) {
          $done=1;
          push @lines,"# start automatic section for $section";
          push @lines,$data;
          push @lines,"# stop automatic section for $section";
        }
        next;
      }
      if ($line =~ /^# stop automatic section for $section$/) {
        $inside=0;next;
      }
      next if $inside==1;
      push @lines,$_;
    }
    if (!$done) {
      push @lines,"# start automatic section for $section";
      push @lines,$data;
      push @lines,"# stop automatic section for $section";
    }
    close FILE;
  } else {
    push @lines,"# start automatic section for $section\n";
    push @lines,$data;
    push @lines,"# stop automatic section for $section\n";
  }
  open FILE,">$file";
  foreach my $line (@lines) {
    next unless defined($line);
    print FILE $line."\n";
  }
  close FILE;
}

sub forceUnlink {
  my $_=shift @_;
  unlink $_;                    # TODO: this may be a directory
}
sub removeGenerated {
  my ($cacheHash,$path,$axioms)=@_;
  my $count=0;
  if (defined($axioms)) {
    &out(1,'display','Removing old files');
  } else {
    &out(1,'init','Cleaning old files cache');
  }
  # If $axioms not defined, just test presence
  # Else, unlink all files not in $axioms hash
  foreach my $key (keys %{$cacheHash->{$path}}) {
    if (-f $key) {
      if (defined($axioms) and !exists($axioms->{$key})) {
        # clean or distclean
        $count++;
        &forceUnlink($key);
        delete $cacheHash->{$path}->{$key};
      }
    } else {
      delete $cacheHash->{$path}->{$key};
    }
  }
  &writeCache($cacheHash,$path);
  if (defined($axioms)) {
    &out(3,'display',"Removed $count old files");
  }
}

sub readAxiomsFromGit {
  &out(1,'init','Reading axioms from git');
  # TODO use some form of exec command instead of open|
  open READ,"git ls-files -z|";
  my $a=<READ>;
  close READ;
  my @b=sort map {decode_utf8($_)} split("\x{00}",$a);
  &out(2,'init',\@b);
  my $hash={};
  foreach my $k (@b) {
    $hash->{$k}=1;
  }
  return $hash;
}
sub readRules {
  local $/;
  open (my $fh,'<',$rulefile);
  my $json=<$fh>;
  my $rules=decode_json($json);
  foreach my $rulename (keys %$rules) {
    my $rule=$rules->{$rulename};
    $rule->{'in'}=[] unless (defined($rule->{'in'}));
    push $rule->{'in'},$actordir.'/'.$rule->{'actor'};
    $rule->{'arg'}=[] unless (defined($rule->{'arg'}));
    $rule->{'class'}='' unless (defined($rule->{'class'}));
    $rule->{'subclass'}='' unless (defined($rule->{'subclass'}));
  }
  $rules->{'AXIOM'}={'type' => 'axiom',
                     'actor' => 'AXIOM',
                     'class' => 'Checking axioms',
                     'subclass' => '',
                    };
  $planContext->{'pristineRules'}=$rules;
  &out(1,'init','Read rules');
}
sub readFileList {
  my ($path,$mandatory)=@_;
  my $hash={};
  if (open FILE,'<:encoding(utf8)',$path) {
    my $line;
    while ($line=<FILE>) {
      chomp $line;
      my $g=&decodeGoalLine($line);
      $hash->{$g}++;
    }
    close FILE;
  } else {
    &out(1,'err',"Could not open $path") if defined($mandatory); 
  }
  return $hash;
}
sub readDir {
  my ($dir,$mandatory)=shift @_;
  my @dirlist;
  if (opendir(my $dh, $dir)) {
    @dirlist=grep {!/^\./} readdir($dh);
    closedir($dh);
  } else {
    &out(1,'err','Could not open directory $dir') if ($mandatory);
  }
  return @dirlist;
}

# Planning

sub actionKey {
  my $rule=shift @_;
  return $rule->{'key'} if (defined($rule->{'key'}));
  if (defined($rule->{'arg'}) and scalar @{$rule->{'arg'}} > 0) {
    $rule->{'key'}=join(' ',$rule->{'actor'},map {&encodeGoalLine($_)} @{$rule->{'arg'}});
  } else {
    $rule->{'key'}=$rule->{'actor'};
  }
  return $rule->{'key'};
}
sub recordGeneration {
  my $rule=shift @_;
  my $key=&actionKey($rule);
  my $gen=$rule->{'gen'};
  &out(2,'plan',"Rule $key is complete at generation $gen");
  $planContext->{'plan'}->{$key}=$rule;
  foreach my $outfile (keys %{$rule->{'out'}}) {
    if (defined($planContext->{'generated'}->{$outfile})) {
      if (defined($planContext->{'realAxioms'})
          and $planContext->{'generated'}->{$outfile} =~ /^AXIOM /) {
        if (defined($rule->{'lazy'})) {
          $planContext->{'lazy'}->{$outfile}=1;
          &out(1,'plan',"Seeing $outfile as lazy");
          goto OK;
        }
        &out(1,'err',"Non lazy-rule $key is regenerating axiom $outfile.");
      } else {
        &out(1,'err',"Rule $key is regenerating $outfile, already generated by ".$planContext->{'generated'}->{$outfile}.'.');
      }
      &finish(1,"Please fix your rules.");
    } else {
    OK:
      $planContext->{'generated'}->{$outfile}=$key;
      $planContext->{'generatedgen'}->{$outfile}=$gen;
      next;
    }
  }
}

sub recordAxioms {
  foreach my $axiom (keys %{$_[0]}) {
    $planContext->{'usedRules'}->{'AXIOM'}++;
    my $axiomRule=&clone($planContext->{'pristineRules'}->{'AXIOM'});
    $axiomRule->{'type'}='simple';
    $axiomRule->{'out'}={$axiom => 1};
    if ($axiom eq $actordir.'/AXIOM') {
      $axiomRule->{'in'}={}
    } else {
      $axiomRule->{'in'}={$actordir.'/AXIOM' => 1};
    }
    $axiomRule->{'wanted'}={};
    $axiomRule->{'arg'}=[$axiom];
    $axiomRule->{'gen'}=0;
    &recordGeneration($axiomRule);
  }
}
sub sortRules {
  my $prule=$planContext->{'pristineRules'};
  foreach my $rulename (keys %$prule) {
    next if (defined($prule->{$rulename}->{'lazy'})
             and $planContext->{'lazyOption'} == 1);
    $planContext->{'usedRules'}->{$rulename}=0;
    if ($prule->{$rulename}->{'type'} eq 'simple') {
      my $rule=&cleanRule(&clone($prule->{$rulename}));
      $planContext->{'simpleRules'}->{&actionKey($rule)}=$rule;
      $planContext->{'usedRules'}->{$rulename}=1;
    } elsif ($prule->{$rulename}->{'type'} eq 'pattern') {
      push $planContext->{'patternRules'},$rulename;
    }
  }
}
sub cleanRule {
  my ($rule,@list)=@_;
  my $list=scalar @list;
  my $in={};
  my $out={};
  my $class=$rule->{'class'};
  if ($class =~ /\$/) {
    foreach my $counter (1..$list) {
      $class =~ s/\$$counter/$list[$counter-1]/ge;
    }
  }
  $rule->{'class'}=$class;
  my $subclass=$rule->{'subclass'};
  if ($subclass =~ /\$/) {
    foreach my $counter (1..$list) {
      $subclass =~ s/\$$counter/$list[$counter-1]/ge;
    }
  }
  $rule->{'subclass'}=$subclass;
  foreach my $file (@{$rule->{'in'}}) {
    foreach my $counter (1..$list) {
      $file =~ s/\$$counter/$list[$counter-1]/ge;
    }
    $in->{$file}=1;
  }
  if (defined($rule->{'infile'})) {
    my $hash=[];
    foreach my $file (@{$rule->{'infile'}}) {
      foreach my $counter (1..$list) {
        $file =~ s/\$$counter/$list[$counter-1]/ge;
      }
      &out(2,'plan',"Expanding infile $file");
      push $hash,readFileList($file);
    }
    &addHashInPlace($in,@$hash);
  }
  foreach my $file (@{$rule->{'out'}}) {
    foreach my $counter (1..$list) {
      $file =~ s/\$$counter/$list[$counter-1]/ge;
    }
    $out->{$file}=1;
  }
  if (defined($rule->{'outfile'})) {
    my $hash=[];
    foreach my $file (@{$rule->{'outfile'}}) {
      foreach my $counter (1..$list) {
        $file =~ s/\$$counter/$list[$counter-1]/ge;
      }
      &out(2,'plan',"Expanding outfile $file");
      push $hash,readFileList($file);
    }
    &addHashInPlace($out,@$hash);
  }
  # Do something
  $rule->{'in'}=$in;
  $rule->{'out'}=$out;
  $rule->{'wanted'}=&clone($in);
  return $rule;
}
sub developPatterns {
  my ($gen,$theorems)=@_;
  foreach my $rulename (@{$planContext->{'patternRules'}}) {
    my $rule=$planContext->{'pristineRules'}->{$rulename};
    my $pattern=$rule->{'pattern'};
    my $patternRE=qr/$pattern/;
    foreach my $theorem (keys %$theorems) {
      my @list = ($theorem =~ $patternRE);
      next unless @list;
      my $arg=$rule->{'argument'};
      foreach my $counter (1..scalar @list) {
        $arg =~ s/\$$counter/$list[$counter-1]/ge;
      }
      if (defined($rule->{'allowedargs'})) {
        my $ok=0;
        foreach my $allow (@{$rule->{'allowedargs'}}) {
          if ($allow eq $arg) {
            $ok=1;last;
          }
        }
        next unless $ok;
      }
      $rule->{'arg'}=[$arg];
      my $newrule=&cleanRule(&clone($rule),@list);
      my $key=&actionKey($newrule);
      $newrule->{'trigger'}=$theorem;
      foreach my $wanted (keys %{$newrule->{'wanted'}}) {
        if (exists($planContext->{'generatedgen'}->{$wanted})
            and $planContext->{'generatedgen'}->{$wanted} < $gen) {
          delete $newrule->{'wanted'}->{$wanted};
        }
      }
      $planContext->{'simpleRules'}->{&actionKey($newrule)}=$newrule;
      $planContext->{'usedRules'}->{$rulename}++;
    }
  }
}
sub resolveSimpleRules {
  my ($theorems)=@_;
  foreach my $key (keys %{$planContext->{'simpleRules'}}) {
    my $rule=$planContext->{'simpleRules'}->{$key};
    $rule->{'wanted'}=&subHash($rule->{'wanted'},$theorems);
    next if (scalar keys $rule->{'wanted'});
    # we found everyone!
    $planContext->{'completeRules'}->{$key}=$planContext->{'simpleRules'}->{$key};
    delete($planContext->{'simpleRules'}->{$key});
  }
}

sub eliminateCompleteRules {
  my ($gen)=@_;
  my $newtheorems={};
  my $mingen=1000000;
  foreach my $key (keys %{$planContext->{'completeRules'}}) {
    my $rule=$planContext->{'completeRules'}->{$key};
    if (defined($rule->{'mingen'}) and $gen<$rule->{'mingen'}) {
      $mingen=$rule->{'mingen'} if ($rule->{'mingen'}<$mingen);
      next;
    }
    $rule->{'gen'}=$gen;
    &recordGeneration($rule);
    foreach my $out (keys %{$rule->{'out'}}) {
      $newtheorems->{$out}=1;
    }
    delete($planContext->{'completeRules'}->{$key});
  }
  return ($mingen,$newtheorems);
}

sub preparePlan {
  my ($axioms,$lazy)=@_;        # include list of lazy here
  if (!defined($lazy)) {
    &out(1,'plan','Initializing plan');
    $planContext->{'lazy'}={};
  } else {
    &out(1,'plan','Recomputing plan (with lazy axioms)');
    $planContext->{'lazy'}=$lazy;
    $axioms=&subHash($axioms,$lazy);
  }
  $planContext->{'generated'}={};
  $planContext->{'plan'}={};
  $planContext->{'completeRules'}={};
  $planContext->{'simpleRules'}={};
  $planContext->{'patternRules'}=[];
  $planContext->{'usedRules'}={};
  $planContext->{'realAxioms'}=&clone($axioms);
  &out(3,'plan','Sorting rules');
  &sortRules();
  &out(2,'plan','Recording axioms');
  &recordAxioms($axioms);
  my $theorems=$axioms;
  my $mingen;
  my $gen=1;
  while ($gen<1000000) {
    &out(2,'plan',"Building theorems (generation $gen), still ".
         (scalar keys %{$planContext->{'simpleRules'}}).' rules to go');
    &developPatterns($gen,$theorems);
    &resolveSimpleRules($theorems);
    ($mingen,$theorems)=&eliminateCompleteRules($gen);
    &out(3,'plan','Found '.(scalar keys %$theorems).' new theorems');
    if (scalar keys %$theorems) {
      $gen++;
    } else {
      $gen=$mingen;
    }
  }
  if (scalar keys %{$planContext->{'lazy'}} > 0 and !defined($lazy)) {
    &preparePlan($axioms,&clone($planContext->{'lazy'}));
  }
}
sub explainPlan {
  my $unbuildable=shift @_;
  &out(1,'plan','Explaining plan');
  foreach my $key (sort keys %{$planContext->{'simpleRules'}}) {
    my $rule=$planContext->{'simpleRules'}->{$key};
    &out(1,'err',"The rule $key did not complete.");
    foreach my $missingfile (sort keys %{$rule->{'wanted'}}) {
      &out(1,'err','The file "'.&encodeGoalLine($missingfile).'" was missing.');
    }
    &out(1,'err','This rule was triggered by "'.&encodeGoalLine($rule->{'trigger'}).'".') if ($rule->{'trigger'});
  }
  my $notUsed=[];
  my $usedRules=$planContext->{'usedRules'};
  foreach my $rulename (sort {$usedRules->{$b} <=> $usedRules->{$a} || $a cmp $b} keys %$usedRules) {
    my $count=$usedRules->{$rulename};
    if ($count) {
      &out(1,'out',"The rule named $rulename was used $count time".($count>1?'s.':'.'));
    } else {
      push $notUsed,$rulename;
    }
  }
  if (scalar @$notUsed > 0) {
    foreach my $rulename (@$notUsed) {
      &out(1,'err',"The rule named $rulename was not used at all.");
    }
  }
  foreach my $file (sort keys %$unbuildable) {
    &out(1,'err',"Impossible to build $file");
  }
}
sub reducePlan {
  &out(1,'plan','Narrowing build paths for selected goals');
  my ($goals,$generation)=@_;
  my $plan={};
  my $seen={};
  my $requirement=&clone($goals);
  while (scalar keys %$requirement) {
    my $tab=[keys %$requirement];
    foreach my $file (keys %$requirement) {
      delete ($requirement->{$file});
      next if ($seen->{$file});
      $seen->{$file}=1;
      if (!exists($generation->{$file})) {
        &out(1,'err','No build path to "'.&encodeGoalLine($file).'" yet.');
        next;
      }
      my $actionkey=$generation->{$file};
      my $inFiles=$planContext->{'plan'}->{$actionkey}->{'in'};
      foreach my $in (keys %$inFiles) {
        $requirement->{$in}=1 unless $seen->{$in};
      }
      $plan->{$actionkey}=1;
    }
  }
  $planContext->{'narrowPlan'}=$plan;
  my $planKeys=[sort {
    my $pa=$planContext->{'plan'}->{$a};
    my $pb=$planContext->{'plan'}->{$b};
    return ($pa->{'gen'} <=> $pb->{'gen'}) ||
      ($pa->{'actor'} cmp $pb->{'actor'}) ||
        ($pa->{'class'} cmp $pb->{'class'}) ||
          ($pa->{'subclass'} cmp $pb->{'subclass'}) ||
            ($pa->{'key'} cmp $pb->{'key'})
          } keys %$plan];
  &out(2,'plan',$planKeys);
  return $planKeys;
}

sub firstCompound {
  my ($plan,$begin) = @_;
  my $newplan=[];
  my $end=$begin+1;
  return (undef,$end) unless ($begin < scalar @$plan);
  my $planList=$planContext->{'plan'};
  my $maxend;
  my $first=$planList->{$plan->[$begin]};
  if (defined($first->{'maxargs'})) {
    $maxend=$begin+$first->{'maxargs'};
  } else {
    $maxend=$begin+100000000;
  }
  while (
         $end < scalar @$plan and
         $end < $maxend and
         $planList->{$plan->[$end]}->{'gen'} == $first->{'gen'} and
         $planList->{$plan->[$end]}->{'actor'} eq $first->{'actor'}
        ) {
    $end++;
  }
  my $candidates=[];
  # weed out already done candidates
  foreach my $i ($begin..$end-1) {
    my $rule=$planList->{$plan->[$i]};
    my $key=&actionKey($rule);
    my $fingerprintIn=&fingerprintArray($rule,'in');
    $rule->{'fingerprintIn'}=$fingerprintIn;
    my $fingerprintOut=&fingerprintArray($rule,'out');
    if (!defined($planContext->{'fingerprint'}->{$key})) {
      &out(2,'plan',"Considering $key (never seen)");
    } elsif ($planContext->{'fingerprint'}->{$key} eq "$fingerprintIn $fingerprintOut") {
      &out(3,'plan',"Not considering $key");
      next;
    } else {
      &out(2,'plan',"Considering $key (input or output changed)");
    }
    push $candidates,$key;
  }
  if (scalar @$candidates == 0) {
    return (undef,$end);
  }
  if (scalar @$candidates == 1) {
    return ($planList->{$candidates->[0]},$end);
  }
  my $compoundRule=&clone($first);
  delete $compoundRule->{'key'};
  my $individualRules=[];
  my $newargs=[];
  my $newins=[];
  my $newouts=[];
  my $origin={};
  foreach my $key (@$candidates) {
    my $rule=$planList->{$key};
    push $newargs,@{$rule->{'arg'}};
    push $newins,$rule->{'in'};
    push $newouts,$rule->{'out'};
    $origin->{$key}=1;
  }
  my $newin=addHash(@$newins);
  my $newout=addHash(@$newouts);
  $compoundRule->{'arg'}=$newargs;
  $compoundRule->{'origin'}=$origin;
  $compoundRule->{'in'}=$newin;
  $compoundRule->{'out'}=$newout;
  return ($compoundRule,$end);
}

# Execution control

sub registerSuccess {
  my ($rule)=@_;
  my $fingerprintOut=&fingerprintArray($rule,'out');
  my $fingerprintIn=$rule->{'fingerprintIn'};
  my $key=&actionKey($rule);
  &out(3,'plan',"Registering success of $key");
  $planContext->{'fingerprint'}->{$key}="$fingerprintIn $fingerprintOut";
  $planContext->{'lazyfingerprint'}->{$key}="$fingerprintIn $fingerprintOut" if defined($rule->{'lazy'});
}
sub attempt {
  my $rule=shift @_;
  my $key=&actionKey($rule);
  &out(2,'exec',"Preparing for $key");
  my @execLine=($actordir.'/'.$rule->{'actor'},@{$rule->{'arg'}});
  if ($rule->{'class'} ne '') {
    &out(1,'display',$rule->{'class'});
    if ($rule->{'subclass'} ne '') {
      &out(2,'display',$rule->{'subclass'});
    }
  } else {
    &out(1,'display',substr $key,0,72); # Default class = key
  }
  # in doubt, every possibly generated file will have been generated in the first
  # steps of the rule, so let's suppose they were.
  if ($rule ne 'AXIOM') {
    &addHashInPlace($planContext->{'junk'},$rule->{'out'});
    &writeCache($planContext,'junk');
  }
  my $status=&execCommand(@execLine);
  if ($status) {
    foreach my $ok (@{$execContext->{'partiallyDone'}}) {
      my $okEscaped=$rule->{'actor'}.' '.&encodeGoalLine($ok); # actionKey
      if (exists($rule->{'origin'}->{$okEscaped})) {
        &registerSuccess($planContext->{'plan'}->{$okEscaped});
      } else {
        &out(1,'err',"$ok was registered as done, but no rule by that name exists");
      }
    }
    &writeCache($planContext,'fingerprint');
    &writeCache($planContext,'lazyfingerprint') if defined($rule->{'lazy'});
    &finish(1,"One rule failed with status $status");
  } else {
    if (exists($rule->{'origin'})) {
      foreach my $ok (keys %{$rule->{'origin'}}) {
        &registerSuccess($planContext->{'plan'}->{$ok});
      }
    } else {
      &registerSuccess($rule);
    }
    &writeCache($planContext,'fingerprint');
    &writeCache($planContext,'lazyfingerprint') if defined($rule->{'lazy'});
  }
}

# Graphing

sub graphviz {
  # TODO enhance.
  # Collapse all targets produced by patterns as one node.
  # Collapse all actions produced by patterns as one node.
  my ($plan,$gen)=@_;
  my $rule;
  print "digraph How {\n  node [shape=box];\n";
  foreach my $key (@$plan) {
    $rule=$planContext->{'plan'}->{$key};
    next if $rule->{'actor'} eq 'AXIOM';
    print "  \"$key\";\n";
  }
  print "  node [shape=ellipse];\n";
  foreach my $key (@$plan) {
    $rule=$planContext->{'plan'}->{$key};
    next if $rule->{'actor'} eq 'AXIOM';
    foreach my $file (keys %{$rule->{'out'}}) {
      print "  \"$key\" -> \"$file\";\n";
    }
    foreach my $file (keys %{$rule->{'in'}}) {
      print "  \"$file\" -> \"$key\";\n";
    }
  }
  print "}\n";
}

# Documentation

if ('' eq 'DOC PRINCIPLES') {
  1;

=pod

=head1 PRINCIPLE

TODO

=head1 RULES

TODO

=head1 LAZY AXIOMS

A lazy axiom is an axiom that is version-controlled, but may be rebuilt
from others. For some reason (because it needs special tools to build,
because it is very long or expensive), it is in fact a theorem that is
delivered as an axiom. It can be used for building, but some manual
action must be made to rebuild it.

A rule that produces a I<lazy axiom> is a I<lazy rule>. A lazy rule will
be ignored unless the B<--hard> option is enabled. Moreover, the lazy
rule fingerprint will be stored in C<plan/lazyfingerprint> instead of
being stored in a temporary location. If C<plan/lazyfingerprint> is
under version control also, the file will not be redone if it depends
only on identical files. For example, an archive file of results shipped
in the project for commodity could be regenerated only if the archived
files change. If none of the archived files change, then the fingerprint
of the rule will be identical to the stored one, and the archive will
not be regenerated (archive files tend to differ in result even if
archiving the same contents, which is a pain for keeping them under
version control).

An axiom regenerated by a lazy rule will not generate any warning.
An axiom regenerated by an ordinaru rule will generate a warning.

=head1 EXPLAINING

The B<--why> and B<--how> specifiers will disable file generation and
explain by a simple graph which file is output starting from the
specified goals (B<--why>) or an input from the specified goals
(B<--how>). The graph is in I<graphviz> format.

=head1 GOALS AND TARGETS

The various goals files are filenames with one name per line. The names
may be escaped by using the %(hexadecimal) notation (you will most
probably never encounter that).

Targets are predefined list of goals that can be used instead of
specifying individual goals. The target names are usually sufficient to
use them as goals.

There is one default target: the I<all> target is the list of all
buildable files.

If no goals are given, then the target I<finals> will be used by default
(even if it is not defined).

=head1 FILES

=over

=item * C<plan/targets/I<target>> a list of goals aliased as a target

=item * C<plan/lazyfingerprint> a list of goals stored in git but not axioms

=item * C<plan/axioms> a list of goals not stored in git but considered as axioms

Beware that if plan/axioms is not empty, your project may be buildable
locally, but fail from the repository.

=item * C<plan/notaxioms> a list of files stored in git but not considered as axioms

For example, a compiled documentation may be stored in the git
repository even if it is automatically rebuilt each time. However,
L</"LAZY AXIOMS"> may be more interesting for this use case.

=item * C<plan/in/I<name>> a good place to put files read by C<infile> directives.

=item * C<plan/out/I<name>> a good place to put files read by C<outfile> directives.

=item * C<plan/actors/I<ACTOR>> a short script that executes the rule named
I<ACTOR> and receives the various arguments as $1, $2, etc.

=item * C<plan/rules> a JSON encoded file containing the rules.

=back

=head1 AUTHOR

Copyright Jean-Christophe Dubacq 2013

=head1 COPYING

This work is licensed under the BSD licence. It is explicitly stated
here that the license does not extend to the data managed by the
program, in case anyone had doubts.

=head1 TODO

Graph output for how is suboptimal (read unusable).

Action C<why> is not implemented yet.

C<sub main> has a lot of redundancy in some parts

=cut

}