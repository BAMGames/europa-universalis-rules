%!PS

% Path documentation
% type of path (pathtype)
%  0 -> sea/sea
%  1 -> land/land or sea/land
%  2 -> river
%  3 -> pass
%  4 -> sea strait (sea/sea)
%  5 -> land strait (sea/land or land/land)
%  6 -> border
%  7 -> lines
%  8 -> squares (closed lines)
% coordinates
%  [ 1 x y ] line
%  [ 2 x y a b c d ] curve
% path
% [ [ type bbox ] [x0 y0] [x1 y1] ...]

% Province documentation
% a province is composed of several elements
% (strongly connected components possibly with holes inside)
%
% type of province: sum of
%   1: is water
%   2: is special
%   4: is noman
%   8: is marcopolo
%  16: is othermap
%  32: is in magnification
% name is the name of the province the "prov" belongs to. A star indicates
% terrain is a key in color dicts
% moves are either 2 digits
% [ [ type name terrain bbox ] [ [moveA lineA1 lineA2] [moveB lineB1 lineB2] ...]]
% when running over various moves, if one comes to a starting point, do a move
% and define a new starting point (new array)
% A move has length 3: x y and open/closed. A province is always composed of closed
% loops only.
%
% Pathset documentation
% A pathset is a succession of paths. It is composed of several (possibly open)
% paths
% [ [ 2 name terrain bbox ] [ [moveA lineA1 lineA2] ... ]]
% same as a province, but type is 2. They are stored in pathsets instead of provs.
% They may contain open loops, opposite to provs. They can only be stroked.

systemdict /.min known not {
    /.min {2 copy gt {exch} if pop} bd
} if
systemdict /.max known not {
    /.max {2 copy lt {exch} if pop} bd
} if
/bboxset {
    /MAXy exch def /MAXx exch def /MINy exch def /MINx exch def
} bd
/bboxtest {
    MINy lt 4 1 roll MINx lt 4 1 roll MAXy gt 4 1 roll MAXx gt 4 1 roll or or or not
} bd

/paths 2000 dict def
/provs 2000 dict def
/pathsets 100 dict def
/!!! { % [ a0 a1 ... an ] => (a0 a1 ... an\n)
    0 1 index { length add 1 add } forall string 0 3 2 roll {
        3 1 roll dup 0 ne {2 copy 32 put 1 add} if 3 -1 roll
        3 copy putinterval length add
    } forall 2 copy 10 put pop
} bd

% Path analysis
/bboxinit {
    /maxy -10000 def /maxx -10000 def /miny 30000 def /minx 30000 def
} bd
/bbox { % x y => x y
    /maxy maxy 2 index .max def /miny miny 2 index .min def
    /maxx maxx 3 index .max def /minx minx 3 index .min def
} bd
/lastpoint { % x y => x y
    /lasty  1 index def /lastx 2 index def
} bd
/beginpath {
    mark pathtype bboxinit
} bd
/m {
    lastpoint bbox 2 array astore
} bd
/l {
    lastpoint bbox 2 array astore
} bd
/c {
    lastpoint bbox 6 2 roll bbox 6 2 roll bbox 6 2 roll 6 array astore
} bd
/endpath {
    counttomark array astore
    dup 0 [ pathtype minx miny maxx maxy ] put
    paths 4 -1 roll 3 -1 roll put pop
} bd
/contpath {
    lastx lasty m
} bd
/carreinit {
    /carrefile TARGET (.clp.ps)! writefile def carrefile
    [ (/carresize ) carresize 3 string cvs( def\n)
    (/carredict 100 dict def\n/provincecolors 100 dict def /detroitdict 100 dict def\n)
    ]!! writestring  
} bd
traces not {carreinit}if
/carrehook {
    carrefile [
        (carredict /) myname ( [ \() myutf (\)) myx 4 string cvs ( )
        myy 4 string cvs ( ) mypos 1 eq {(false)}{(true)}ifelse ( ] put\n)
    ]!! writestring
} bd
/carreNamesdict 10 dict def
/carre { % centerx centery below0above1 label internalname rough => -
    /rough exch def /myname exch def /mynick exch def /myutf exch def
    /mypos exch def /myy exch def /myx exch def
    /pathtype pathtype 1 index 8 def
    carreNamesdict mynick true put
    (carre) myname ! cvn beginpath
    rough {
        myx carresize sub myy carresize sub m
        myx carresize add myy carresize sub l
        myx carresize add myy carresize add l
        myx carresize sub myy carresize add l
        myx carresize sub myy carresize sub l
    } {
        /css carresize 0.8 mul def
        myx css sub myy carresize sub m
        myx css add myy carresize sub l
        myx carresize add myy css sub l
        myx carresize add myy css add l
        myx css add myy carresize add l
        myx css sub myy carresize add l
        myx carresize sub myy css add l
        myx carresize sub myy css sub l
        myx css sub myy carresize sub l
    } ifelse
    endpath def
    /mybbox [
        myx carresize sub myy carresize sub
        myx carresize add myy carresize add
    ] def
    carrehook
} def
/detroit { % detroitname [ x y angle x y angle impulse ] => ---
    carrefile [ (detroitdict) 5 -1 roll 20 string cvs (/) exch ! ([) 6 -1 roll {10 string cvs} forall (]) (put) ] !!! writestring
} bd

% Provinces analysis
/ppdef { % symbolicname type terrain mark moves [] provincename => -
    /pname exch def pop counttomark array astore /moves exch def pop
    /terrain exch def /xtype exch def
    [ [ xtype pname terrain minx miny maxx maxy ] moves ]
    xtype 2 eq {pathsets}{provs}ifelse 3 1 roll put
} bd
/beginprov {
    bboxinit /firstpoint true def mark
} bd
/provinceshook {} def
true {
    /zone {2 exch beginprov} bd
    /mer {1 /mer beginprov} bd
    /lac {5 /lac beginprov} bd
    /europemer {17 /mer beginprov} bd
    /europemerrotw {19 /mer beginprov} bd
    /terrain {0 /terrain beginprov} bd
    /noman {4 /noman beginprov} bd
    /europe {16 /terrain beginprov} bd
    /foreto {0 /foreto beginprov} bd
    /desert {0 /desert beginprov} bd
    /plaine {0 /plaine beginprov} bd
    /monts {0 /monts beginprov} bd
    /foret {0 /foret beginprov} bd
    /marais {0 /marais beginprov} bd
    /kforet {8 /foret beginprov} bd
    /kmonts {8 /monts beginprov} bd
    /kmarais {8 /marais beginprov} bd
    /kdesert {8 /desert beginprov} bd
    /kplaine {8 /plaine beginprov} bd
    /lmer {33 /mer beginprov} bd
    /ldesert {32 /desert beginprov} bd
    /lplaine {32 /plaine beginprov} bd
    /lmonts {32 /monts beginprov} bd
    /lforet {32 /foret beginprov} bd
    /lmarais {32 /marais beginprov} bd
    /lkforet {40 /foret beginprov} bd
    /lkmonts {40 /monts beginprov} bd
    /lkmarais {40 /marais beginprov} bd
    /lkdesert {40 /desert beginprov} bd
    /lkplaine {40 /plaine beginprov} bd
} if % terrains types definitions
/AS {
    /complement exch def
    /firstpoint true def % Closing a loop
    counttomark array astore dup dup 0 get [ exch aload pop complement ] 0 exch put exch
} bd
/AP {
    /p exch def p 0 get aload pop bbox pop pop bbox pop pop pop
    p 1 get firstpoint {
        dup length 2 ne {startPointIsACurve} if % DEBUG
        aload 3 1 roll /starty exch def /startx exch def
        /firstpoint false def
    } {
        aload pop lasty ne exch lastx ne or {continuationPointIsNotTheSame} if
    } ifelse
    2 1 p length 1 sub {p exch get} for
    mark 1 index aload pop /lasty exch def /lastx exch def cleartomark
    lasty starty eq lastx startx eq and {
        /firstpoint true def % Closing a loop
        counttomark array astore dup dup 0 get [ exch aload pop true ] 0 exch put exch 
    } if 
} bd
/A {paths exch get AP} bd
/AR {
    paths exch get /p exch def [ p 0 get
    % Now we revert the path
    false p length 1 sub -1 1 {
        % ~p = [ a b c d e f ], false => [ e f ] c d a b true
        %      z t x y true => [ z t x y e f ] c d a b true
        % ~p = [ a b ], false => [ a b ]
        %      z t x y true => [ z t x y a b ] false
        p exch get /pp exch def {
            pp length 6 eq {
                pp 4 get pp 5 get 6 array astore
                pp 2 get pp 3 get pp 0 get pp 1 get true
            } {
                pp aload pop 6 array astore false
            } ifelse
        } {
            pp length 6 eq {
                pp 4 get pp 5 get 2 array astore
                pp 2 get pp 3 get pp 0 get pp 1 get true
            } {
                pp false
            } ifelse
        } ifelse
    } for pop ] AP
} bd
/BH {} def
/EH {} def

% Painting
/out { t exch writestring } bd
/setrgbstroke {
    /xcolor exch def true 0 1 2 {
        /i exch def xcolor i get lastcolor i get eq and
    } for not {
        /lastcolor xcolor def
        xcolor aload pop eq exch xcolor 1 get eq and not {
            [ xcolor {10 string cvs} forall (RG) ]!!! out
        } {
            [ xcolor 0 get 10 string cvs (G) ]!!! out
        } ifelse
    } if} bd
/setrgbfill {
    /xcolor exch def true 0 1 2 {
        /i exch def xcolor i get lastfillcolor i get eq and
    } for not {
        /lastfillcolor xcolor def
        xcolor aload pop eq exch xcolor 1 get eq and not {
            [ xcolor {10 string cvs} forall (rg) ]!!! out
        } {
            [ xcolor 0 get 10 string cvs (g) ]!!! out
        } ifelse
    } if} bd
/setwidth {
     dup lastwidth ne {
        [ 1 index 7 string cvs (w) ] !!! out /lastwidth exch def
    } { pop } ifelse
} bd
/savecontext {
    (q\n) out
    /contexts [ contexts {} forall [ lastwidth lastcolor lastfillcolor ] ] def
} bd
/restorecontext {
    (Q\n) out
    /contexts [ contexts {} forall aload pop
    /lastfillcolor exch def
    /lastcolor exch def
    /lastwidth exch def
    ] def
} bd
/styleinit {
    /fillunclosed false def
    /cache /aaaaaaaaaaa def
    /pathwidth << 0 4  1 4  2 6  3 6  4 6  5 6  6 4  7 2  8 4 >> def
    /pathcolor << 
        0 [1 1 1]
        1 [0 0 0]
        2 [0.355 0.575 0.875]
        3 [1 .8 .8]
        4 [.6 .1 .1]
        5 [.6 .1 .1]
        6 [0 0 0]
        7 [0 0 0]
        8 [0 0 0]
    >> def
    /colordict <<
        /normal <<
            /mer    [.325 .6  .875    .255 .475 .775]
            /plaine [.9   .9  .7      .8   .8   .5]
            /desert [1    1   .4      .9   .9   .3]
            /monts  [.9   .6  .2      .7   .5   .3]
            /foret  [.6   1   .3      .4   .9   .4]
            /foreto [.6   .8  .6      .5   .7   .5]
            /marais [.5   .6  .5      .3   .4   .3]
            /terrain[0    0   0       1    1    1 ]
            /noman  [1    1   1       .8   .8   9 ]
            /lac    [.425 .7  1       .355 .575 .875]
        >>
        /othermap <<
            /mer    [0.425 0.9 0.875    0.355 0.775 0.775]
            /terrain[0.8 0.8 0.8    0.7 0.7 0.85]
        >>
    >> def
    colordict /marcopolo <<
        colordict /normal get {} forall
    >> put
    colordict /magnification <<
        colordict /normal get {
            [ exch aload pop 2 {
                3 copy add add /tmp exch def 3 {
                    3 1 roll tmp add 4 div
                } repeat 6 3 roll
            } repeat ]
        } forall
    >> put
    /lastwidth -1 def
    /lastcolor [ -1 -1 -1 ] def
    /lastfillcolor [ -1 -1 -1 ] def
    /contexts [] def
} bd
/percent ( ) dup 0 37 put def
/provbboxtest {
    pp 3 4 getinterval aload pop bboxtest
} bd 
/colorinterpolate {
    /.coa exch def /.cob 1 .coa sub def
    [ exch aload pop 3 {4 -1 roll .coa mul 1 index .cob mul add 4 1 roll 6 1 roll} repeat 6 3 roll pop pop pop ]
} bd
/sortpaths { % sorts paths by type in sortedpaths
    /sortedpaths [ 10 { 10 dict } repeat ] def
    paths {
        0 get dup 1 4 getinterval aload pop bboxtest {
            0 get sortedpaths exch get exch true put
        } {
            pop pop
        } ifelse
    } forall
} bd
/drawpaths { % type => -
    /currenttype exch def
    pathwidth currenttype get setwidth
    pathcolor currenttype get setrgbstroke
    sortedpaths currenttype get {
        pop paths exch get /p exch def
        [ p 1 get {10 string cvs} forall (m) ]!!! out
        2 1 p length 1 sub {
            [ exch p exch get {10 string cvs} forall
            counttomark 6 eq {(c)}{(l)}ifelse ]!!! out
        } for (S\n) out 
    } forall
} bd
/drawpathsschematic { % type => -
    /currenttype exch def
    sortedpaths currenttype get {
        pop /pn exch def /p paths pn get def
        p 1 get aload pop /ys exch def /xs exch def
        p p length 1 sub get aload pop /ye exch def /xe exch def
        [0 0 1] setrgbstroke
        1 setwidth [ xs ys (m) 
        2 1 p length 1 sub {
            p exch get dup length 2 eq {
                aload pop (l)
            } {
                dup 4 get exch 5 get (l)
            } ifelse
        } for (S) ] [ exch {10 string cvs} forall ]!!! out 
        [.4 .4 1] setrgbfill
        1 1 p length 1 sub {
            p exch get dup length 2 eq {
                aload pop /yy exch def /xx exch def
            } {
                dup 4 get /xx exch def 5 get /yy exch def
            } ifelse
            [[xx 1 add yy (m) xx yy 1 add (l) xx 1 sub yy (l) xx yy 1 sub (l f)
             ] {10 string cvs} forall ]!!! out
        } for
        3 setwidth
        [1 1 1] setrgbstroke
        [ [ xs ys (m) xe ye (l S) ]{10 string cvs} forall ]!!! dup out
        2 setwidth [0 0 0] setrgbstroke out [0 0 0] setrgbfill
        carrefile [
        xe xs ne ye ys ne or {
            (\(q )
            [[xe xs sub ye ys sub atan dup sin exch cos dup neg 2 index
            xs xe add 2 div ys ye add 2 div]{12 string cvs}forall (cm)]!!!
            (\) out)
        } {
            (\(q 1 0 0 1 )xs xe add 2 div 10 string cvs ( )
            ys ye add 2 div 10 string cvs ( cm \)out\n)
        } ifelse
        (\() pn 30 string cvs (\) 0 0 100 12 (FontArialNarrow) centertextbbox (Q )out)
        ] !! writestring
    } forall
} bd
/drawcontourprov { % define pn and p first
    pn cache ne {/debug false def
        /cache pn def /cachedstring [
            0 1 p 1 get length 1 sub {
            /closedsegment true def
            p 1 get exch get {
                dup length 5 lt {
                    dup length 3 eq {
                        aload pop dup type /arraytype eq {
                            /complementsegment exch def
                            /closedsegment false def
                        } {
                            pop /closedsegment true def
                        }ifelse
                        10 string cvs exch 10 string cvs exch ( ) exch ( m\n) 
                    } {
                        aload pop
                        10 string cvs exch 10 string cvs exch ( ) exch ( l\n)
                    } ifelse 
                } {
                    {10 string cvs ( )} forall (c\n) 
                } ifelse
            } forall
            closedsegment {(h\n)}{
                fillunclosed {
                    complementsegment {
                        aload pop
                        10 string cvs exch 10 string cvs exch ( ) exch ( l\n)
                    } forall (h\n) /cache /aaa def
                } if
            } ifelse
        } for ] !! def 
    } if cachedstring
} bd
/provcolors { % - => -
        /xtype pp 0 get def
        /terrain pp 2 get def
        /colorset {
            xtype 8 and 0 ne marcopoloisimportant and { /marcopolo exit } if
            xtype 16 and 0 ne { /othermap exit } if
            xtype 32 and 0 ne { /magnification exit } if
            /normal exit
        } loop def
        /colors colordict colorset get terrain get def    
} bd
/drawprovs {
    /.proc exch def
    provs { /p exch def /pn exch def /pp p 0 get def
        provbboxtest {
            traces not {[ percent pn 40 string cvs pp 1 get ] !!! out}if
            provcolors .proc
        } if
    } forall
} bd
/drawpathsets {
    /.proc exch def
    pathsets { /p exch def /pn exch def /pp p 0 get def
        provbboxtest {
            [ percent pn 40 string cvs pp 1 get ] !!! out
            .proc
        } if
    } forall
} bd
styleinit

/outputGroupsNames {
    carrefile (/namesdict <<\n) writestring [
        pathsets {
            0 get /header exch def pop
            header 1 get dup 0 40 put
            ( [) dup 0 41 put colordict /special get header 2 get get {
                12 string cvs ( )
            } forall pop (]\n)
        } forall
    ]!! carrefile exch writestring
    carrefile (>> def\n) writestring
} bd
/outputClips {
    carrefile (/clippeddict 3 dict def\n) writestring
    clipped { /pn exch def /p provs pn get def
        carrefile [
            (clippeddict\() p 0 get 1 get (\)\() drawcontourprov (\)put\n)
        ]!! writestring
    }forall
} bd

% Set of painting styles
/dopage_simple_white_background {
    /t TARGET (.clp) ! writefile def
    (1 w 1 j 1 J\n) out % linewidth linecap linejoin
    sortpaths 
    /pathwidth << 0 4  1 4  2 4  3 8  4 6  5 6  6 4  7 2  8 4 >> def
    /pathcolor << pathcolor {pop[0 0 0]}forall >> def
    pathcolor 2  [0 0 1] put
    pathcolor 3 [.5 .5 .5] put
    {
        pp 0 get 13 and 0 ne {
            savecontext
            pp 0 get 4 and 0 ne {
                (.5 g\n)
            }{
                pp 0 get 8 and 0 ne {
                    (.8 g\n)
                } {
                    (.95 g\n)
                } ifelse
            }ifelse out
            drawcontourprov out (f\n) out
            restorecontext
        } if
    } drawprovs
    {
        savecontext
        colordict /special get pp 2 get get setrgbstroke
        specialwidth setwidth
        /fillunclosed true def
        drawcontourprov out
        /fillunclosed false def
        (W n\n) out
        drawcontourprov out (S\n) out           
        restorecontext
    } drawpathsets
    [ 0 8 1 6 7 4 5 2 3 ] {drawpaths} forall
    t closefile
    outputGroupsNames
} bd
/dopage_simple_color_background {
    /t TARGET (.clp) ! writefile def
    (1 w 1 j 1 J\n) out % linewidth linecap linejoin
    sortpaths
    {
        savecontext
        colors 0 3 getinterval setrgbfill
        colors 3 3 getinterval setrgbstroke
        20 setwidth
        drawcontourprov out (W n\n) out
        drawcontourprov out (B\n) out
        restorecontext
    } drawprovs
    /found false def
    {
        savecontext
        colordict /special get pp 2 get get setrgbstroke
        50 setwidth
        /fillunclosed true def
        drawcontourprov out
        /fillunclosed false def
        (W n\n) out
        (/GSalphaZone gs\n)out
        drawcontourprov out (S\n) out           
        restorecontext
        /found true def
    } drawpathsets
    found {
        carrefile (<< /Type /ExtGState /LC 0 /CA .5 >> (GSalphaZone) defobj\n) writestring
        carrefile (\(GSalphaZone\) /pagegss push\n) writestring
    } if
    [ percent (Paths) ] !!! out
    [ 0 8 1 6 7 4 5 2 3 ] {drawpaths} forall
    t closefile
    outputClips
    outputGroupsNames
} bd
/dopage_rich_color_background {
    /t TARGET (.clp) ! writefile def
    (1 w 1 j 1 J\n) out % linewidth linecap linejoin
    sortpaths
    {
        savecontext
        colors 0 3 getinterval setrgbfill
        drawcontourprov out (W n\n) out
        drawcontourprov out (f\n) out
        1 -.1 0 {
            /step exch def
            colors step colorinterpolate setrgbstroke
            20 30 step mul add setwidth
            drawcontourprov out (S\n) out
        } for
        drawcontourprov out (S\n) out
        restorecontext
    } drawprovs
    /found false def
    {
        savecontext
        colordict /special get pp 2 get get setrgbstroke
        50 setwidth
        /fillunclosed true def
        drawcontourprov out
        /fillunclosed false def
        (W n\n) out
        (/GSalphaZone gs\n)out
        1 -.1 0 {
            /step exch def
            20 30 step mul add setwidth
            drawcontourprov out (S\n) out
        } for
        /found true def
        restorecontext
    } drawpathsets
    found {
        carrefile (<< /Type /ExtGState /LC 0 /CA .075 >> (GSalphaZone) defobj\n) writestring
        carrefile (\(GSalphaZone\) /pagegss push\n) writestring
    } if
    [ 0 8 1 6 7 4 5 2 3 ] {drawpaths} forall
    t closefile
    outputClips
    outputGroupsNames
} bd
/dopage_schematic_color_background {
    /t TARGET (.clp) ! writefile def
    (1 w 1 j 1 J\n) out % linewidth linecap linejoin
    sortpaths
    {
        savecontext
        colors 0 3 getinterval setrgbfill
        drawcontourprov out (W n\n) out
        drawcontourprov out (f\n) out
        carrefile [
            ((0 G 0 g )out \() pp 1 get (\) ) pp 3 4 getinterval aload pop exch 4 1 roll add 2 div 12 string cvs
            3 1 roll add 2 div 12 string cvs exch ( ) exch ( 100 )pp 1 get 0 get 42 eq{(9)}{(18)}ifelse((FontArialNarrow-Bold) centertextbbox\n)
        ]!! writestring
        restorecontext
    } drawprovs
    /found false def
    {
        savecontext
        colordict /special get pp 2 get get setrgbstroke
        20 setwidth
        /fillunclosed true def
        drawcontourprov out
        /fillunclosed false def
        (W n\n) out
        (/GSalphaZone gs\n)out
        drawcontourprov out (S\n) out           
        /found true def
        restorecontext
    } drawpathsets
    found {
        carrefile (<< /Type /ExtGState /LC 0 /D [[20] 0] >> (GSalphaZone) defobj\n) writestring
        carrefile (\(GSalphaZone\) /pagegss push\n) writestring
    } if
    [ percent (Paths) ] !!! out
    [ 0 8 1 6 7 4 5 2 3 ] {drawpaths} forall
    [ 0 8 1 6 7 4 5 2 3 ] {drawpathsschematic} forall
    t closefile
} bd

% Traces
/tracestr { t exch writestring } bd
/traceinit {
    /t TARGET (.js) ! writefile def
    (var contours;\nif \(contours == undefined\) {contours=[];}\ncontoursbase=contours.length;\n\n) tracestr
    (var contourssections;\nif \(contourssections == undefined\) {contourssections={};}\ncontourssections[') tracestr
    mapname tracestr
    (']={s:contours.length};\n\n) tracestr    
} bd
/tracefinish {
    (\n\ncontourssections[') tracestr
    mapname tracestr
    (']['e']=contours.length;\n) tracestr
    t closefile
} bd
/tracebboxtest {% [ a b c d ] [ a' b' c' d' ] => true if no intersection
    2 copy 0 get exch 2 get gt 3 1 roll
    2 copy 2 get exch 0 get lt 3 1 roll
    2 copy 1 get exch 3 get gt 3 1 roll
    3 get exch 1 get lt or or or
} bd
/displayvector {
    4 -1 roll 12 string cvs (<)exch !(,)! 4 -1 roll 12 string cvs !( -- )!
    3 -1 roll 12 string cvs !(,)! exch 12 string cvs !(>)!
} bd
/tracesegmentintersect {% [x0 y0 x1 y1] [a0 b0 a1 b1 a2 b2 ... an bn] => bool
    % true if P0P1 intersects any P'(i)P'(i+1)
    /vcross false def
    /vv exch def /v1 exch def
    /v1x0 v1 0 get def
    /v1y0 v1 1 get def
    /v1x1 v1 2 get def
    /v1y1 v1 3 get def
    /v1x v1x1 v1x0 sub def
    /v1y v1y1 v1y0 sub def
    /v2xx -1 def
    /v2yy -1 def
    /v2x1 -1 def
    /v2y1 -1 def
    0 2 vv length 1 sub {
        /vim exch def
        /v2x0 v2x1 def
        /v2y0 v2y1 def
        /v2x1 vv vim get def
        /v2y1 vv vim 1 add get def
        v2xx -1 eq {
            /v2xx v2x1 def
            /v2yy v2y1 def
        } {
            /v2x v2x1 v2x0 sub def 
            /v2y v2y1 v2y0 sub def
            /vd v1x v2y mul v2x v1y mul sub def
            vd 0 ne {
                /vs v1y v2x0 v1x0 sub mul v1x v1y0 v2y0 sub mul add vd div def
                /vt v2x v1y0 v2y0 sub mul v2y v1x0 v2x0 sub mul sub vd div def
                vs 0 ge vs 1 le and vt 0 ge vt 1 le and and {
                    /vcross true def exit
                } if
            } if
        } ifelse
    } for
    vcross
} bd
/dopage_traces_background {
    10 setflat
    /carreprefix (magic) def
    magic {dup 1 4 getinterval /mybbox exch def
    0 get /mynick exch def
    /myname mynick def
    carrehook
    } forall
    {
        pp 1 get 0 get 42 ne {
            /tbbox pp 3 4 getinterval def
            /tname pp 1 get def
            /torigin pn 30 string cvs def
            /tover [
                specialdict {
                    tbbox tracebboxtest {pop} if
                } forall
            ] def
            /tpath [
                0 1 p 1 get length 1 sub {
                    /i exch def [ p 1 get i get
                    newpath 
                    { 
                        dup length 3 eq {
                            aload pop pop moveto
                        } { 
                            dup length 2 eq {
                                aload pop lineto
                            } {
                                aload pop curveto
                            } ifelse
                        } ifelse
                    } forall
                    closepath flattenpath
                    {}{}{}{}pathforall ]
                } for
            ] def
            /tover [ tover {
                /tw 0 def % 0 : not inside
                /tcandidate exch def /tcand specialdict tcandidate get def
                {
                    tcand aload pop 3 -1 roll add 2 div /ty exch def
                    add 2 div /tx exch def
                    /txx -1 def /tyy -1 def
                    /ta -1 def /tb -1 def /tc -1 def /td -1 def
                    /tenv tpath 0 get def /tw 0 def
                    0 2 tenv length 1 sub {
                        /tm exch def
                        /ta tc def /tb td def
                        /tc tenv tm get def
                        /td tenv tm 1 add get def
                        txx -1 eq {
                            /txx tc def /tyy td def
                        } {
                            /tval tx ta sub td tb sub mul ty tb sub tc ta sub mul sub def
                            td ty gt tb ty le and tval 0 le and {
                                /tw tw 1 add def
                            } if
                            td ty lt tb ty ge and tval 0 ge and {
                                /tw tw 1 sub def
                            } if
                            txx tc eq tyy td eq and {
                                /txx -1 def /tyy -1 def
                            } if
                        } ifelse
                    } for
                    tw 0 ne {exit}if % Center inside tenv! great!
                    % Now we have to see if the bbox of the special does intersect with
                    % a line of the envelop
                    [ tcand 0 get tcand 1 get tcand 2 get tcand 1 get ] tenv tracesegmentintersect
                    {/tw 1 def exit}if
                    [ tcand 2 get tcand 1 get tcand 2 get tcand 3 get ] tenv tracesegmentintersect
                    {/tw 1 def exit}if
                    [ tcand 2 get tcand 3 get tcand 0 get tcand 3 get ] tenv tracesegmentintersect
                    {/tw 1 def exit}if
                    [ tcand 0 get tcand 3 get tcand 0 get tcand 1 get ] tenv tracesegmentintersect
                    {/tw 1 def exit}if
                    exit
                }loop
                tw 0 ne { tcandidate } if
            } forall ] def
            /tpath [ tpath {aload pop} forall ] def
            [
                (contours.push\({n:')tname
                (',t:1,o:')torigin
                tover length 0 ne {
                    (',m:[)tover {
                        10 string cvs (+contoursbase)(,)
                    }forall pop(])
                }{(')} ifelse
                (,c:)tpath tracecommalist
                (',b:)tbbox tracecommalist
                (}\);\n)
            ]!! tracestr
        } if
    } drawprovs
} bd
/tracebox {% name origin bbox
    /tbbox exch def
    /torigin exch def
    /tname exch def
    [(contours.push\({n:')tname(',t:2,o:')torigin(',b:)tbbox tracecommalist(}\);\n)]!! tracestr
} def
/tracecommalist {
    [exch([) exch true exch {
        exch {
            xfact mul xbase add .5 add cvi
            12 string cvs(,)
            false
        } {
            yfact mul ybase add .5 add cvi
            12 string cvs(,)
            true
        } ifelse
    }forall pop pop(])]!!
} bd
traces {
    /BH {mark} bd
    /EH {mark ne {NHEHmechanismfailed}if cleartomark mark} bd
    /detroit { pop pop } bd
    /carreinit {
        /carreprefix (carre) def
        /specialcounter 0 def
        /specialdict 10 dict def
        /specialcarredict 10 dict def
    } def
    carreinit
    /carrehook {
        mynick 0 get 42 ne {
            mynick carreprefix myname ! mybbox tracebox
            specialcarredict specialcounter myutf put
            specialdict specialcounter tbbox put
            /specialcounter specialcounter 1 add def
        } if
    } bd
} if
